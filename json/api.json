{
 "nvim__buf_redraw_range": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "first"
   ],
   [
    "Integer",
    "last"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim__buf_stats": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim__get_hl_defs": {
  "params": [
   [
    "Integer",
    "ns_id"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim__get_lib_dir": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim__id": {
  "params": [
   [
    "Object",
    "obj"
   ]
  ],
  "params_doc": {
   "obj": "Object to return."
  },
  "doc": "Returns object given as argument.\nThis API function is used for testing. One should not rely on\nits presence in plugins.",
  "return": "its argument.",
  "seealso": []
 },
 "nvim__id_array": {
  "params": [
   [
    "Array",
    "arr"
   ]
  ],
  "params_doc": {
   "arr": "Array to return."
  },
  "doc": "Returns array given as argument.\nThis API function is used for testing. One should not rely on\nits presence in plugins.",
  "return": "its argument.",
  "seealso": []
 },
 "nvim__id_dictionary": {
  "params": [
   [
    "Dictionary",
    "dct"
   ]
  ],
  "params_doc": {
   "dct": "Dictionary to return."
  },
  "doc": "Returns dictionary given as argument.\nThis API function is used for testing. One should not rely on\nits presence in plugins.",
  "return": "its argument.",
  "seealso": []
 },
 "nvim__id_float": {
  "params": [
   [
    "Float",
    "flt"
   ]
  ],
  "params_doc": {
   "flt": "Value to return."
  },
  "doc": "Returns floating-point value given as argument.\nThis API function is used for testing. One should not rely on\nits presence in plugins.",
  "return": "its argument.",
  "seealso": []
 },
 "nvim__inspect_cell": {
  "params": [
   [
    "Integer",
    "grid"
   ],
   [
    "Integer",
    "row"
   ],
   [
    "Integer",
    "col"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "NB: if your UI doesn't use hlstate, this will not return\nhlstate first time.",
  "seealso": []
 },
 "nvim__screenshot": {
  "params": [
   [
    "String",
    "path"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim__set_hl_ns": {
  "params": [
   [
    "Integer",
    "ns_id"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "ns_id": "the namespace to activate"
  },
  "doc": "Set active namespace for highlights.\nNB: this function can be called from async contexts, but the\nsemantics are not yet well-defined. To start with\n|nvim_set_decoration_provider| on_win and on_line callbacks\nare explicitly allowed to change the namespace during a redraw\ncycle.",
  "seealso": []
 },
 "nvim__stats": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets internal stats.",
  "return": "Map of various internal stats.",
  "seealso": []
 },
 "nvim_buf_add_highlight": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "String",
    "hl_group"
   ],
   [
    "Integer",
    "line"
   ],
   [
    "Integer",
    "col_start"
   ],
   [
    "Integer",
    "col_end"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "namespace to use or -1 for ungrouped\n                 highlight",
   "hl_group": "Name of the highlight group to use",
   "line": "Line to highlight (zero-indexed)",
   "col_start": "Start of (byte-indexed) column range to\n                 highlight",
   "col_end": "End of (byte-indexed) column range to\n                 highlight, or -1 to highlight to end of line"
  },
  "doc": "Adds a highlight to buffer.\nUseful for plugins that dynamically generate highlights to a\nbuffer (like a semantic highlighter or linter). The function\nadds a single highlight to a buffer. Unlike |matchaddpos()|\nhighlights follow changes to line numbering (as lines are\ninserted/removed above the highlighted line), like signs and\nmarks do.\nNamespaces are used for batch deletion/updating of a set of\nhighlights. To create a namespace, use\n|nvim_create_namespace()| which returns a namespace id. Pass\nit in to this function as `ns_id` to add highlights to the\nnamespace. All highlights in the same namespace can then be\ncleared with single call to |nvim_buf_clear_namespace()|. If\nthe highlight never will be deleted by an API call, pass\n`ns_id = -1` .\nAs a shorthand, `ns_id = 0` can be used to create a new\nnamespace for the highlight, the allocated id is then\nreturned. If `hl_group` is the empty string no highlight is\nadded, but a new `ns_id` is still returned. This is supported\nfor backwards compatibility, new code should use\n|nvim_create_namespace()| to create a new empty namespace.",
  "return": "The ns_id that was used",
  "seealso": []
 },
 "nvim_buf_attach": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Boolean",
    "send_buffer"
   ],
   [
    "DictionaryOf(LuaRef)",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "send_buffer": "True if the initial notification should\n                   contain the whole buffer: first\n                   notification will be `nvim_buf_lines_event`\n                   . Else the first notification will be\n                   `nvim_buf_changedtick_event` . Not for Lua\n                   callbacks.",
   "opts": "Optional parameters.\n                   • on_lines: Lua callback invoked on change.\n                     Return`true`to detach. Args:\n                     • the string \"lines\"\n                     • buffer handle\n                     • b:changedtick\n                     • first line that changed (zero-indexed)\n                     • last line that was changed\n                     • last line in the updated range\n                     • byte count of previous contents\n                     • deleted_codepoints (if `utf_sizes` is\n                       true)\n                     • deleted_codeunits (if `utf_sizes` is\n                       true)\n\n                   • on_bytes: lua callback invoked on change.\n                     This callback receives more granular\n                     information about the change compared to\n                     on_lines. Return`true`to detach. Args:\n                     • the string \"bytes\"\n                     • buffer handle\n                     • b:changedtick\n                     • start row of the changed text\n                       (zero-indexed)\n                     • start column of the changed text\n                     • byte offset of the changed text (from\n                       the start of the buffer)\n                     • old end row of the changed text\n                     • old end column of the changed text\n                     • old end byte length of the changed text\n                     • new end row of the changed text\n                     • new end column of the changed text\n                     • new end byte length of the changed text\n\n                   • on_changedtick: Lua callback invoked on\n                     changedtick increment without text\n                     change. Args:\n                     • the string \"changedtick\"\n                     • buffer handle\n                     • b:changedtick\n\n                   • on_detach: Lua callback invoked on\n                     detach. Args:\n                     • the string \"detach\"\n                     • buffer handle\n\n                   • on_reload: Lua callback invoked on\n                     reload. The entire buffer content should\n                     be considered changed. Args:\n                     • the string \"detach\"\n                     • buffer handle\n\n                   • utf_sizes: include UTF-32 and UTF-16 size\n                     of the replaced region, as args to\n                     `on_lines` .\n                   • preview: also attach to command preview\n                     (i.e. 'inccommand') events."
  },
  "doc": "Activates buffer-update events on a channel, or as Lua\ncallbacks.\nExample (Lua): capture buffer updates in a global `events` variable (use \"print(vim.inspect(events))\" to see its\ncontents): >\n  events = {}\n  vim.api.nvim_buf_attach(0, false, {\n    on_lines=function(...) table.insert(events, {...}) end})\n\n<",
  "return": "False if attach failed (invalid parameter, or buffer isn't\n    loaded); otherwise True. TODO: LUA_API_NO_EVAL",
  "seealso": [
   "|nvim_buf_detach()|",
   "|api-buffer-updates-lua|"
  ]
 },
 "nvim_buf_call": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "LuaRef",
    "fun"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "fun": "Function to call inside the buffer (currently\n              lua callable only)"
  },
  "doc": "call a function with buffer as temporary current buffer\nThis temporarily switches current buffer to \"buffer\". If the\ncurrent window already shows \"buffer\", the window is not\nswitched If a window inside the current tabpage (including a\nfloat) already shows the buffer One of these windows will be\nset as current window temporarily. Otherwise a temporary\nscratch window (calleed the \"autocmd window\" for historical\nreasons) will be used.\nThis is useful e.g. to call vimL functions that only work with\nthe current buffer/window currently, like |termopen()|.",
  "return": "Return value of function. NB: will deepcopy lua values\n    currently, use upvalues to send lua references in and out.",
  "seealso": []
 },
 "nvim_buf_clear_namespace": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "Integer",
    "line_start"
   ],
   [
    "Integer",
    "line_end"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "Namespace to clear, or -1 to clear all\n                  namespaces.",
   "line_start": "Start of range of lines to clear",
   "line_end": "End of range of lines to clear (exclusive)\n                  or -1 to clear to end of buffer."
  },
  "doc": "Clears namespaced objects (highlights, extmarks, virtual text)\nfrom a region.\nLines are 0-indexed. |api-indexing| To clear the namespace in\nthe entire buffer, specify line_start=0 and line_end=-1.",
  "seealso": []
 },
 "nvim_buf_del_extmark": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "Integer",
    "id"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "Namespace id from |nvim_create_namespace()|",
   "id": "Extmark id"
  },
  "doc": "Removes an extmark.",
  "return": "true if the extmark was found, else false",
  "seealso": []
 },
 "nvim_buf_del_keymap": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "mode"
   ],
   [
    "String",
    "lhs"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Unmaps a buffer-local |mapping| for the given mode.",
  "seealso": [
   "|nvim_del_keymap()|"
  ]
 },
 "nvim_buf_del_var": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Variable name"
  },
  "doc": "Removes a buffer-scoped (b:) variable",
  "seealso": []
 },
 "nvim_buf_delete": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "opts": "Optional parameters. Keys:\n              • force: Force deletion and ignore unsaved\n                changes.\n              • unload: Unloaded only, do not delete. See\n                |:bunload|"
  },
  "doc": "Deletes the buffer. See |:bwipeout|",
  "seealso": []
 },
 "nvim_buf_detach": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Deactivates buffer-update events on the channel.",
  "return": "False if detach failed (because the buffer isn't loaded);\n    otherwise True.",
  "seealso": [
   "|nvim_buf_attach()|",
   "|api-lua-detach| for detaching Lua callbacks"
  ]
 },
 "nvim_buf_get_changedtick": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Gets a changed tick of a buffer",
  "return": "`b:changedtick` value.",
  "seealso": []
 },
 "nvim_buf_get_commands": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "opts": "Optional parameters. Currently not used."
  },
  "doc": "Gets a map of buffer-local |user-commands|.",
  "return": "Map of maps describing commands.",
  "seealso": []
 },
 "nvim_buf_get_extmark_by_id": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "Integer",
    "id"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "Namespace id from |nvim_create_namespace()|",
   "id": "Extmark id",
   "opts": "Optional parameters. Keys:\n              • details: Whether to include the details dict"
  },
  "doc": "Gets the position (0-indexed) of an extmark.",
  "return": "0-indexed (row, col) tuple or empty list () if extmark id\n    was absent",
  "seealso": []
 },
 "nvim_buf_get_extmarks": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "Object",
    "start"
   ],
   [
    "Object",
    "end"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "Namespace id from |nvim_create_namespace()|",
   "start": "Start of range: a 0-indexed (row, col) or valid\n              extmark id (whose position defines the bound).\n              |api-indexing|",
   "end": "End of range (inclusive): a 0-indexed (row, col)\n              or valid extmark id (whose position defines the\n              bound). |api-indexing|",
   "opts": "Optional parameters. Keys:\n              • limit: Maximum number of marks to return\n              • details Whether to include the details dict"
  },
  "doc": "Gets extmarks in \"traversal order\" from a |charwise| region\ndefined by buffer positions (inclusive, 0-indexed\n|api-indexing|).\nRegion can be given as (row,col) tuples, or valid extmark ids\n(whose positions define the bounds). 0 and -1 are understood\nas (0,0) and (-1,-1) respectively, thus the following are\nequivalent:\n>\n  nvim_buf_get_extmarks(0, my_ns, 0, -1, {})\n  nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})\n\n<\nIf `end` is less than `start` , traversal works backwards.\n(Useful with `limit` , to get the first marks prior to a given\nposition.)\nExample:\n>\n  local a   = vim.api\n  local pos = a.nvim_win_get_cursor(0)\n  local ns  = a.nvim_create_namespace('my-plugin')\n  -- Create new extmark at line 1, column 1.\n  local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, 0, {})\n  -- Create new extmark at line 3, column 1.\n  local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, 0, {})\n  -- Get extmarks only from line 3.\n  local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})\n  -- Get all marks in this buffer + namespace.\n  local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})\n  print(vim.inspect(ms))\n\n<",
  "return": "List of [extmark_id, row, col] tuples in \"traversal\n    order\".",
  "seealso": []
 },
 "nvim_buf_get_keymap": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "mode"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "mode": "Mode short-name (\"n\", \"i\", \"v\", ...)",
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Gets a list of buffer-local |mapping| definitions.",
  "return": "Array of maparg()-like dictionaries describing mappings.\n    The \"buffer\" key holds the associated buffer handle.",
  "seealso": []
 },
 "nvim_buf_get_lines": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "start"
   ],
   [
    "Integer",
    "end"
   ],
   [
    "Boolean",
    "strict_indexing"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "start": "First line index",
   "end": "Last line index (exclusive)",
   "strict_indexing": "Whether out-of-bounds should be an\n                       error."
  },
  "doc": "Gets a line-range from the buffer.\nIndexing is zero-based, end-exclusive. Negative indices are\ninterpreted as length+1+index: -1 refers to the index past the\nend. So to get the last element use start=-2 and end=-1.\nOut-of-bounds indices are clamped to the nearest valid value,\nunless `strict_indexing` is set.",
  "return": "Array of lines, or empty array for unloaded buffer.",
  "seealso": []
 },
 "nvim_buf_get_mark": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Mark name"
  },
  "doc": "Return a tuple (row,col) representing the position of the\nnamed mark.\nMarks are (1,0)-indexed. |api-indexing|",
  "return": "(row, col) tuple",
  "seealso": []
 },
 "nvim_buf_get_name": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Gets the full file name for the buffer",
  "return": "Buffer name",
  "seealso": []
 },
 "nvim_buf_get_offset": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "index"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "index": "Line index"
  },
  "doc": "Returns the byte offset of a line (0-indexed). |api-indexing|\nLine 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is\none byte. 'fileformat' and 'fileencoding' are ignored. The\nline index just after the last line gives the total byte-count\nof the buffer. A final EOL byte is counted if it would be\nwritten, see 'eol'.\nUnlike |line2byte()|, throws error for out-of-bounds indexing.\nReturns -1 for unloaded buffer.",
  "return": "Integer byte offset, or -1 for unloaded buffer.",
  "seealso": []
 },
 "nvim_buf_get_option": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Option name"
  },
  "doc": "Gets a buffer option value",
  "return": "Option value",
  "seealso": []
 },
 "nvim_buf_get_var": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Variable name"
  },
  "doc": "Gets a buffer-scoped (b:) variable.",
  "return": "Variable value",
  "seealso": []
 },
 "nvim_buf_is_loaded": {
  "params": [
   [
    "Buffer",
    "buffer"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Checks if a buffer is valid and loaded. See |api-buffer| for\nmore info about unloaded buffers.",
  "return": "true if the buffer is valid and loaded, false otherwise.",
  "seealso": []
 },
 "nvim_buf_is_valid": {
  "params": [
   [
    "Buffer",
    "buffer"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Checks if a buffer is valid.\n\nNote:\n    Even if a buffer is valid it may have been unloaded. See\n    |api-buffer| for more info about unloaded buffers.\n",
  "return": "true if the buffer is valid, false otherwise.",
  "seealso": []
 },
 "nvim_buf_line_count": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Gets the buffer line count",
  "return": "Line count, or 0 for unloaded buffer. |api-buffer|",
  "seealso": []
 },
 "nvim_buf_set_extmark": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "ns_id"
   ],
   [
    "Integer",
    "line"
   ],
   [
    "Integer",
    "col"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "ns_id": "Namespace id from |nvim_create_namespace()|",
   "line": "Line where to place the mark, 0-based.\n              |api-indexing|",
   "col": "Column where to place the mark, 0-based.\n              |api-indexing|",
   "opts": "Optional parameters.\n              • id : id of the extmark to edit.\n              • end_line : ending line of the mark, 0-based\n                inclusive.\n              • end_col : ending col of the mark, 0-based\n                exclusive.\n              • hl_group : name of the highlight group used to\n                highlight this mark.\n              • virt_text : virtual text to link to this mark.\n                A list of [text, highlight] tuples, each\n                representing a text chunk with specified\n                highlight. `highlight` element can either be a\n                a single highlight group, or an array of\n                multiple highlight groups that will be stacked\n                (highest priority last). A highlight group can\n                be supplied either as a string or as an\n                integer, the latter which can be obtained\n                using |nvim_get_hl_id_by_name|.\n              • virt_text_pos : position of virtual text.\n                Possible values:\n                • \"eol\": right after eol character (default)\n                • \"overlay\": display over the specified\n                  column, without shifting the underlying\n                  text.\n                • \"right_align\": display right aligned in the\n                  window.\n\n              • virt_text_win_col : position the virtual text\n                at a fixed window column (starting from the\n                first text column)\n              • virt_text_hide : hide the virtual text when\n                the background text is selected or hidden due\n                to horizontal scroll 'nowrap'\n              • hl_mode : control how highlights are combined\n                with the highlights of the text. Currently\n                only affects virt_text highlights, but might\n                affect`hl_group`in later versions.\n                • \"replace\": only show the virt_text color.\n                  This is the default\n                • \"combine\": combine with background text\n                  color\n                • \"blend\": blend with background text color.\n\n              • hl_eol : when true, for a multiline highlight\n                covering the EOL of a line, continue the\n                highlight for the rest of the screen line\n                (just like for diff and cursorline highlight).\n              • ephemeral : for use with\n                |nvim_set_decoration_provider| callbacks. The\n                mark will only be used for the current redraw\n                cycle, and not be permantently stored in the\n                buffer.\n              • right_gravity : boolean that indicates the\n                direction the extmark will be shifted in when\n                new text is inserted (true for right, false\n                for left). defaults to true.\n              • end_right_gravity : boolean that indicates the\n                direction the extmark end position (if it\n                exists) will be shifted in when new text is\n                inserted (true for right, false for left).\n                Defaults to false.\n              • priority: a priority value for the highlight\n                group. For example treesitter highlighting\n                uses a value of 100."
  },
  "doc": "Creates or updates an extmark.\nTo create a new extmark, pass id=0. The extmark id will be\nreturned. To move an existing mark, pass its id.\nIt is also allowed to create a new mark by passing in a\npreviously unused id, but the caller must then keep track of\nexisting and unused ids itself. (Useful over RPC, to avoid\nwaiting for the return value.)\nUsing the optional arguments, it is possible to use this to\nhighlight a range of text, and also to associate virtual text\nto the mark.",
  "return": "Id of the created/updated extmark",
  "seealso": []
 },
 "nvim_buf_set_keymap": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "mode"
   ],
   [
    "String",
    "lhs"
   ],
   [
    "String",
    "rhs"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer"
  },
  "doc": "Sets a buffer-local |mapping| for the given mode.",
  "seealso": [
   "|nvim_set_keymap()|"
  ]
 },
 "nvim_buf_set_lines": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "start"
   ],
   [
    "Integer",
    "end"
   ],
   [
    "Boolean",
    "strict_indexing"
   ],
   [
    "ArrayOf(String)",
    "replacement"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "start": "First line index",
   "end": "Last line index (exclusive)",
   "strict_indexing": "Whether out-of-bounds should be an\n                       error.",
   "replacement": "Array of lines to use as replacement"
  },
  "doc": "Sets (replaces) a line-range in the buffer.\nIndexing is zero-based, end-exclusive. Negative indices are\ninterpreted as length+1+index: -1 refers to the index past the\nend. So to change or delete the last element use start=-2 and\nend=-1.\nTo insert lines at a given index, set `start` and `end` to the\nsame index. To delete a range of lines, set `replacement` to\nan empty array.\nOut-of-bounds indices are clamped to the nearest valid value,\nunless `strict_indexing` is set.",
  "seealso": []
 },
 "nvim_buf_set_name": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Buffer name"
  },
  "doc": "Sets the full file name for a buffer",
  "seealso": []
 },
 "nvim_buf_set_option": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Option name",
   "value": "Option value"
  },
  "doc": "Sets a buffer option value. Passing 'nil' as value deletes the\noption (only works if there's a global fallback)",
  "seealso": []
 },
 "nvim_buf_set_text": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Integer",
    "start_row"
   ],
   [
    "Integer",
    "start_col"
   ],
   [
    "Integer",
    "end_row"
   ],
   [
    "Integer",
    "end_col"
   ],
   [
    "ArrayOf(String)",
    "replacement"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "start_row": "First line index",
   "start_column": "Last column",
   "end_row": "Last line index",
   "end_column": "Last column",
   "replacement": "Array of lines to use as replacement"
  },
  "doc": "Sets (replaces) a range in the buffer\nThis is recommended over nvim_buf_set_lines when only\nmodifying parts of a line, as extmarks will be preserved on\nnon-modified parts of the touched lines.\nIndexing is zero-based and end-exclusive.\nTo insert text at a given index, set `start` and `end` ranges\nto the same index. To delete a range, set `replacement` to an\narray containing an empty string, or simply an empty array.\nPrefer nvim_buf_set_lines when adding or deleting entire lines\nonly.",
  "seealso": []
 },
 "nvim_buf_set_var": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle, or 0 for current buffer",
   "name": "Variable name",
   "value": "Variable value"
  },
  "doc": "Sets a buffer-scoped (b:) variable",
  "seealso": []
 },
 "nvim_call_atomic": {
  "params": [
   [
    "Array",
    "calls"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "calls": "an array of calls, where each call is described\n             by an array with two elements: the request name,\n             and an array of arguments."
  },
  "doc": "Calls many API methods atomically.\nThis has two main usages:\n1. To perform several requests from an async context\n   atomically, i.e. without interleaving redraws, RPC requests\n   from other clients, or user interactions (however API\n   methods may trigger autocommands or event processing which\n   have such side-effects, e.g. |:sleep| may wake timers).\n2. To minimize RPC overhead (roundtrips) of a sequence of many\n   requests.\n",
  "return": "Array of two elements. The first is an array of return\n    values. The second is NIL if all calls succeeded. If a\n    call resulted in an error, it is a three-element array\n    with the zero-based index of the call which resulted in an\n    error, the error type and the error message. If an error\n    occurred, the values from all preceding calls will still\n    be returned.",
  "seealso": []
 },
 "nvim_call_dict_function": {
  "params": [
   [
    "Object",
    "dict"
   ],
   [
    "String",
    "fn"
   ],
   [
    "Array",
    "args"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "dict": "Dictionary, or String evaluating to a VimL |self|\n            dict",
   "fn": "Name of the function defined on the VimL dict",
   "args": "Function arguments packed in an Array"
  },
  "doc": "Calls a VimL |Dictionary-function| with the given arguments.\nOn execution error: fails with VimL error, does not update\nv:errmsg.",
  "return": "Result of the function call",
  "seealso": []
 },
 "nvim_call_function": {
  "params": [
   [
    "String",
    "fn"
   ],
   [
    "Array",
    "args"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "fn": "Function to call",
   "args": "Function arguments packed in an Array"
  },
  "doc": "Calls a VimL function with the given arguments.\nOn execution error: fails with VimL error, does not update\nv:errmsg.",
  "return": "Result of the function call",
  "seealso": []
 },
 "nvim_chan_send": {
  "params": [
   [
    "Integer",
    "chan"
   ],
   [
    "String",
    "data"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "chan": "id of the channel",
   "data": "data to write. 8-bit clean: can contain NUL bytes."
  },
  "doc": "Send data to channel `id` . For a job, it writes it to the\nstdin of the process. For the stdio channel |channel-stdio|,\nit writes to Nvim's stdout. For an internal terminal instance\n(|nvim_open_term()|) it writes directly to terimal output. See\n|channel-bytes| for more information.\nThis function writes raw data, not RPC messages. If the\nchannel was created with `rpc=true` then the channel expects\nRPC messages, use |vim.rpcnotify()| and |vim.rpcrequest()|\ninstead.",
  "seealso": []
 },
 "nvim_command": {
  "params": [
   [
    "String",
    "command"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "command": "Ex-command string"
  },
  "doc": "Executes an ex-command.\nOn execution error: fails with VimL error, does not update\nv:errmsg.",
  "seealso": [
   "|nvim_exec()|"
  ]
 },
 "nvim_create_buf": {
  "params": [
   [
    "Boolean",
    "listed"
   ],
   [
    "Boolean",
    "scratch"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "listed": "Sets 'buflisted'",
   "scratch": "Creates a \"throwaway\" |scratch-buffer| for\n               temporary work (always 'nomodified'). Also sets\n               'nomodeline' on the buffer."
  },
  "doc": "Creates a new, empty, unnamed buffer.",
  "return": "Buffer handle, or 0 on error",
  "seealso": [
   "buf_open_scratch"
  ]
 },
 "nvim_create_namespace": {
  "params": [
   [
    "String",
    "name"
   ]
  ],
  "params_doc": {
   "name": "Namespace name or empty string"
  },
  "doc": "Creates a new namespace , or gets an existing one.\nNamespaces are used for buffer highlights and virtual text,\nsee |nvim_buf_add_highlight()| and |nvim_buf_set_extmark()|.\nNamespaces can be named or anonymous. If `name` matches an\nexisting namespace, the associated id is returned. If `name`\nis an empty string a new, anonymous namespace is created.",
  "return": "Namespace id",
  "seealso": []
 },
 "nvim_del_current_line": {
  "params": [
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Deletes the current line.",
  "seealso": []
 },
 "nvim_del_keymap": {
  "params": [
   [
    "String",
    "mode"
   ],
   [
    "String",
    "lhs"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Unmaps a global |mapping| for the given mode.\nTo unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.",
  "seealso": [
   "|nvim_set_keymap()|"
  ]
 },
 "nvim_del_var": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Variable name"
  },
  "doc": "Removes a global (g:) variable.",
  "seealso": []
 },
 "nvim_echo": {
  "params": [
   [
    "Array",
    "chunks"
   ],
   [
    "Boolean",
    "history"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "chunks": "A list of [text, hl_group] arrays, each\n               representing a text chunk with specified\n               highlight. `hl_group` element can be omitted\n               for no highlight.",
   "history": "if true, add to |message-history|.",
   "opts": "Optional parameters. Reserved for future use."
  },
  "doc": "Echo a message.",
  "seealso": []
 },
 "nvim_err_write": {
  "params": [
   [
    "String",
    "str"
   ]
  ],
  "params_doc": {
   "str": "Message"
  },
  "doc": "Writes a message to the Vim error buffer. Does not append\n\"\\n\", the message is buffered (won't display) until a linefeed\nis written.",
  "seealso": []
 },
 "nvim_err_writeln": {
  "params": [
   [
    "String",
    "str"
   ]
  ],
  "params_doc": {
   "str": "Message"
  },
  "doc": "Writes a message to the Vim error buffer. Appends \"\\n\", so the\nbuffer is flushed (and displayed).",
  "seealso": [
   "nvim_err_write()"
  ]
 },
 "nvim_eval": {
  "params": [
   [
    "String",
    "expr"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "expr": "VimL expression string"
  },
  "doc": "Evaluates a VimL |expression|. Dictionaries and Lists are\nrecursively expanded.\nOn execution error: fails with VimL error, does not update\nv:errmsg.",
  "return": "Evaluation result or expanded object",
  "seealso": []
 },
 "nvim_exec": {
  "params": [
   [
    "String",
    "src"
   ],
   [
    "Boolean",
    "output"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "src": "Vimscript code",
   "output": "Capture and return all (non-error, non-shell\n              |:!|) output"
  },
  "doc": "Executes Vimscript (multiline block of Ex-commands), like\nanonymous |:source|.\nUnlike |nvim_command()| this function supports heredocs,\nscript-scope (s:), etc.\nOn execution error: fails with VimL error, does not update\nv:errmsg.",
  "return": "Output (non-error, non-shell |:!|) if `output` is true,\n    else empty string.",
  "seealso": [
   "|execute()|",
   "|nvim_command()|"
  ]
 },
 "nvim_exec_lua": {
  "params": [
   [
    "String",
    "code"
   ],
   [
    "Array",
    "args"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "code": "Lua code to execute",
   "args": "Arguments to the code"
  },
  "doc": "Execute Lua code. Parameters (if any) are available as `...`\ninside the chunk. The chunk can return a value.\nOnly statements are executed. To evaluate an expression,\nprefix it with `return` : return my_function(...)",
  "return": "Return value of Lua code if present or NIL.",
  "seealso": []
 },
 "nvim_feedkeys": {
  "params": [
   [
    "String",
    "keys"
   ],
   [
    "String",
    "mode"
   ],
   [
    "Boolean",
    "escape_csi"
   ]
  ],
  "params_doc": {
   "keys": "to be typed",
   "mode": "behavior flags, see |feedkeys()|",
   "escape_csi": "If true, escape K_SPECIAL/CSI bytes in\n                  `keys`"
  },
  "doc": "Sends input-keys to Nvim, subject to various quirks controlled\nby `mode` flags. This is a blocking call, unlike\n|nvim_input()|.\nOn execution error: does not fail, but updates v:errmsg.\nTo input sequences like <C-o> use |nvim_replace_termcodes()|\n(typically with escape_csi=true) to replace |keycodes|, then\npass the result to nvim_feedkeys().\nExample: >\n    :let key = nvim_replace_termcodes(\"<C-o>\", v:true, v:false, v:true)\n    :call nvim_feedkeys(key, 'n', v:true)\n\n<",
  "seealso": [
   "feedkeys()",
   "vim_strsave_escape_csi"
  ]
 },
 "nvim_get_all_options_info": {
  "params": [
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets the option information for all options.\nThe dictionary has the full option names as keys and option\nmetadata dictionaries as detailed at |nvim_get_option_info|.",
  "return": "dictionary of all options",
  "seealso": []
 },
 "nvim_get_api_info": {
  "params": [],
  "params_doc": {},
  "doc": "Returns a 2-tuple (Array), where item 0 is the current channel\nid and item 1 is the |api-metadata| map (Dictionary).",
  "return": "2-tuple [{channel-id}, {api-metadata}]",
  "seealso": []
 },
 "nvim_get_chan_info": {
  "params": [
   [
    "Integer",
    "chan"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets information about a channel.",
  "return": "Dictionary describing a channel, with these keys:\n    • \"id\" Channel id.\n    • \"argv\" (optional) Job arguments list.\n    • \"stream\" Stream underlying the channel.\n      • \"stdio\" stdin and stdout of this Nvim instance\n      • \"stderr\" stderr of this Nvim instance\n      • \"socket\" TCP/IP socket or named pipe\n      • \"job\" Job with communication over its stdio.\n\n    • \"mode\" How data received on the channel is interpreted.\n      • \"bytes\" Send and receive raw bytes.\n      • \"terminal\" |terminal| instance interprets ASCII\n        sequences.\n      • \"rpc\" |RPC| communication on the channel is active.\n\n    • \"pty\" (optional) Name of pseudoterminal. On a POSIX\n      system this is a device path like \"/dev/pts/1\". If the\n      name is unknown, the key will still be present if a pty\n      is used (e.g. for winpty on Windows).\n    • \"buffer\" (optional) Buffer with connected |terminal|\n      instance.\n    • \"client\" (optional) Info about the peer (client on the\n      other end of the RPC channel), if provided by it via\n      |nvim_set_client_info()|.\n",
  "seealso": []
 },
 "nvim_get_color_by_name": {
  "params": [
   [
    "String",
    "name"
   ]
  ],
  "params_doc": {
   "name": "Color name or \"#rrggbb\" string"
  },
  "doc": "Returns the 24-bit RGB value of a |nvim_get_color_map()| color\nname or \"#rrggbb\" hexadecimal string.\nExample: >\n    :echo nvim_get_color_by_name(\"Pink\")\n    :echo nvim_get_color_by_name(\"#cbcbcb\")\n\n<",
  "return": "24-bit RGB value, or -1 for invalid argument.",
  "seealso": []
 },
 "nvim_get_color_map": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Returns a map of color names and RGB values.\nKeys are color names (e.g. \"Aqua\") and values are 24-bit RGB\ncolor values (e.g. 65535).",
  "return": "Map of color names and RGB values.",
  "seealso": []
 },
 "nvim_get_commands": {
  "params": [
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "opts": "Optional parameters. Currently only supports\n            {\"builtin\":false}"
  },
  "doc": "Gets a map of global (non-buffer-local) Ex commands.\nCurrently only |user-commands| are supported, not builtin Ex\ncommands.",
  "return": "Map of maps describing commands.",
  "seealso": []
 },
 "nvim_get_context": {
  "params": [
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "opts": "Optional parameters.\n            • types: List of |context-types| (\"regs\", \"jumps\",\n              \"bufs\", \"gvars\", …) to gather, or empty for\n              \"all\"."
  },
  "doc": "Gets a map of the current editor state.",
  "return": "map of global |context|.",
  "seealso": []
 },
 "nvim_get_current_buf": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current buffer.",
  "return": "Buffer handle",
  "seealso": []
 },
 "nvim_get_current_line": {
  "params": [
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current line.",
  "return": "Current line string",
  "seealso": []
 },
 "nvim_get_current_tabpage": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current tabpage.",
  "return": "Tabpage handle",
  "seealso": []
 },
 "nvim_get_current_win": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current window.",
  "return": "Window handle",
  "seealso": []
 },
 "nvim_get_hl_by_id": {
  "params": [
   [
    "Integer",
    "hl_id"
   ],
   [
    "Boolean",
    "rgb"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "hl_id": "Highlight id as returned by |hlID()|",
   "rgb": "Export RGB colors"
  },
  "doc": "Gets a highlight definition by id. |hlID()|",
  "return": "Highlight definition map",
  "seealso": [
   "nvim_get_hl_by_name"
  ]
 },
 "nvim_get_hl_by_name": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Boolean",
    "rgb"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Highlight group name",
   "rgb": "Export RGB colors"
  },
  "doc": "Gets a highlight definition by name.",
  "return": "Highlight definition map",
  "seealso": [
   "nvim_get_hl_by_id"
  ]
 },
 "nvim_get_hl_id_by_name": {
  "params": [
   [
    "String",
    "name"
   ]
  ],
  "params_doc": {},
  "doc": "Gets a highlight group by name\nsimilar to |hlID()|, but allocates a new ID if not present.",
  "seealso": []
 },
 "nvim_get_keymap": {
  "params": [
   [
    "String",
    "mode"
   ]
  ],
  "params_doc": {
   "mode": "Mode short-name (\"n\", \"i\", \"v\", ...)"
  },
  "doc": "Gets a list of global (non-buffer-local) |mapping|\ndefinitions.",
  "return": "Array of maparg()-like dictionaries describing mappings.\n    The \"buffer\" key is always zero.",
  "seealso": []
 },
 "nvim_get_mode": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current mode. |mode()| \"blocking\" is true if Nvim is\nwaiting for input.",
  "return": "Dictionary { \"mode\": String, \"blocking\": Boolean }",
  "seealso": []
 },
 "nvim_get_namespaces": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets existing, non-anonymous namespaces.",
  "return": "dict that maps from names to namespace ids.",
  "seealso": []
 },
 "nvim_get_option": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Option name"
  },
  "doc": "Gets an option value string.",
  "return": "Option value (global)",
  "seealso": []
 },
 "nvim_get_option_info": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Option name"
  },
  "doc": "Gets the option information for one option\nResulting dictionary has keys:\n• name: Name of the option (like 'filetype')\n• shortname: Shortened name of the option (like 'ft')\n• type: type of option (\"string\", \"number\" or \"boolean\")\n• default: The default value for the option\n• was_set: Whether the option was set.\n• last_set_sid: Last set script id (if any)\n• last_set_linenr: line number where option was set\n• last_set_chan: Channel where option was set (0 for local)\n• scope: one of \"global\", \"win\", or \"buf\"\n• global_local: whether win or buf option has a global value\n• commalist: List of comma separated values\n• flaglist: List of single char flags\n",
  "return": "Option Information",
  "seealso": []
 },
 "nvim_get_proc": {
  "params": [
   [
    "Integer",
    "pid"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets info describing process `pid` .",
  "return": "Map of process properties, or NIL if process not found.",
  "seealso": []
 },
 "nvim_get_proc_children": {
  "params": [
   [
    "Integer",
    "pid"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets the immediate children of process `pid` .",
  "return": "Array of child process ids, empty if process not found.",
  "seealso": []
 },
 "nvim_get_runtime_file": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Boolean",
    "all"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "pattern of files to search for",
   "all": "whether to return all matches or only the first"
  },
  "doc": "Find files in runtime directories\n'name' can contain wildcards. For example\nnvim_get_runtime_file(\"colors/*.vim\", true) will return all\ncolor scheme files. Always use forward slashes (/) in the\nsearch pattern for subdirectories regardless of platform.\nIt is not an error to not find any files. An empty array is\nreturned then.",
  "return": "list of absolute paths to the found files",
  "seealso": []
 },
 "nvim_get_var": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Variable name"
  },
  "doc": "Gets a global (g:) variable.",
  "return": "Variable value",
  "seealso": []
 },
 "nvim_get_vvar": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Variable name"
  },
  "doc": "Gets a v: variable.",
  "return": "Variable value",
  "seealso": []
 },
 "nvim_input": {
  "params": [
   [
    "String",
    "keys"
   ]
  ],
  "params_doc": {
   "keys": "to be typed"
  },
  "doc": "Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a\nlow-level input buffer and the call is non-blocking (input is\nprocessed asynchronously by the eventloop).\nOn execution error: does not fail, but updates v:errmsg.\n\nNote:\n    |keycodes| like <CR> are translated, so \"<\" is special. To\n    input a literal \"<\", send <LT>.\n\nNote:\n    For mouse events use |nvim_input_mouse()|. The pseudokey\n    form \"<LeftMouse><col,row>\" is deprecated since\n    |api-level| 6.\n",
  "return": "Number of bytes actually written (can be fewer than\n    requested if the buffer becomes full).",
  "seealso": []
 },
 "nvim_input_mouse": {
  "params": [
   [
    "String",
    "button"
   ],
   [
    "String",
    "action"
   ],
   [
    "String",
    "modifier"
   ],
   [
    "Integer",
    "grid"
   ],
   [
    "Integer",
    "row"
   ],
   [
    "Integer",
    "col"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "button": "Mouse button: one of \"left\", \"right\",\n                \"middle\", \"wheel\".",
   "action": "For ordinary buttons, one of \"press\", \"drag\",\n                \"release\". For the wheel, one of \"up\", \"down\",\n                \"left\", \"right\".",
   "modifier": "String of modifiers each represented by a\n                single char. The same specifiers are used as\n                for a key press, except that the \"-\" separator\n                is optional, so \"C-A-\", \"c-a\" and \"CA\" can all\n                be used to specify Ctrl+Alt+click.",
   "grid": "Grid number if the client uses |ui-multigrid|,\n                else 0.",
   "row": "Mouse row-position (zero-based, like redraw\n                events)",
   "col": "Mouse column-position (zero-based, like redraw\n                events)"
  },
  "doc": "Send mouse event from GUI.\nNon-blocking: does not wait on any result, but queues the\nevent to be processed soon by the event loop.\n\nNote:\n    Currently this doesn't support \"scripting\" multiple mouse\n    events by calling it multiple times in a loop: the\n    intermediate mouse positions will be ignored. It should be\n    used to implement real-time mouse input in a GUI. The\n    deprecated pseudokey form (\"<LeftMouse><col,row>\") of\n    |nvim_input()| has the same limitation.\n",
  "seealso": []
 },
 "nvim_list_bufs": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current list of buffer handles\nIncludes unlisted (unloaded/deleted) buffers, like `:ls!` .\nUse |nvim_buf_is_loaded()| to check if a buffer is loaded.",
  "return": "List of buffer handles",
  "seealso": []
 },
 "nvim_list_chans": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Get information about all open channels.",
  "return": "Array of Dictionaries, each describing a channel with the\n    format specified at |nvim_get_chan_info()|.",
  "seealso": []
 },
 "nvim_list_runtime_paths": {
  "params": [
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Gets the paths contained in 'runtimepath'.",
  "return": "List of paths",
  "seealso": []
 },
 "nvim_list_tabpages": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current list of tabpage handles.",
  "return": "List of tabpage handles",
  "seealso": []
 },
 "nvim_list_uis": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets a list of dictionaries representing attached UIs.",
  "return": "Array of UI dictionaries, each with these keys:\n    • \"height\" Requested height of the UI\n    • \"width\" Requested width of the UI\n    • \"rgb\" true if the UI uses RGB colors (false implies\n      |cterm-colors|)\n    • \"ext_...\" Requested UI extensions, see |ui-option|\n    • \"chan\" Channel id of remote UI (not present for TUI)\n",
  "seealso": []
 },
 "nvim_list_wins": {
  "params": [
   [
    "void",
    ""
   ]
  ],
  "params_doc": {},
  "doc": "Gets the current list of window handles.",
  "return": "List of window handles",
  "seealso": []
 },
 "nvim_load_context": {
  "params": [
   [
    "Dictionary",
    "dict"
   ]
  ],
  "params_doc": {
   "dict": "|Context| map."
  },
  "doc": "Sets the current editor state from the given |context| map.",
  "seealso": []
 },
 "nvim_notify": {
  "params": [
   [
    "String",
    "msg"
   ],
   [
    "Integer",
    "log_level"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "msg": "Message to display to the user",
   "log_level": "The log level",
   "opts": "Reserved for future use."
  },
  "doc": "Notify the user with a message\nRelays the call to vim.notify . By default forwards your\nmessage in the echo area but can be overridden to trigger\ndesktop notifications.",
  "seealso": []
 },
 "nvim_open_term": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "the buffer to use (expected to be empty)",
   "opts": "Optional parameters. Reserved for future use."
  },
  "doc": "Open a terminal instance in a buffer\nBy default (and currently the only option) the terminal will\nnot be connected to an external process. Instead, input send\non the channel will be echoed directly by the terminal. This\nis useful to display ANSI terminal sequences returned as part\nof a rpc message, or similar.\nNote: to directly initiate the terminal using the right size,\ndisplay the buffer in a configured window before calling this.\nFor instance, for a floating display, first create an empty\nbuffer using |nvim_create_buf()|, then display it using\n|nvim_open_win()|, and then call this function. Then\n|nvim_chan_send()| cal be called immediately to process\nsequences in a virtual terminal having the intended size.",
  "return": "Channel id, or 0 on error",
  "seealso": []
 },
 "nvim_open_win": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Boolean",
    "enter"
   ],
   [
    "Dictionary",
    "config"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer to display, or 0 for current buffer",
   "enter": "Enter the window (make it the current window)",
   "config": "Map defining the window configuration. Keys:\n              • `relative`: Sets the window layout to \"floating\", placed\n                at (row,col) coordinates relative to:\n                • \"editor\" The global editor grid\n                • \"win\" Window given by the `win` field, or\n                  current window.\n                • \"cursor\" Cursor position in current window.\n\n              • `win` : |window-ID| for relative=\"win\".\n              • `anchor`: Decides which corner of the float to place\n                at (row,col):\n                • \"NW\" northwest (default)\n                • \"NE\" northeast\n                • \"SW\" southwest\n                • \"SE\" southeast\n\n              • `width` : Window width (in character cells).\n                Minimum of 1.\n              • `height` : Window height (in character cells).\n                Minimum of 1.\n              • `bufpos` : Places float relative to buffer\n                text (only when relative=\"win\"). Takes a tuple\n                of zero-indexed [line, column]. `row` and\n                `col` if given are applied relative to this\n                position, else they default to `row=1` and\n                `col=0` (thus like a tooltip near the buffer\n                text).\n              • `row` : Row position in units of \"screen cell\n                height\", may be fractional.\n              • `col` : Column position in units of \"screen\n                cell width\", may be fractional.\n              • `focusable` : Enable focus by user actions\n                (wincmds, mouse events). Defaults to true.\n                Non-focusable windows can be entered by\n                |nvim_set_current_win()|.\n              • `external` : GUI should display the window as\n                an external top-level window. Currently\n                accepts no other positioning configuration\n                together with this.\n              • `zindex`: Stacking order. floats with higher`zindex`go on top on floats with lower indices. Must\n                be larger than zero. The following screen\n                elements have hard-coded z-indices:\n                • 100: insert completion popupmenu\n                • 200: message scrollback\n                • 250: cmdline completion popupmenu (when\n                  wildoptions+=pum) The default value for\n                  floats are 50. In general, values below 100\n                  are recommended, unless there is a good\n                  reason to overshadow builtin elements.\n\n              • `style`: Configure the appearance of the window.\n                Currently only takes one non-empty value:\n                • \"minimal\" Nvim will display the window with\n                  many UI options disabled. This is useful\n                  when displaying a temporary float where the\n                  text should not be edited. Disables\n                  'number', 'relativenumber', 'cursorline',\n                  'cursorcolumn', 'foldcolumn', 'spell' and\n                  'list' options. 'signcolumn' is changed to\n                  `auto` and 'colorcolumn' is cleared. The\n                  end-of-buffer region is hidden by setting\n                  `eob` flag of 'fillchars' to a space char,\n                  and clearing the |EndOfBuffer| region in\n                  'winhighlight'.\n\n              • `border`: Style of (optional) window border. This can\n                either be a string or an array. The string\n                values are\n                • \"none\": No border (default).\n                • \"single\": A single line box.\n                • \"double\": A double line box.\n                • \"rounded\": Like \"single\", but with rounded\n                  corners (\"╭\" etc.).\n                • \"solid\": Adds padding by a single whitespace\n                  cell.\n                • \"shadow\": A drop shadow effect by blending\n                  with the background.\n                • If it is an array, it should have a length\n                  of eight or any divisor of eight. The array\n                  will specifify the eight chars building up\n                  the border in a clockwise fashion starting\n                  with the top-left corner. As an example, the\n                  double box style could be specified as [\n                  \"╔\", \"═\" ,\"╗\", \"║\", \"╝\", \"═\", \"╚\", \"║\" ]. If\n                  the number of chars are less than eight,\n                  they will be repeated. Thus an ASCII border\n                  could be specified as [ \"/\", \"-\", \"\\\\\", \"|\"\n                  ], or all chars the same as [ \"x\" ]. An\n                  empty string can be used to turn off a\n                  specific border, for instance, [ \"\", \"\", \"\",\n                  \">\", \"\", \"\", \"\", \"<\" ] will only make\n                  vertical borders but not horizontal ones. By\n                  default, `FloatBorder` highlight is used,\n                  which links to `VertSplit` when not defined.\n                  It could also be specified by character: [\n                  {\"+\", \"MyCorner\"}, {\"x\", \"MyBorder\"} ].\n\n              • `noautocmd` : If true then no buffer-related\n                autocommand events such as |BufEnter|,\n                |BufLeave| or |BufWinEnter| may fire from\n                calling this function."
  },
  "doc": "Open a new window.\nCurrently this is used to open floating and external windows.\nFloats are windows that are drawn above the split layout, at\nsome anchor position in some other window. Floats can be drawn\ninternally or by external GUI with the |ui-multigrid|\nextension. External windows are only supported with multigrid\nGUIs, and are displayed as separate top-level windows.\nFor a general overview of floats, see |api-floatwin|.\nExactly one of `external` and `relative` must be specified.\nThe `width` and `height` of the new window must be specified.\nWith relative=editor (row=0,col=0) refers to the top-left\ncorner of the screen-grid and (row=Lines-1,col=Columns-1)\nrefers to the bottom-right corner. Fractional values are\nallowed, but the builtin implementation (used by non-multigrid\nUIs) will always round down to nearest integer.\nOut-of-bounds values, and configurations that make the float\nnot fit inside the main editor, are allowed. The builtin\nimplementation truncates values so floats are fully within the\nmain screen grid. External GUIs could let floats hover outside\nof the main window like a tooltip, but this should not be used\nto specify arbitrary WM screen positions.\nExample (Lua): window-relative float >\n    vim.api.nvim_open_win(0, false,\n      {relative='win', row=3, col=3, width=12, height=3})\n\n<\nExample (Lua): buffer-relative float (travels as buffer is\nscrolled) >\n    vim.api.nvim_open_win(0, false,\n      {relative='win', width=12, height=3, bufpos={100,10}})\n\n<",
  "return": "Window handle, or 0 on error",
  "seealso": []
 },
 "nvim_out_write": {
  "params": [
   [
    "String",
    "str"
   ]
  ],
  "params_doc": {
   "str": "Message"
  },
  "doc": "Writes a message to the Vim output buffer. Does not append\n\"\\n\", the message is buffered (won't display) until a linefeed\nis written.",
  "seealso": []
 },
 "nvim_parse_expression": {
  "params": [
   [
    "String",
    "expr"
   ],
   [
    "String",
    "flags"
   ],
   [
    "Boolean",
    "highlight"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "expr": "Expression to parse. Always treated as a\n                 single line.",
   "flags": "Flags:\n                 • \"m\" if multiple expressions in a row are\n                   allowed (only the first one will be\n                   parsed),\n                 • \"E\" if EOC tokens are not allowed\n                   (determines whether they will stop parsing\n                   process or be recognized as an\n                   operator/space, though also yielding an\n                   error).\n                 • \"l\" when needing to start parsing with\n                   lvalues for \":let\" or \":for\". Common flag\n                   sets:\n                 • \"m\" to parse like for \":echo\".\n                 • \"E\" to parse like for \"<C-r>=\".\n                 • empty string for \":call\".\n                 • \"lm\" to parse for \":let\".",
   "highlight": "If true, return value will also include\n                 \"highlight\" key containing array of 4-tuples\n                 (arrays) (Integer, Integer, Integer, String),\n                 where first three numbers define the\n                 highlighted region and represent line,\n                 starting column and ending column (latter\n                 exclusive: one should highlight region\n                 [start_col, end_col))."
  },
  "doc": "Parse a VimL expression.",
  "return": "\n    • AST: top-level dictionary with these keys:\n      • \"error\": Dictionary with error, present only if parser\n        saw some error. Contains the following keys:\n        • \"message\": String, error message in printf format,\n          translated. Must contain exactly one \"%.*s\".\n        • \"arg\": String, error message argument.\n\n      • \"len\": Amount of bytes successfully parsed. With flags\n        equal to \"\" that should be equal to the length of expr\n        string. (“Successfully parsed” here means\n        “participated in AST creation”, not “till the first\n        error”.)\n      • \"ast\": AST, either nil or a dictionary with these\n        keys:\n        • \"type\": node type, one of the value names from\n          ExprASTNodeType stringified without \"kExprNode\"\n          prefix.\n        • \"start\": a pair [line, column] describing where node\n          is \"started\" where \"line\" is always 0 (will not be 0\n          if you will be using nvim_parse_viml() on e.g.\n          \":let\", but that is not present yet). Both elements\n          are Integers.\n        • \"len\": “length” of the node. This and \"start\" are\n          there for debugging purposes primary (debugging\n          parser and providing debug information).\n        • \"children\": a list of nodes described in top/\"ast\".\n          There always is zero, one or two children, key will\n          not be present if node has no children. Maximum\n          number of children may be found in node_maxchildren\n          array.\n\n\n    • Local values (present only for certain nodes):\n      • \"scope\": a single Integer, specifies scope for\n        \"Option\" and \"PlainIdentifier\" nodes. For \"Option\" it\n        is one of ExprOptScope values, for \"PlainIdentifier\"\n        it is one of ExprVarScope values.\n      • \"ident\": identifier (without scope, if any), present\n        for \"Option\", \"PlainIdentifier\", \"PlainKey\" and\n        \"Environment\" nodes.\n      • \"name\": Integer, register name (one character) or -1.\n        Only present for \"Register\" nodes.\n      • \"cmp_type\": String, comparison type, one of the value\n        names from ExprComparisonType, stringified without\n        \"kExprCmp\" prefix. Only present for \"Comparison\"\n        nodes.\n      • \"ccs_strategy\": String, case comparison strategy, one\n        of the value names from ExprCaseCompareStrategy,\n        stringified without \"kCCStrategy\" prefix. Only present\n        for \"Comparison\" nodes.\n      • \"augmentation\": String, augmentation type for\n        \"Assignment\" nodes. Is either an empty string, \"Add\",\n        \"Subtract\" or \"Concat\" for \"=\", \"+=\", \"-=\" or \".=\"\n        respectively.\n      • \"invert\": Boolean, true if result of comparison needs\n        to be inverted. Only present for \"Comparison\" nodes.\n      • \"ivalue\": Integer, integer value for \"Integer\" nodes.\n      • \"fvalue\": Float, floating-point value for \"Float\"\n        nodes.\n      • \"svalue\": String, value for \"SingleQuotedString\" and\n        \"DoubleQuotedString\" nodes.\n\n",
  "seealso": []
 },
 "nvim_paste": {
  "params": [
   [
    "String",
    "data"
   ],
   [
    "Boolean",
    "crlf"
   ],
   [
    "Integer",
    "phase"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "data": "Multiline input. May be binary (containing NUL\n             bytes).",
   "crlf": "Also break lines at CR and CRLF.",
   "phase": "-1: paste in a single call (i.e. without\n             streaming). To \"stream\" a paste, call `nvim_paste` sequentially with these `phase` values:\n             • 1: starts the paste (exactly once)\n             • 2: continues the paste (zero or more times)\n             • 3: ends the paste (exactly once)"
  },
  "doc": "Pastes at cursor, in any mode.\nInvokes the `vim.paste` handler, which handles each mode\nappropriately. Sets redo/undo. Faster than |nvim_input()|.\nLines break at LF (\"\\n\").\nErrors ('nomodifiable', `vim.paste()` failure, …) are\nreflected in `err` but do not affect the return value (which\nis strictly decided by `vim.paste()` ). On error, subsequent\ncalls are ignored (\"drained\") until the next paste is\ninitiated (phase 1 or -1).",
  "return": "\n    • true: Client may continue pasting.\n    • false: Client must cancel the paste.\n",
  "seealso": []
 },
 "nvim_put": {
  "params": [
   [
    "ArrayOf(String)",
    "lines"
   ],
   [
    "String",
    "type"
   ],
   [
    "Boolean",
    "after"
   ],
   [
    "Boolean",
    "follow"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "lines": "|readfile()|-style list of lines.\n              |channel-lines|",
   "type": "Edit behavior: any |getregtype()| result, or:\n              • \"b\" |blockwise-visual| mode (may include\n                width, e.g. \"b3\")\n              • \"c\" |charwise| mode\n              • \"l\" |linewise| mode\n              • \"\" guess by contents, see |setreg()|",
   "after": "If true insert after cursor (like |p|), or\n              before (like |P|).",
   "follow": "If true place cursor at end of inserted text."
  },
  "doc": "Puts text at cursor, in any mode.\nCompare |:put| and |p| which are always linewise.",
  "seealso": []
 },
 "nvim_replace_termcodes": {
  "params": [
   [
    "String",
    "str"
   ],
   [
    "Boolean",
    "from_part"
   ],
   [
    "Boolean",
    "do_lt"
   ],
   [
    "Boolean",
    "special"
   ]
  ],
  "params_doc": {
   "str": "String to be converted.",
   "from_part": "Legacy Vim parameter. Usually true.",
   "do_lt": "Also translate <lt>. Ignored if `special` is\n                 false.",
   "special": "Replace |keycodes|, e.g. <CR> becomes a \"\\n\"\n                 char."
  },
  "doc": "Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a\nstring with the internal representation.",
  "seealso": [
   "replace_termcodes",
   "cpoptions"
  ]
 },
 "nvim_select_popupmenu_item": {
  "params": [
   [
    "Integer",
    "item"
   ],
   [
    "Boolean",
    "insert"
   ],
   [
    "Boolean",
    "finish"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "item": "Index (zero-based) of the item to select. Value\n              of -1 selects nothing and restores the original\n              text.",
   "insert": "Whether the selection should be inserted in the\n              buffer.",
   "finish": "Finish the completion and dismiss the popupmenu.\n              Implies `insert` .",
   "opts": "Optional parameters. Reserved for future use."
  },
  "doc": "Selects an item in the completion popupmenu.\nIf |ins-completion| is not active this API call is silently\nignored. Useful for an external UI using |ui-popupmenu| to\ncontrol the popupmenu with the mouse. Can also be used in a\nmapping; use <cmd> |:map-cmd| to ensure the mapping doesn't\nend completion mode.",
  "seealso": []
 },
 "nvim_set_client_info": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Dictionary",
    "version"
   ],
   [
    "String",
    "type"
   ],
   [
    "Dictionary",
    "methods"
   ],
   [
    "Dictionary",
    "attributes"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Short name for the connected client",
   "version": "Dictionary describing the version, with\n                  these (optional) keys:\n                  • \"major\" major version (defaults to 0 if\n                    not set, for no release yet)\n                  • \"minor\" minor version\n                  • \"patch\" patch number\n                  • \"prerelease\" string describing a\n                    prerelease, like \"dev\" or \"beta1\"\n                  • \"commit\" hash or similar identifier of\n                    commit",
   "type": "Must be one of the following values. Client\n                  libraries should default to \"remote\" unless\n                  overridden by the user.\n                  • \"remote\" remote client connected to Nvim.\n                  • \"ui\" gui frontend\n                  • \"embedder\" application using Nvim as a\n                    component (for example, IDE/editor\n                    implementing a vim mode).\n                  • \"host\" plugin host, typically started by\n                    nvim\n                  • \"plugin\" single plugin, started by nvim",
   "methods": "Builtin methods in the client. For a host,\n                  this does not include plugin methods which\n                  will be discovered later. The key should be\n                  the method name, the values are dicts with\n                  these (optional) keys (more keys may be\n                  added in future versions of Nvim, thus\n                  unknown keys are ignored. Clients must only\n                  use keys defined in this or later versions\n                  of Nvim):\n                  • \"async\" if true, send as a notification.\n                    If false or unspecified, use a blocking\n                    request\n                  • \"nargs\" Number of arguments. Could be a\n                    single integer or an array of two\n                    integers, minimum and maximum inclusive.",
   "attributes": "Arbitrary string:string map of informal\n                  client properties. Suggested keys:\n                  • \"website\": Client homepage URL (e.g.\n                    GitHub repository)\n                  • \"license\": License description (\"Apache\n                    2\", \"GPLv3\", \"MIT\", …)\n                  • \"logo\": URI or path to image, preferably\n                    small logo or icon. .png or .svg format is\n                    preferred."
  },
  "doc": "Self-identifies the client.\nThe client/plugin/application should call this after\nconnecting, to provide hints about its identity and purpose,\nfor debugging and orchestration.\nCan be called more than once; the caller should merge old info\nif appropriate. Example: library first identifies the channel,\nthen a plugin using that library later identifies itself.\n\nNote:\n    \"Something is better than nothing\". You don't need to\n    include all the fields.\n",
  "seealso": []
 },
 "nvim_set_current_buf": {
  "params": [
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "buffer": "Buffer handle"
  },
  "doc": "Sets the current buffer.",
  "seealso": []
 },
 "nvim_set_current_dir": {
  "params": [
   [
    "String",
    "dir"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "dir": "Directory path"
  },
  "doc": "Changes the global working directory.",
  "seealso": []
 },
 "nvim_set_current_line": {
  "params": [
   [
    "String",
    "line"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "line": "Line contents"
  },
  "doc": "Sets the current line.",
  "seealso": []
 },
 "nvim_set_current_tabpage": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle"
  },
  "doc": "Sets the current tabpage.",
  "seealso": []
 },
 "nvim_set_current_win": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle"
  },
  "doc": "Sets the current window.",
  "seealso": []
 },
 "nvim_set_decoration_provider": {
  "params": [
   [
    "Integer",
    "ns_id"
   ],
   [
    "DictionaryOf(LuaRef)",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "ns_id": "Namespace id from |nvim_create_namespace()|",
   "opts": "Callbacks invoked during redraw:\n             • on_start: called first on each screen redraw\n               [\"start\", tick]\n             • on_buf: called for each buffer being redrawn\n               (before window callbacks) [\"buf\", bufnr, tick]\n             • on_win: called when starting to redraw a\n               specific window. [\"win\", winid, bufnr, topline,\n               botline_guess]\n             • on_line: called for each buffer line being\n               redrawn. (The interation with fold lines is\n               subject to change) [\"win\", winid, bufnr, row]\n             • on_end: called at the end of a redraw cycle\n               [\"end\", tick]"
  },
  "doc": "Set or change decoration provider for a namespace\nThis is a very general purpose interface for having lua\ncallbacks being triggered during the redraw code.\nThe expected usage is to set extmarks for the currently\nredrawn buffer. |nvim_buf_set_extmark| can be called to add\nmarks on a per-window or per-lines basis. Use the `ephemeral`\nkey to only use the mark for the current screen redraw (the\ncallback will be called again for the next redraw ).\nNote: this function should not be called often. Rather, the\ncallbacks themselves can be used to throttle unneeded\ncallbacks. the `on_start` callback can return `false` to\ndisable the provider until the next redraw. Similarly, return\n`false` in `on_win` will skip the `on_lines` calls for that\nwindow (but any extmarks set in `on_win` will still be used).\nA plugin managing multiple sources of decoration should\nideally only set one provider, and merge the sources\ninternally. You can use multiple `ns_id` for the extmarks\nset/modified inside the callback anyway.\nNote: doing anything other than setting extmarks is considered\nexperimental. Doing things like changing options are not\nexpliticly forbidden, but is likely to have unexpected\nconsequences (such as 100% CPU consumption). doing\n`vim.rpcnotify` should be OK, but `vim.rpcrequest` is quite\ndubious for the moment.",
  "seealso": []
 },
 "nvim_set_hl": {
  "params": [
   [
    "Integer",
    "ns_id"
   ],
   [
    "String",
    "name"
   ],
   [
    "Dictionary",
    "val"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "ns_id": "number of namespace for this highlight",
   "name": "highlight group name, like ErrorMsg",
   "val": "highlight definition map, like\n             |nvim_get_hl_by_name|. in addition the following\n             keys are also recognized: `default` : don't\n             override existing definition, like `hi default`\n             `ctermfg` : sets foreground of cterm color\n             `ctermbg` : sets background of cterm color\n             `cterm` : cterm attribute map. sets attributed\n             for cterm colors. similer to `hi cterm` Note: by\n             default cterm attributes are same as attributes\n             of gui color"
  },
  "doc": "Set a highlight group.\nTODO: ns_id = 0, should modify :highlight namespace TODO val\nshould take update vs reset flag",
  "seealso": []
 },
 "nvim_set_keymap": {
  "params": [
   [
    "String",
    "mode"
   ],
   [
    "String",
    "lhs"
   ],
   [
    "String",
    "rhs"
   ],
   [
    "Dictionary",
    "opts"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "mode": "Mode short-name (map command prefix: \"n\", \"i\",\n            \"v\", \"x\", …) or \"!\" for |:map!|, or empty string\n            for |:map|.",
   "lhs": "Left-hand-side |{lhs}| of the mapping.",
   "rhs": "Right-hand-side |{rhs}| of the mapping.",
   "opts": "Optional parameters map. Accepts all\n            |:map-arguments| as keys excluding |<buffer>| but\n            including |noremap|. Values are Booleans. Unknown\n            key is an error."
  },
  "doc": "Sets a global |mapping| for the given mode.\nTo set a buffer-local mapping, use |nvim_buf_set_keymap()|.\nUnlike |:map|, leading/trailing whitespace is accepted as part\nof the {lhs} or {rhs}. Empty {rhs} is |<Nop>|. |keycodes| are\nreplaced as usual.\nExample: >\n    call nvim_set_keymap('n', ' <NL>', '', {'nowait': v:true})\n\n<\nis equivalent to: >\n    nmap <nowait> <Space><NL> <Nop>\n\n<",
  "seealso": []
 },
 "nvim_set_option": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Option name",
   "value": "New option value"
  },
  "doc": "Sets an option value.",
  "seealso": []
 },
 "nvim_set_var": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Variable name",
   "value": "Variable value"
  },
  "doc": "Sets a global (g:) variable.",
  "seealso": []
 },
 "nvim_set_vvar": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "name": "Variable name",
   "value": "Variable value"
  },
  "doc": "Sets a v: variable, if it is not readonly.",
  "seealso": []
 },
 "nvim_strwidth": {
  "params": [
   [
    "String",
    "text"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "text": "Some text"
  },
  "doc": "Calculates the number of display cells occupied by `text` .\n<Tab> counts as one cell.",
  "return": "Number of cells",
  "seealso": []
 },
 "nvim_subscribe": {
  "params": [
   [
    "String",
    "event"
   ]
  ],
  "params_doc": {
   "event": "Event type string"
  },
  "doc": "Subscribes to event broadcasts.",
  "seealso": []
 },
 "nvim_tabpage_del_var": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage",
   "name": "Variable name"
  },
  "doc": "Removes a tab-scoped (t:) variable",
  "seealso": []
 },
 "nvim_tabpage_get_number": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage"
  },
  "doc": "Gets the tabpage number",
  "return": "Tabpage number",
  "seealso": []
 },
 "nvim_tabpage_get_var": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage",
   "name": "Variable name"
  },
  "doc": "Gets a tab-scoped (t:) variable",
  "return": "Variable value",
  "seealso": []
 },
 "nvim_tabpage_get_win": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage"
  },
  "doc": "Gets the current window in a tabpage",
  "return": "Window handle",
  "seealso": []
 },
 "nvim_tabpage_is_valid": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage"
  },
  "doc": "Checks if a tabpage is valid",
  "return": "true if the tabpage is valid, false otherwise",
  "seealso": []
 },
 "nvim_tabpage_list_wins": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage"
  },
  "doc": "Gets the windows in a tabpage",
  "return": "List of windows in `tabpage`",
  "seealso": []
 },
 "nvim_tabpage_set_var": {
  "params": [
   [
    "Tabpage",
    "tabpage"
   ],
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "tabpage": "Tabpage handle, or 0 for current tabpage",
   "name": "Variable name",
   "value": "Variable value"
  },
  "doc": "Sets a tab-scoped (t:) variable",
  "seealso": []
 },
 "nvim_ui_attach": {
  "params": [
   [
    "Integer",
    "width"
   ],
   [
    "Integer",
    "height"
   ],
   [
    "Dictionary",
    "options"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "width": "Requested screen columns",
   "height": "Requested screen rows",
   "options": "|ui-option| map"
  },
  "doc": "Activates UI events on the channel.\nEntry point of all UI clients. Allows |--embed| to continue\nstartup. Implies that the client is ready to show the UI. Adds\nthe client to the list of UIs. |nvim_list_uis()|\n\nNote:\n    If multiple UI clients are attached, the global screen\n    dimensions degrade to the smallest client. E.g. if client\n    A requests 80x40 but client B requests 200x100, the global\n    screen has size 80x40.\n",
  "seealso": []
 },
 "nvim_ui_detach": {
  "params": [
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "Deactivates UI events on the channel.\nRemoves the client from the list of UIs. |nvim_list_uis()|",
  "seealso": []
 },
 "nvim_ui_pum_set_bounds": {
  "params": [
   [
    "Float",
    "width"
   ],
   [
    "Float",
    "height"
   ],
   [
    "Float",
    "row"
   ],
   [
    "Float",
    "col"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "width": "Popupmenu width.",
   "height": "Popupmenu height.",
   "row": "Popupmenu row.",
   "col": "Popupmenu height."
  },
  "doc": "Tells Nvim the geometry of the popumenu, to align floating\nwindows with an external popup menu.\nNote that this method is not to be confused with\n|nvim_ui_pum_set_height()|, which sets the number of visible\nitems in the popup menu, while this function sets the bounding\nbox of the popup menu, including visual elements such as\nborders and sliders. Floats need not use the same font size,\nnor be anchored to exact grid corners, so one can set\nfloating-point numbers to the popup menu geometry.",
  "seealso": []
 },
 "nvim_ui_pum_set_height": {
  "params": [
   [
    "Integer",
    "height"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "height": "Popupmenu height, must be greater than zero."
  },
  "doc": "Tells Nvim the number of elements displaying in the popumenu,\nto decide <PageUp> and <PageDown> movement.",
  "seealso": []
 },
 "nvim_ui_set_option": {
  "params": [
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "error"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim_ui_try_resize": {
  "params": [
   [
    "Integer",
    "width"
   ],
   [
    "Integer",
    "height"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "nvim_ui_try_resize_grid": {
  "params": [
   [
    "Integer",
    "grid"
   ],
   [
    "Integer",
    "width"
   ],
   [
    "Integer",
    "height"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "grid": "The handle of the grid to be changed.",
   "width": "The new requested width.",
   "height": "The new requested height."
  },
  "doc": "Tell Nvim to resize a grid. Triggers a grid_resize event with\nthe requested grid size or the maximum size if it exceeds size\nlimits.\nOn invalid grid handle, fails with error.",
  "seealso": []
 },
 "nvim_unsubscribe": {
  "params": [
   [
    "String",
    "event"
   ]
  ],
  "params_doc": {
   "event": "Event type string"
  },
  "doc": "Unsubscribes to event broadcasts.",
  "seealso": []
 },
 "nvim_win_call": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "LuaRef",
    "fun"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "fun": "Function to call inside the window (currently\n              lua callable only)"
  },
  "doc": "Calls a function with window as temporary current window.",
  "return": "Return value of function. NB: will deepcopy lua values\n    currently, use upvalues to send lua references in and out.",
  "seealso": [
   "|win_execute()|",
   "|nvim_buf_call()|"
  ]
 },
 "nvim_win_close": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Boolean",
    "force"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "force": "Behave like `:close!` The last window of a\n              buffer with unwritten changes can be closed. The\n              buffer will become hidden, even if 'hidden' is\n              not set."
  },
  "doc": "Closes the window (like |:close| with a |window-ID|).",
  "seealso": []
 },
 "nvim_win_del_var": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "name": "Variable name"
  },
  "doc": "Removes a window-scoped (w:) variable",
  "seealso": []
 },
 "nvim_win_get_buf": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the current buffer in a window",
  "return": "Buffer handle",
  "seealso": []
 },
 "nvim_win_get_config": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets window configuration.\nThe returned value may be given to |nvim_open_win()|.\n`relative` is empty for normal windows.",
  "return": "Map defining the window configuration, see\n    |nvim_open_win()|",
  "seealso": []
 },
 "nvim_win_get_cursor": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the (1,0)-indexed cursor position in the window.\n|api-indexing|",
  "return": "(row, col) tuple",
  "seealso": []
 },
 "nvim_win_get_height": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the window height",
  "return": "Height as a count of rows",
  "seealso": []
 },
 "nvim_win_get_number": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the window number",
  "return": "Window number",
  "seealso": []
 },
 "nvim_win_get_option": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "name": "Option name"
  },
  "doc": "Gets a window option value",
  "return": "Option value",
  "seealso": []
 },
 "nvim_win_get_position": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the window position in display cells. First position is\nzero.",
  "return": "(row, col) tuple with the window position",
  "seealso": []
 },
 "nvim_win_get_tabpage": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the window tabpage",
  "return": "Tabpage that contains the window",
  "seealso": []
 },
 "nvim_win_get_var": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "String",
    "name"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "name": "Variable name"
  },
  "doc": "Gets a window-scoped (w:) variable",
  "return": "Variable value",
  "seealso": []
 },
 "nvim_win_get_width": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Gets the window width",
  "return": "Width as a count of columns",
  "seealso": []
 },
 "nvim_win_hide": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Closes the window and hide the buffer it contains (like\n|:hide| with a |window-ID|).\nLike |:hide| the buffer becomes hidden unless another window\nis editing it, or 'bufhidden' is `unload` , `delete` or `wipe`\nas opposed to |:close| or |nvim_win_close|, which will close\nthe buffer.",
  "seealso": []
 },
 "nvim_win_is_valid": {
  "params": [
   [
    "Window",
    "window"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window"
  },
  "doc": "Checks if a window is valid",
  "return": "true if the window is valid, false otherwise",
  "seealso": []
 },
 "nvim_win_set_buf": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Buffer",
    "buffer"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "buffer": "Buffer handle"
  },
  "doc": "Sets the current buffer in a window, without side-effects",
  "seealso": []
 },
 "nvim_win_set_config": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Dictionary",
    "config"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "config": "Map defining the window configuration, see\n              |nvim_open_win()|"
  },
  "doc": "Configures window layout. Currently only for floating and\nexternal windows (including changing a split window to those\nlayouts).\nWhen reconfiguring a floating window, absent option keys will\nnot be changed. `row` / `col` and `relative` must be\nreconfigured together.",
  "seealso": [
   "|nvim_open_win()|"
  ]
 },
 "nvim_win_set_cursor": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "ArrayOf(Integer, 2)",
    "pos"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "pos": "(row, col) tuple representing the new position"
  },
  "doc": "Sets the (1,0)-indexed cursor position in the window.\n|api-indexing|",
  "seealso": []
 },
 "nvim_win_set_height": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Integer",
    "height"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "height": "Height as a count of rows"
  },
  "doc": "Sets the window height. This will only succeed if the screen\nis split horizontally.",
  "seealso": []
 },
 "nvim_win_set_option": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "name": "Option name",
   "value": "Option value"
  },
  "doc": "Sets a window option value. Passing 'nil' as value deletes the\noption(only works if there's a global fallback)",
  "seealso": []
 },
 "nvim_win_set_var": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "String",
    "name"
   ],
   [
    "Object",
    "value"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "name": "Variable name",
   "value": "Variable value"
  },
  "doc": "Sets a window-scoped (w:) variable",
  "seealso": []
 },
 "nvim_win_set_width": {
  "params": [
   [
    "Window",
    "window"
   ],
   [
    "Integer",
    "width"
   ],
   [
    "Error *",
    "err"
   ]
  ],
  "params_doc": {
   "window": "Window handle, or 0 for current window",
   "width": "Width as a count of columns"
  },
  "doc": "Sets the window width. This will only succeed if the screen is\nsplit vertically.",
  "seealso": []
 }
}