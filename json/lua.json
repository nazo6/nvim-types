{
 "deep_equal": {
  "params": [
   [
    "",
    "a"
   ],
   [
    "",
    "b"
   ]
  ],
  "params_doc": {
   "a": "first value",
   "b": "second value"
  },
  "doc": "Deep compare values for equality\nTables are compared recursively unless they both provide the `eq` methamethod. All other types are compared using the equality `==` operator.",
  "return": "`true` if values are equals, else `false` .",
  "seealso": []
 },
 "deepcopy": {
  "params": [
   [
    "",
    "orig"
   ]
  ],
  "params_doc": {
   "orig": "Table to copy"
  },
  "doc": "Returns a deep copy of the given object. Non-table objects are\ncopied as in a typical Lua assignment, whereas table objects\nare copied recursively. Functions are naively copied, so\nfunctions in the copied table point to the same functions as\nthose in the input table. Userdata and threads are not copied\nand will throw an error.",
  "return": "New table of copied keys and (nested) values.",
  "seealso": []
 },
 "defer_fn": {
  "params": [
   [
    "",
    "fn"
   ],
   [
    "",
    "timeout"
   ]
  ],
  "params_doc": {
   "fn": "Callback to call once `timeout` expires",
   "timeout": "Number of milliseconds to wait before calling\n               `fn`"
  },
  "doc": "Defers calling `fn` until `timeout` ms passes.\nUse to do a one-shot timer that calls `fn` Note: The {fn} is |schedule_wrap|ped automatically, so API\nfunctions are safe to call.",
  "return": "timer luv timer object",
  "seealso": []
 },
 "endswith": {
  "params": [
   [
    "",
    "s"
   ],
   [
    "",
    "suffix"
   ]
  ],
  "params_doc": {
   "s": "(string) a string",
   "suffix": "(string) a suffix"
  },
  "doc": "Tests if `s` ends with `suffix` .",
  "return": "(boolean) true if `suffix` is a suffix of s",
  "seealso": []
 },
 "gsplit": {
  "params": [
   [
    "",
    "s"
   ],
   [
    "",
    "sep"
   ],
   [
    "",
    "plain"
   ]
  ],
  "params_doc": {
   "s": "String to split",
   "sep": "Separator string or pattern",
   "plain": "If `true` use `sep` literally (passed to\n             String.find)"
  },
  "doc": "Splits a string at each instance of a separator.",
  "return": "Iterator over the split components",
  "seealso": [
   "|vim.split()|",
   "https://www.lua.org/pil/20.2.html",
   "http://lua-users.org/wiki/StringLibraryTutorial"
  ]
 },
 "insert_keys": {
  "params": [
   [
    "",
    "obj"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "inspect": {
  "params": [
   [
    "",
    "object"
   ],
   [
    "",
    "options"
   ]
  ],
  "params_doc": {},
  "doc": "Return a human-readable representation of the given object.",
  "seealso": [
   "https://github.com/kikito/inspect.lua",
   "https://github.com/mpeterv/vinspect"
  ]
 },
 "is_callable": {
  "params": [
   [
    "",
    "f"
   ]
  ],
  "params_doc": {
   "f": "Any object"
  },
  "doc": "Returns true if object `f` can be called as a function.",
  "return": "true if `f` is callable, else false",
  "seealso": []
 },
 "is_valid": {
  "params": [
   [
    "",
    "opt"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "list_extend": {
  "params": [
   [
    "",
    "dst"
   ],
   [
    "",
    "src"
   ],
   [
    "",
    "start"
   ],
   [
    "",
    "finish"
   ]
  ],
  "params_doc": {
   "dst": "list which will be modified and appended to.",
   "src": "list from which values will be inserted.",
   "start": "Start index on src. defaults to 1",
   "finish": "Final index on src. defaults to #src"
  },
  "doc": "Extends a list-like table with the values of another list-like\ntable.\nNOTE: This mutates dst!",
  "return": "dst",
  "seealso": [
   "|vim.tbl_extend()|"
  ]
 },
 "list_slice": {
  "params": [
   [
    "",
    "list"
   ],
   [
    "",
    "start"
   ],
   [
    "",
    "finish"
   ]
  ],
  "params_doc": {
   "list": "table table",
   "start": "integer Start range of slice",
   "finish": "integer End range of slice"
  },
  "doc": "Creates a copy of a table containing only elements from start\nto end (inclusive)",
  "return": "Copy of table sliced from start to finish (inclusive)",
  "seealso": []
 },
 "make_dict_accessor": {
  "params": [
   [
    "",
    "scope"
   ]
  ],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "notify": {
  "params": [
   [
    "",
    "msg"
   ],
   [
    "",
    "log_level"
   ],
   [
    "",
    "_opts"
   ]
  ],
  "params_doc": {
   "msg": "Content of the notification to show to the\n                 user",
   "log_level": "Optional log level",
   "opts": "Dictionary with optional options (timeout,\n                 etc)"
  },
  "doc": "Notification provider\nWithout a runtime, writes to :Messages",
  "seealso": [
   ":help nvim_notify"
  ]
 },
 "on_key": {
  "params": [
   [
    "",
    "fn"
   ],
   [
    "",
    "ns_id"
   ]
  ],
  "params_doc": {
   "fn": "function: Callback function. It should take one\n             string argument. On each key press, Nvim passes\n             the key char to fn(). |i_CTRL-V| If {fn} is nil,\n             it removes the callback for the associated\n             {ns_id}",
   "ns_id": "number? Namespace ID. If nil or 0, generates and\n             returns a new |nvim_create_namesapce()| id."
  },
  "doc": "Adds Lua function {fn} with namespace id {ns_id} as a listener\nto every, yes every, input key.\nThe Nvim command-line option |-w| is related but does not\nsupport callbacks and cannot be toggled dynamically.\n\nNote:\n    {fn} will not be cleared by |nvim_buf_clear_namespace()|\n\nNote:\n    {fn} will receive the keys after mappings have been\n    evaluated\n",
  "return": "number Namespace id associated with {fn}. Or count of all\n    callbacks if on_key() is called without arguments.",
  "seealso": []
 },
 "paste": {
  "params": [
   [
    "",
    "lines"
   ],
   [
    "",
    "phase"
   ]
  ],
  "params_doc": {
   "lines": "|readfile()|-style list of lines to paste.\n             |channel-lines|",
   "phase": "-1: \"non-streaming\" paste: the call contains all\n             lines. If paste is \"streamed\", `phase` indicates the stream state:\n             • 1: starts the paste (exactly once)\n             • 2: continues the paste (zero or more times)\n             • 3: ends the paste (exactly once)"
  },
  "doc": "Paste handler, invoked by |nvim_paste()| when a conforming UI\n(such as the |TUI|) pastes text into the editor.\nExample: To remove ANSI color codes when pasting: >\n\n vim.paste = (function(overridden)\n   return function(lines, phase)\n     for i,line in ipairs(lines) do\n       -- Scrub ANSI color codes from paste input.\n       lines[i] = line:gsub('\\27%[[0-9;mK]+', '')\n     end\n     overridden(lines, phase)\n   end\n end)(vim.paste)\n \n<",
  "return": "false if client should cancel the paste.",
  "seealso": [
   "|paste|"
  ]
 },
 "pesc": {
  "params": [
   [
    "",
    "s"
   ]
  ],
  "params_doc": {
   "s": "String to escape"
  },
  "doc": "Escapes magic chars in a Lua pattern.",
  "return": "%-escaped pattern string",
  "seealso": [
   "https://github.com/rxi/lume"
  ]
 },
 "region": {
  "params": [
   [
    "",
    "bufnr"
   ],
   [
    "",
    "pos1"
   ],
   [
    "",
    "pos2"
   ],
   [
    "",
    "regtype"
   ],
   [
    "",
    "inclusive"
   ]
  ],
  "params_doc": {
   "bufnr": "number of buffer",
   "pos1": "(line, column) tuple marking beginning of\n                 region",
   "pos2": "(line, column) tuple marking end of region",
   "regtype": "type of selection (:help setreg)",
   "inclusive": "boolean indicating whether the selection is\n                 end-inclusive"
  },
  "doc": "Get a table of lines with start, end columns for a region\nmarked by two points",
  "return": "region lua table of the form {linenr = {startcol,endcol}}",
  "seealso": []
 },
 "register_keystroke_callback": {
  "params": [],
  "params_doc": {},
  "doc": "",
  "seealso": []
 },
 "schedule_wrap": {
  "params": [
   [
    "",
    "cb"
   ]
  ],
  "params_doc": {},
  "doc": "Defers callback `cb` until the Nvim API is safe to call.",
  "seealso": [
   "|lua-loop-callbacks|",
   "|vim.schedule()|",
   "|vim.in_fast_event()|"
  ]
 },
 "split": {
  "params": [
   [
    "",
    "s"
   ],
   [
    "",
    "sep"
   ],
   [
    "",
    "plain"
   ]
  ],
  "params_doc": {
   "s": "String to split",
   "sep": "Separator string or pattern",
   "plain": "If `true` use `sep` literally (passed to\n             String.find)"
  },
  "doc": "Splits a string at each instance of a separator.\nExamples: >\n split(\":aa::b:\", \":\")     --> {'','aa','','b',''}\n split(\"axaby\", \"ab?\")     --> {'','x','y'}\n split(x*yz*o, \"*\", true)  --> {'x','yz','o'}\n\n<",
  "return": "List-like table of the split components.",
  "seealso": [
   "|vim.gsplit()|"
  ]
 },
 "startswith": {
  "params": [
   [
    "",
    "s"
   ],
   [
    "",
    "prefix"
   ]
  ],
  "params_doc": {
   "s": "(string) a string",
   "prefix": "(string) a prefix"
  },
  "doc": "Tests if `s` starts with `prefix` .",
  "return": "(boolean) true if `prefix` is a prefix of s",
  "seealso": []
 },
 "tbl_add_reverse_lookup": {
  "params": [
   [
    "",
    "o"
   ]
  ],
  "params_doc": {
   "o": "table The table to add the reverse to."
  },
  "doc": "Add the reverse lookup values to an existing table. For\nexample: tbl_add_reverse_lookup { A = 1 } == { [1] = 'A , A = 1 }`",
  "seealso": []
 },
 "tbl_contains": {
  "params": [
   [
    "",
    "t"
   ],
   [
    "",
    "value"
   ]
  ],
  "params_doc": {
   "t": "Table to check",
   "value": "Value to compare"
  },
  "doc": "Checks if a list-like (vector) table contains `value` .",
  "return": "true if `t` contains `value`",
  "seealso": []
 },
 "tbl_count": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "Table"
  },
  "doc": "Counts the number of non-nil values in table `t` .\n>\n\n vim.tbl_count({ a=1, b=2 }) => 2\n vim.tbl_count({ 1, 2 }) => 2\n \n<",
  "return": "Number that is the number of the value in table",
  "seealso": [
   "https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua"
  ]
 },
 "tbl_deep_extend": {
  "params": [
   [
    "",
    "behavior"
   ],
   [
    "",
    "..."
   ]
  ],
  "params_doc": {
   "behavior": "Decides what to do if a key is found in more\n                than one map:\n                • \"error\": raise an error\n                • \"keep\": use value from the leftmost map\n                • \"force\": use value from the rightmost map",
   "...": "Two or more map-like tables."
  },
  "doc": "Merges recursively two or more map-like tables.",
  "seealso": [
   "|tbl_extend()|"
  ]
 },
 "tbl_extend": {
  "params": [
   [
    "",
    "behavior"
   ],
   [
    "",
    "..."
   ]
  ],
  "params_doc": {
   "behavior": "Decides what to do if a key is found in more\n                than one map:\n                • \"error\": raise an error\n                • \"keep\": use value from the leftmost map\n                • \"force\": use value from the rightmost map",
   "...": "Two or more map-like tables."
  },
  "doc": "Merges two or more map-like tables.",
  "seealso": [
   "|extend()|"
  ]
 },
 "tbl_filter": {
  "params": [
   [
    "",
    "func"
   ],
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "func": "function or callable table",
   "t": "table"
  },
  "doc": "Filter a table using a predicate function",
  "seealso": []
 },
 "tbl_flatten": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "List-like table"
  },
  "doc": "Creates a copy of a list-like table such that any nested\ntables are \"unrolled\" and appended to the result.",
  "return": "Flattened copy of the given list-like table.",
  "seealso": [
   "Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua"
  ]
 },
 "tbl_isempty": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "Table to check"
  },
  "doc": "Checks if a table is empty.",
  "seealso": [
   "https://github.com/premake/premake-core/blob/master/src/base/table.lua"
  ]
 },
 "tbl_islist": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "Table"
  },
  "doc": "Tests if a Lua table can be treated as an array.\nEmpty table `{}` is assumed to be an array, unless it was\ncreated by |vim.empty_dict()| or returned as a dict-like |API|\nor Vimscript result, for example from |rpcrequest()| or\n|vim.fn|.",
  "return": "`true` if array-like table, else `false` .",
  "seealso": []
 },
 "tbl_keys": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "Table"
  },
  "doc": "Return a list of all keys used in a table. However, the order\nof the return table of keys is not guaranteed.",
  "return": "list of keys",
  "seealso": [
   "Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua"
  ]
 },
 "tbl_map": {
  "params": [
   [
    "",
    "func"
   ],
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "func": "function or callable table",
   "t": "table"
  },
  "doc": "Apply a function to all values of a table.",
  "seealso": []
 },
 "tbl_values": {
  "params": [
   [
    "",
    "t"
   ]
  ],
  "params_doc": {
   "t": "Table"
  },
  "doc": "Return a list of all values used in a table. However, the\norder of the return table of values is not guaranteed.",
  "return": "list of values",
  "seealso": []
 },
 "trim": {
  "params": [
   [
    "",
    "s"
   ]
  ],
  "params_doc": {
   "s": "String to trim"
  },
  "doc": "Trim whitespace (Lua pattern \"%s\") from both sides of a\nstring.",
  "return": "String with whitespace removed from its beginning and end",
  "seealso": [
   "https://www.lua.org/pil/20.2.html"
  ]
 },
 "uri_from_bufnr": {
  "params": [
   [
    "",
    "bufnr"
   ]
  ],
  "params_doc": {
   "bufnr": "(number): Buffer number"
  },
  "doc": "Get a URI from a bufnr",
  "return": "URI",
  "seealso": []
 },
 "uri_from_fname": {
  "params": [
   [
    "",
    "path"
   ]
  ],
  "params_doc": {
   "path": "(string): Path to file"
  },
  "doc": "Get a URI from a file path.",
  "return": "URI",
  "seealso": []
 },
 "uri_to_bufnr": {
  "params": [
   [
    "",
    "uri"
   ]
  ],
  "params_doc": {
   "uri": "(string): The URI"
  },
  "doc": "Return or create a buffer for a uri.",
  "return": "bufnr.",
  "seealso": []
 },
 "uri_to_fname": {
  "params": [
   [
    "",
    "uri"
   ]
  ],
  "params_doc": {
   "uri": "(string): The URI"
  },
  "doc": "Get a filename from a URI",
  "return": "Filename",
  "seealso": []
 },
 "validate": {
  "params": [
   [
    "",
    "opt"
   ]
  ],
  "params_doc": {
   "opt": "Map of parameter names to validations. Each key is\n           a parameter name; each value is a tuple in one of\n           these forms:\n           1. (arg_value, type_name, optional)\n              • arg_value: argument value\n              • type_name: string type name, one of: (\"table\",\n                \"t\", \"string\", \"s\", \"number\", \"n\", \"boolean\",\n                \"b\", \"function\", \"f\", \"nil\", \"thread\",\n                \"userdata\")\n              • optional: (optional) boolean, if true, `nil`\n                is valid\n\n           2. (arg_value, fn, msg)\n              • arg_value: argument value\n              • fn: any function accepting one argument,\n                returns true if and only if the argument is\n                valid. Can optionally return an additional\n                informative error message as the second\n                returned value.\n              • msg: (optional) error string if validation\n                fails"
  },
  "doc": "Validates a parameter specification (types and values).\nUsage example: >\n\n  function user.new(name, age, hobbies)\n    vim.validate{\n      name={name, 'string'},\n      age={age, 'number'},\n      hobbies={hobbies, 'table'},\n    }\n    ...\n  end\n \n<\nExamples with explicit argument values (can be run directly): >\n\n  vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}\n     => NOP (success)\n\n  vim.validate{arg1={1, 'table'}}\n     => error('arg1: expected table, got number')\n\n  vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}\n     => error('arg1: expected even number, got 3')\n \n<",
  "seealso": []
 }
}