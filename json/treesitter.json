{
 "LanguageTree:add_child": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "lang"
   ]
  ],
  "params_doc": {
   "lang": "The language to add.",
   "self": ""
  },
  "doc": "Adds a child language to this tree.\nIf the language already exists as a child, it will first be\nremoved.",
  "seealso": []
 },
 "LanguageTree:children": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Returns a map of language to child tree.",
  "seealso": []
 },
 "LanguageTree:contains": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "range"
   ]
  ],
  "params_doc": {
   "range": "A range, that is a `{ start_line, start_col,\n             end_line, end_col }` table.",
   "self": ""
  },
  "doc": "Determines wether This goes down the tree to recursively check childs.",
  "seealso": []
 },
 "LanguageTree:destroy": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Destroys this language tree and all its children.\nAny cleanup logic should be performed here. Note, this DOES\nNOT remove this tree from a parent. `remove_child` must be called on the parent to remove it.",
  "seealso": []
 },
 "LanguageTree:for_each_child": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "fn"
   ],
   [
    "",
    "include_self"
   ]
  ],
  "params_doc": {
   "fn": "The function to invoke. This is invoked\n                    with arguments (tree: LanguageTree, lang:\n                    string)",
   "include_self": "Whether to include the invoking tree in\n                    the results.",
   "self": ""
  },
  "doc": "Invokes the callback for each LanguageTree and it's children\nrecursively",
  "seealso": []
 },
 "LanguageTree:for_each_tree": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "fn"
   ]
  ],
  "params_doc": {
   "fn": "The callback to invoke. The callback is invoked\n            with arguments (tree: TSTree, languageTree:\n            LanguageTree)",
   "self": ""
  },
  "doc": "Invokes the callback for each treesitter trees recursively.\nNote, this includes the invoking language tree's trees as\nwell.",
  "seealso": []
 },
 "LanguageTree:included_regions": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Gets the set of included regions",
  "seealso": []
 },
 "LanguageTree:invalidate": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "reload"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Invalidates this parser and all its children",
  "seealso": []
 },
 "LanguageTree:is_valid": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Determines whether this tree is valid. If the tree is invalid, `parse()` must be called to get the an updated tree.",
  "seealso": []
 },
 "LanguageTree:lang": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Gets the language of this tree node.",
  "seealso": []
 },
 "LanguageTree:language_for_range": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "range"
   ]
  ],
  "params_doc": {
   "range": "A text range, see |LanguageTree:contains|",
   "self": ""
  },
  "doc": "Gets the appropriate language that contains",
  "seealso": []
 },
 "LanguageTree:parse": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Parses all defined regions using a treesitter parser for the\nlanguage this tree represents. This will run the injection\nquery for this language to determine if any child languages\nshould be created.",
  "seealso": []
 },
 "LanguageTree:register_cbs": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "cbs"
   ]
  ],
  "params_doc": {
   "cbs": "An `nvim_buf_attach` -like table argument with the following keys : `on_bytes` : see `nvim_buf_attach` , but this will be called after the parsers callback. `on_changedtree` : a callback that will be called every time the\n            tree has syntactical changes. it will only be\n            passed one argument, that is a table of the ranges\n            (as node ranges) that changed. `on_child_added` : emitted when a child is added to the tree. `on_child_removed` : emitted when a child is removed from the tree.",
   "self": ""
  },
  "doc": "Registers callbacks for the parser",
  "seealso": []
 },
 "LanguageTree:remove_child": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "lang"
   ]
  ],
  "params_doc": {
   "lang": "The language to remove.",
   "self": ""
  },
  "doc": "Removes a child language from this tree.",
  "seealso": []
 },
 "LanguageTree:set_included_regions": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "regions"
   ]
  ],
  "params_doc": {
   "regions": "A list of regions this tree should manage and\n               parse.",
   "self": ""
  },
  "doc": "Sets the included regions that should be parsed by this\nparser. A region is a set of nodes and/or ranges that will be\nparsed in the same context.\nFor example, `{ { node1 }, { node2} }` is two separate\nregions. This will be parsed by the parser in two different\ncontexts... thus resulting in two separate trees.\n`{ { node1, node2 } }` is a single region consisting of two\nnodes. This will be parsed by the parser in a single\ncontext... thus resulting in a single tree.\nThis allows for embedded languages to be parsed together\nacross different nodes, which is useful for templating\nlanguages like ERB and EJS.\nNote, this call invalidates the tree and requires it to be\nparsed again.",
  "seealso": []
 },
 "LanguageTree:source": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Returns the source content of the language tree (bufnr or\nstring).",
  "seealso": []
 },
 "LanguageTree:trees": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Returns all trees this language tree contains. Does not\ninclude child languages.",
  "seealso": []
 },
 "Query:iter_captures": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "node"
   ],
   [
    "",
    "source"
   ],
   [
    "",
    "start"
   ],
   [
    "",
    "stop"
   ]
  ],
  "params_doc": {
   "node": "The node under which the search will occur",
   "source": "The source buffer or string to exctract text\n              from",
   "start": "The starting line of the search",
   "stop": "The stopping line of the search (end-exclusive)",
   "self": ""
  },
  "doc": "Iterate over all captures from all matches inside {node}\n{source} is needed if the query contains predicates, then the\ncaller must ensure to use a freshly parsed tree consistent\nwith the current text of the buffer (if relevent). {start_row}\nand {end_row} can be used to limit matches inside a row range\n(this is typically used with root node as the node, i e to get\nsyntax highlight matches in the current viewport). When\nomitted the start and end row values are used from the given\nnode.\nThe iterator returns three values, a numeric id identifying\nthe capture, the captured node, and metadata from any\ndirectives processing the match. The following example shows\nhow to get captures by name:\n>\n\n for id, node, metadata in query:iter_captures(tree:root(), bufnr, first, last) do\n   local name = query.captures[id] -- name of the capture in the query\n   -- typically useful info about the node:\n   local type = node:type() -- type of the captured node\n   local row1, col1, row2, col2 = node:range() -- range of the capture\n   ... use the info here ...\n end\n \n<",
  "return": "The matching capture id",
  "seealso": []
 },
 "Query:iter_matches": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "node"
   ],
   [
    "",
    "source"
   ],
   [
    "",
    "start"
   ],
   [
    "",
    "stop"
   ]
  ],
  "params_doc": {
   "node": "The node under which the search will occur",
   "source": "The source buffer or string to search",
   "start": "The starting line of the search",
   "stop": "The stopping line of the search (end-exclusive)",
   "self": ""
  },
  "doc": "Iterates the matches of self on a given range.\nIterate over all matches within a node. The arguments are the\nsame as for |query:iter_captures()| but the iterated values\nare different: an (1-based) index of the pattern in the query,\na table mapping capture indices to nodes, and metadata from\nany directives processing the match. If the query has more\nthan one pattern the capture table might be sparse, and e.g.\n`pairs()` method should be used over `ipairs` . Here an\nexample iterating over all captures in every match:\n>\n\n for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, first, last) do\n   for id, node in pairs(match) do\n     local name = query.captures[id]\n     -- `node` was captured by the `name` capture in the match\n\n     local node_data = metadata[id] -- Node level metadata\n\n     ... use the info here ...\n   end\n end\n \n<",
  "return": "The matching pattern id",
  "seealso": []
 },
 "TSHighlighter:destroy": {
  "params": [
   [
    "",
    "self"
   ]
  ],
  "params_doc": {
   "self": ""
  },
  "doc": "Removes all internal references to the highlighter",
  "seealso": []
 },
 "TSHighlighter:get_query": {
  "params": [
   [
    "",
    "self"
   ],
   [
    "",
    "lang"
   ]
  ],
  "params_doc": {
   "lang": "A language used by the highlighter.",
   "self": ""
  },
  "doc": "Gets the query used for",
  "seealso": []
 },
 "add_directive": {
  "params": [
   [
    "",
    "name"
   ],
   [
    "",
    "handler"
   ],
   [
    "",
    "force"
   ]
  ],
  "params_doc": {
   "name": "the name of the directive, without leading #",
   "handler": "the handler function to be used signature will\n               be (match, pattern, bufnr, predicate)"
  },
  "doc": "Adds a new directive to be used in queries",
  "seealso": []
 },
 "add_predicate": {
  "params": [
   [
    "",
    "name"
   ],
   [
    "",
    "handler"
   ],
   [
    "",
    "force"
   ]
  ],
  "params_doc": {
   "name": "the name of the predicate, without leading #",
   "handler": "the handler function to be used signature will\n               be (match, pattern, bufnr, predicate)"
  },
  "doc": "Adds a new predicate to be used in queries",
  "seealso": []
 },
 "get_node_text": {
  "params": [
   [
    "",
    "node"
   ],
   [
    "",
    "source"
   ]
  ],
  "params_doc": {
   "node": "the node",
   "bsource": "The buffer or string from which the node is\n               extracted"
  },
  "doc": "Gets the text corresponding to a given node",
  "seealso": []
 },
 "get_parser": {
  "params": [
   [
    "",
    "bufnr"
   ],
   [
    "",
    "lang"
   ],
   [
    "",
    "opts"
   ]
  ],
  "params_doc": {
   "bufnr": "The buffer the parser should be tied to",
   "lang": "The filetype of this parser",
   "opts": "Options object to pass to the created language\n             tree"
  },
  "doc": "Gets the parser for this bufnr / ft combination.\nIf needed this will create the parser. Unconditionnally attach\nthe provided callback",
  "return": "The parser",
  "seealso": []
 },
 "get_query": {
  "params": [
   [
    "",
    "lang"
   ],
   [
    "",
    "query_name"
   ]
  ],
  "params_doc": {
   "lang": "The language to use for the query",
   "query_name": "The name of the query (i.e. \"highlights\")"
  },
  "doc": "Returns the runtime query {query_name} for {lang}.",
  "return": "The corresponding query, parsed.",
  "seealso": []
 },
 "get_query_files": {
  "params": [
   [
    "",
    "lang"
   ],
   [
    "",
    "query_name"
   ],
   [
    "",
    "is_included"
   ]
  ],
  "params_doc": {
   "lang": "The language",
   "query_name": "The name of the query to load",
   "is_included": "Internal parameter, most of the time left\n                   as `nil`"
  },
  "doc": "Gets the list of files used to make up a query",
  "seealso": []
 },
 "get_string_parser": {
  "params": [
   [
    "",
    "str"
   ],
   [
    "",
    "lang"
   ],
   [
    "",
    "opts"
   ]
  ],
  "params_doc": {
   "str": "The string to parse",
   "lang": "The language of this string",
   "opts": "Options to pass to the created language tree"
  },
  "doc": "Gets a string parser",
  "seealso": []
 },
 "inspect_language": {
  "params": [
   [
    "",
    "lang"
   ]
  ],
  "params_doc": {
   "lang": "The language."
  },
  "doc": "Inspects the provided language.\nInspecting provides some useful informations on the language\nlike node names, ...",
  "seealso": []
 },
 "list_directives": {
  "params": [],
  "params_doc": {},
  "doc": "",
  "return": "The list of supported directives.",
  "seealso": []
 },
 "list_predicates": {
  "params": [],
  "params_doc": {},
  "doc": "",
  "return": "The list of supported predicates.",
  "seealso": []
 },
 "new": {
  "params": [
   [
    "",
    "source"
   ],
   [
    "",
    "lang"
   ],
   [
    "",
    "opts"
   ]
  ],
  "params_doc": {
   "source": "Can be a bufnr or a string of text to\n                       parse",
   "lang": "The language this tree represents",
   "opts": "Options table",
   "opts.injections": "A table of language to injection query\n                       strings. This is useful for overriding\n                       the built-in runtime file searching for\n                       the injection language query per\n                       language."
  },
  "doc": "Represents a single treesitter parser for a language. The\nlanguage can contain child languages with in its range, hence\nthe tree.",
  "seealso": []
 },
 "parse_query": {
  "params": [
   [
    "",
    "lang"
   ],
   [
    "",
    "query"
   ]
  ],
  "params_doc": {
   "lang": "The language",
   "query": "A string containing the query (s-expr syntax)"
  },
  "doc": "Parse {query} as a string. (If the query is in a file, the\ncaller should read the contents into a string before calling).\nReturns a `Query` (see |lua-treesitter-query|) object which\ncan be used to search nodes in the syntax tree for the\npatterns defined in {query} using `iter_*` methods below.\nExposes `info` and `captures` with additional information about the {query}.\n• `captures` contains the list of unique capture names defined\n  in {query}. - `info.captures` also points to `captures` .\n• `info.patterns` contains information about predicates.\n",
  "return": "The query",
  "seealso": []
 },
 "require_language": {
  "params": [
   [
    "",
    "lang"
   ],
   [
    "",
    "path"
   ],
   [
    "",
    "silent"
   ]
  ],
  "params_doc": {
   "lang": "The language the parser should parse",
   "path": "Optional path the parser is located at",
   "silent": "Don't throw an error if language not found"
  },
  "doc": "Asserts that the provided language is installed, and\noptionally provide a path for the parser\nParsers are searched in the `parser` runtime directory.",
  "seealso": []
 },
 "set_query": {
  "params": [
   [
    "",
    "lang"
   ],
   [
    "",
    "query_name"
   ],
   [
    "",
    "text"
   ]
  ],
  "params_doc": {
   "lang": "string: The language to use for the query",
   "query_name": "string: The name of the query (i.e.\n                  \"highlights\")",
   "text": "string: The query text (unparsed)."
  },
  "doc": "The explicitly set queries from\n|vim.treesitter.query.set_query()|.\nSets the runtime query {query_name} for {lang}\nThis allows users to override any runtime files and/or\nconfiguration set by plugins.",
  "seealso": []
 }
}