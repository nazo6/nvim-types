{
 "leftTitle": "VIM",
 "rightTitle": "lua-builtin",
 "description": "",
 "data": [
  {
   "type": "func",
   "name": "vim.api.{func}",
   "description": "        Invokes Nvim |API| function {func} with arguments {...}.\n        Example: call the \"nvim_get_current_line()\" API function: >\n            print(tostring(vim.api.nvim_get_current_line()))",
   "argsStr": "{...}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.version",
   "description": "        Returns the version of the current neovim build.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.in_fast_event",
   "description": "        Returns true if the code is executing as part of a \"fast\" event\n        handler, where most of the API is disabled. These are low-level events\n        (e.g. |lua-loop-callbacks|) which can be invoked whenever Nvim polls\n        for input.  When this is `false` most API functions are callable (but\n        may be subject to other restrictions such as |textlock|).",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "vim.NIL",
   "description": "\tSpecial value used to represent NIL in msgpack-rpc and |v:null| in\n\tvimL interaction, and similar cases. Lua `nil` cannot be used as\n\tpart of a lua table representing a Dictionary or Array, as it\n\tis equivalent to a missing value: `{\"foo\", nil}` is the same as \n\t`{\"foo\"}`",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "vim.empty_dict",
   "description": "\tCreates a special table which will be converted to an empty\n\tdictionary when converting lua values to vimL or API types. The\n\ttable is empty, and this property is marked using a metatable. An\n\tempty table `{}` without this metatable will default to convert to\n\tan array/list.\n\n\tNote: if numeric keys are added to the table, the metatable will be\n\tignored and the dict converted to a list/array anyway.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.region",
   "description": "        Converts a selection specified by the buffer ({bufnr}), starting\n        position ({pos1}, a zero-indexed pair `{line1,column1}`), ending\n        position ({pos2}, same format as {pos1}), the type of the register\n        for the selection ({type}, see |regtype|), and a boolean indicating\n        whether the selection is inclusive or not, into a zero-indexed table \n        of linewise selections of the form `{linenr = {startcol, endcol}}` .",
   "argsStr": "{bufnr}, {pos1}, {pos2}, {type}, {inclusive}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.register_keystroke_callback",
   "description": "        Register a lua {fn} with an {ns_id} to be run after every keystroke.\n\n        Parameters: ~\n            {fn}: (function): Function to call on keystroke.\n                    It should take one argument, which is a string.\n                    The string will contain the literal keys typed.\n                    See |i_CTRL-V|\n\n                    If {fn} is `nil`, it removes the callback for the\n                    associated {ns_id}.\n\n            {ns_id}: (number)  Namespace ID. If not passed or 0, will generate\n                     and return a new namespace ID from |nvim_create_namespace()|\n\n        Return: ~\n            (number) Namespace ID associated with {fn}\n\n        NOTE: {fn} will be automatically removed if an error occurs while\n        calling. This is to prevent the annoying situation of every keystroke\n        erroring while trying to remove a broken callback.\n\n        NOTE: {fn} will receive the keystrokes after mappings have been\n        evaluated\n\n        NOTE: {fn} will *NOT* be cleared from |nvim_buf_clear_namespace()|",
   "argsStr": "{fn}, {ns_id}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.rpcnotify",
   "description": "\tSends {event} to {channel} via |RPC| and returns immediately.\n\tIf {channel} is 0, the event is broadcast to all channels.\n\n\tThis function also works in a fast callback |lua-loop-callbacks|.",
   "argsStr": "{channel}, {method}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.rpcrequest",
   "description": "\tSends a request to {channel} to invoke {method} via\n\t|RPC| and blocks until a response is received.\n\n\tNote: NIL values as part of the return value is represented as\n\t|vim.NIL| special value",
   "argsStr": "{channel}, {method}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.stricmp",
   "description": "        Compares strings case-insensitively.  Returns 0, 1 or -1 if strings\n        are equal, {a} is greater than {b} or {a} is lesser than {b},\n        respectively.",
   "argsStr": "{a}, {b}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.str_utfindex",
   "description": "        Convert byte index to UTF-32 and UTF-16 indicies. If {index} is not\n        supplied, the length of the string is used. All indicies are zero-based.\n        Returns two values: the UTF-32 and UTF-16 indicies respectively.\n\n        Embedded NUL bytes are treated as terminating the string. Invalid\n        UTF-8 bytes, and embedded surrogates are counted as one code\n        point each. An {index} in the middle of a UTF-8 sequence is rounded\n        upwards to the end of that sequence.",
   "argsStr": "{str}[, {index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.str_byteindex",
   "description": "        Convert UTF-32 or UTF-16 {index} to byte index. If {use_utf16} is not\n        supplied, it defaults to false (use UTF-32). Returns the byte index.\n\n        Invalid UTF-8 and NUL is treated like by |vim.str_byteindex()|. An {index}\n        in the middle of a UTF-16 sequence is rounded upwards to the end of that\n        sequence.",
   "argsStr": "{str}, {index}[, {use_utf16}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.schedule",
   "description": "        Schedules {callback} to be invoked soon by the main event-loop. Useful\n        to avoid |textlock| or other temporary restrictions.",
   "argsStr": "{callback}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.defer_fn",
   "description": "    Defers calling {fn} until {timeout} ms passes.  Use to do a one-shot timer\n    that calls {fn}.\n\n    Note: The {fn} is |schedule_wrap|ped automatically, so API functions are\n    safe to call.\n\n    Parameters: ~\n        {fn}        Callback to call once {timeout} expires\n        {timeout}   Time in ms to wait before calling {fn}\n\n    Returns: ~\n        |vim.loop|.new_timer() object",
   "argsStr": "{fn}, {timeout}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "vim.wait",
   "description": "        Wait for {time} in milliseconds until {callback} returns `true`.\n\n        Executes {callback} immediately and at approximately {interval}\n        milliseconds (default 200). Nvim still processes other events during\n        this time.\n\n    Parameters: ~\n        {time}      Number of milliseconds to wait\n        {callback}  Optional callback. Waits until {callback} returns true\n        {interval}  (Approximate) number of milliseconds to wait between polls\n        {fast_only} If true, only |api-fast| events will be processed.\n                        If called from while in an |api-fast| event, will\n                        automatically be set to `true`.\n\n    Returns: ~\n        If {callback} returns `true` during the {time}:\n            `true, nil`\n\n        If {callback} never returns `true` during the {time}:\n            `false, -1`\n\n        If {callback} is interrupted during the {time}:\n            `false, -2`\n\n        If {callback} errors, the error is raised.\n\n        Examples: >\n\n    ---\n    -- Wait for 100 ms, allowing other events to process\n    vim.wait(100, function() end)\n\n    ---\n    -- Wait for 100 ms or until global variable set.\n    vim.wait(100, function() return vim.g.waiting_for_var end)\n\n    ---\n    -- Wait for 1 second or until global variable set, checking every ~500 ms\n    vim.wait(1000, function() return vim.g.waiting_for_var end, 500)\n\n    ---\n    -- Schedule a function to set a value in 100ms\n    vim.defer_fn(function() vim.g.timer_result = true end, 100)\n\n    -- Would wait ten seconds if results blocked. Actually only waits  100 ms\n    if vim.wait(10000, function() return vim.g.timer_result end) then\n      print('Only waiting a little bit of time!')\n    end\n<",
   "argsStr": "{time} [, {callback}, {interval}, {fast_only}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "vim.type_idx",
   "description": "\tType index for use in |lua-special-tbl|.  Specifying one of the \n\tvalues from |vim.types| allows typing the empty table (it is \n\tunclear whether empty Lua table represents empty list or empty array) \n\tand forcing integral numbers to be |Float|.  See |lua-special-tbl| for \n\tmore details.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "vim.val_idx",
   "description": "\tValue index for tables representing |Float|s.  A table representing \n\tfloating-point value 1.0 looks like this: >\n            {\n              [vim.type_idx] = vim.types.float,\n              [vim.val_idx] = 1.0,\n            }\n<\tSee also |vim.type_idx| and |lua-special-tbl|.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "vim.types",
   "description": "\tTable with possible values for |vim.type_idx|.  Contains two sets \n\tof key-value pairs: first maps possible values for |vim.type_idx| \n\tto human-readable strings, second maps human-readable type names to \n\tvalues for |vim.type_idx|.  Currently contains pairs for `float`, \n\t`array` and `dictionary` types.\n\n\tNote: one must expect that values corresponding to `vim.types.float`, \n\t`vim.types.array` and `vim.types.dictionary` fall under only two \n\tfollowing assumptions:\n\t1. Value may serve both as a key and as a value in a table.  Given the \n\t   properties of Lua tables this basically means “value is not `nil`”.\n\t2. For each value in `vim.types` table `vim.types[vim.types[value]]` \n\t   is the same as `value`.\n\tNo other restrictions are put on types, and it is not guaranteed that \n\tvalues corresponding to `vim.types.float`, `vim.types.array` and \n\t`vim.types.dictionary` will not change or that `vim.types` table will \n\tonly contain values for these three types.",
   "valuetype": "any"
  }
 ]
}