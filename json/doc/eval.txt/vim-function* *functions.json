{
 "leftTitle": "4. Builtin Functions",
 "rightTitle": "vim-function* *functions",
 "description": "",
 "data": [
  {
   "type": "func",
   "name": "abs",
   "description": "\t\tReturn the absolute value of {expr}.  When {expr} evaluates to\n\t\ta |Float| abs() returns a |Float|.  When {expr} can be\n\t\tconverted to a |Number| abs() returns a |Number|.  Otherwise\n\t\tabs() gives an error message and returns -1.\n\t\tExamples: >\n\t\t\techo abs(1.456)\n<\t\t\t1.456  >\n\t\t\techo abs(-5.456)\n<\t\t\t5.456  >\n\t\t\techo abs(-4)\n<\t\t\t4\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->abs()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "acos",
   "description": "\t\tReturn the arc cosine of {expr} measured in radians, as a\n\t\t|Float| in the range of [0, pi].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo acos(0)\n<\t\t\t1.570796 >\n\t\t\t:echo acos(-0.5)\n<\t\t\t2.094395\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->acos()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "add",
   "description": "\t\tAppend the item {expr} to |List| or |Blob| {object}.  Returns\n\t\tthe resulting |List| or |Blob|.  Examples: >\n\t\t\t:let alist = add([1, 2, 3], item)\n\t\t\t:call add(mylist, \"woodstock\")\n<\t\tNote that when {expr} is a |List| it is appended as a single\n\t\titem.  Use |extend()| to concatenate |Lists|.\n\t\tWhen {object} is a |Blob| then {expr} must be a number.\n\t\tUse |insert()| to add an item at another position.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->add(val1)->add(val2)",
   "argsStr": "{object}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "and",
   "description": "\t\tBitwise AND on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let flag = and(bits, 0x80)\n<\t\tCan also be used as a |method|: >\n\t\t\t:let flag = bits->and(0x80)",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "api_info",
   "description": "\t\tReturns Dictionary of |api-metadata|.\n\n\t\tView it in a nice human-readable format: >\n\t\t       :lua print(vim.inspect(vim.fn.api_info()))",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "append",
   "description": "\t\tWhen {text} is a |List|: Append each item of the |List| as a\n\t\ttext line below line {lnum} in the current buffer.\n\t\tOtherwise append {text} as one text line below line {lnum} in\n\t\tthe current buffer.\n\t\t{lnum} can be zero to insert a line before the first one.\n\t\t{lnum} is used like with |getline()|.\n\t\tReturns 1 for failure ({lnum} out of range or out of memory),\n\t\t0 for success.  Example: >\n\t\t\t:let failed = append(line('$'), \"# THE END\")\n\t\t\t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])\n\n<\t\tCan also be used as a |method| after a List: >\n\t\t\tmylist->append(lnum)",
   "argsStr": "{lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "appendbufline",
   "description": "\t\tLike |append()| but append the text in buffer {expr}.\n\n\t\tThis function works only for loaded buffers. First call\n\t\t|bufload()| if needed.\n\n\t\tFor the use of {buf}, see |bufname()|.\n\n\t\t{lnum} is used like with |append()|.  Note that using |line()|\n\t\twould use the current buffer, not the one appending to.\n\t\tUse \"$\" to append at the end of the buffer.\n\n\t\tOn success 0 is returned, on failure 1 is returned.\n\n\t\tIf {buf} is not a valid buffer or {lnum} is not valid, an\n\t\terror message is given. Example: >\n\t\t\t:let failed = appendbufline(13, 0, \"# THE START\")\n<\n\t\tCan also be used as a |method| after a List: >\n\t\t\tmylist->appendbufline(buf, lnum)",
   "argsStr": "{buf}, {lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argc",
   "description": "\t\tThe result is the number of files in the argument list.  See\n\t\t|arglist|.\n\t\tIf {winid} is not supplied, the argument list of the current\n\t\twindow is used.\n\t\tIf {winid} is -1, the global argument list is used.\n\t\tOtherwise {winid} specifies the window of which the argument\n\t\tlist is used: either the window number or the window ID.\n\t\tReturns -1 if the {winid} argument is invalid.",
   "argsStr": "[{winid}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argidx",
   "description": "The result is the current index in the argument list.  0 is\n\t\tthe first file.  argc() - 1 is the last one.  See |arglist|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "arglistid",
   "description": "\t\tReturn the argument list ID.  This is a number which\n\t\tidentifies the argument list being used.  Zero is used for the\n\t\tglobal argument list.  See |arglist|.\n\t\tReturns -1 if the arguments are invalid.\n\n\t\tWithout arguments use the current window.\n\t\tWith {winnr} only use this window in the current tab page.\n\t\tWith {winnr} and {tabnr} use the window in the specified tab\n\t\tpage.\n\t\t{winnr} can be the window number or the |window-ID|.",
   "argsStr": "[{winnr} [, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argv",
   "description": "\t\tThe result is the {nr}th file in the argument list.  See\n\t\t|arglist|.  \"argv(0)\" is the first one.  Example: >\n\t:let i = 0\n\t:while i < argc()\n\t:  let f = escape(fnameescape(argv(i)), '.')\n\t:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'\n\t:  let i = i + 1\n\t:endwhile\n<\t\tWithout the {nr} argument, or when {nr} is -1, a |List| with\n\t\tthe whole |arglist| is returned.\n\n\t\tThe {winid} argument specifies the window ID, see |argc()|.\n\t\tFor the Vim command line arguments see |v:argv|.",
   "argsStr": "[{nr} [, {winid}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "asin",
   "description": "\t\tReturn the arc sine of {expr} measured in radians, as a |Float|\n\t\tin the range of [-pi/2, pi/2].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo asin(0.8)\n<\t\t\t0.927295 >\n\t\t\t:echo asin(-0.5)\n<\t\t\t-0.523599\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->asin()\n\n\nassert_ functions are documented here: |assert-functions-details|",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "atan",
   "description": "\t\tReturn the principal value of the arc tangent of {expr}, in\n\t\tthe range [-pi/2, +pi/2] radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan(100)\n<\t\t\t1.560797 >\n\t\t\t:echo atan(-4.01)\n<\t\t\t-1.326405\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->atan()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "atan2",
   "description": "\t\tReturn the arc tangent of {expr1} / {expr2}, measured in\n\t\tradians, as a |Float| in the range [-pi, pi].\n\t\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan2(-1, 1)\n<\t\t\t-0.785398 >\n\t\t\t:echo atan2(1, -1)\n<\t\t\t2.356194\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->atan2(1)",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "browse",
   "description": "\t\tPut up a file requester.  This only works when \"has(\"browse\")\"\n\t\treturns |TRUE| (only in some GUI versions).\n\t\tThe input fields are:\n\t\t    {save}\twhen |TRUE|, select file to write\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\t    {default}\tdefault file name\n\t\tAn empty string is returned when the \"Cancel\" button is hit,\n\t\tsomething went wrong, or browsing is not possible.",
   "argsStr": "{save}, {title}, {initdir}, {default}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "browsedir",
   "description": "\t\tPut up a directory requester.  This only works when\n\t\t\"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n\t\tOn systems where a directory browser is not supported a file\n\t\tbrowser is used.  In that case: select a file in the directory\n\t\tto be used.\n\t\tThe input fields are:\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\tWhen the \"Cancel\" button is hit, something went wrong, or\n\t\tbrowsing is not possible, an empty string is returned.",
   "argsStr": "{title}, {initdir}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufadd",
   "description": "\t\tAdd a buffer to the buffer list with String {name}.\n\t\tIf a buffer for file {name} already exists, return that buffer\n\t\tnumber.  Otherwise return the buffer number of the newly\n\t\tcreated buffer.  When {name} is an empty string then a new\n\t\tbuffer is always created.\n\t\tThe buffer will not have' 'buflisted' set.\n<\t\tCan also be used as a |method|: >\n\t\t\tlet bufnr = 'somename'->bufadd()",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufexists",
   "description": "\t\tThe result is a Number, which is |TRUE| if a buffer called\n\t\t{buf} exists.\n\t\tIf the {buf} argument is a number, buffer numbers are used.\n\t\tNumber zero is the alternate buffer for the current window.\n\n\t\tIf the {buf} argument is a string it must match a buffer name\n\t\texactly.  The name can be:\n\t\t- Relative to the current directory.\n\t\t- A full path.\n\t\t- The name of a buffer with 'buftype' set to \"nofile\".\n\t\t- A URL name.\n\t\tUnlisted buffers will be found.\n\t\tNote that help files are listed by their short name in the\n\t\toutput of |:buffers|, but bufexists() requires using their\n\t\tlong name to be able to find them.\n\t\tbufexists() may report a buffer exists, but to use the name\n\t\twith a |:buffer| command you may need to use |expand()|.  Esp\n\t\tfor MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\n\t\tUse \"bufexists(0)\" to test for the existence of an alternate\n\t\tfile name.\n\n\t\tCan also be used as a |method|: >\n\t\t\tlet exists = 'somename'->bufexists()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "buflisted",
   "description": "\t\tThe result is a Number, which is |TRUE| if a buffer called\n\t\t{buf} exists and is listed (has the 'buflisted' option set).\n\t\tThe {buf} argument is used like with |bufexists()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tlet listed = 'somename'->buflisted()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufload",
   "description": "\t\tEnsure the buffer {buf} is loaded.  When the buffer name\n\t\trefers to an existing file then the file is read.  Otherwise\n\t\tthe buffer will be empty.  If the buffer was already loaded\n\t\tthen there is no change.\n\t\tIf there is an existing swap file for the file of the buffer,\n\t\tthere will be no dialog, the buffer will be loaded anyway.\n\t\tThe {buf} argument is used like with |bufexists()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\teval 'somename'->bufload()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufloaded",
   "description": "\t\tThe result is a Number, which is |TRUE| if a buffer called\n\t\t{buf} exists and is loaded (shown in a window or hidden).\n\t\tThe {buf} argument is used like with |bufexists()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tlet loaded = 'somename'->bufloaded()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufname",
   "description": "\t\tThe result is the name of a buffer.  Mostly as it is displayed\n\t\tby the `:ls` command, but not using special names such as\n\t\t\"[No Name]\".\n\t\tIf {buf} is omitted the current buffer is used.\n\t\tIf {buf} is a Number, that buffer number's name is given.\n\t\tNumber zero is the alternate buffer for the current window.\n\t\tIf {buf} is a String, it is used as a |file-pattern| to match\n\t\twith the buffer names.  This is always done like 'magic' is\n\t\tset and 'cpoptions' is empty.  When there is more than one\n\t\tmatch an empty string is returned.\n\t\t\"\" or \"%\" can be used for the current buffer, \"#\" for the\n\t\talternate buffer.\n\t\tA full match is preferred, otherwise a match at the start, end\n\t\tor middle of the buffer name is accepted.  If you only want a\n\t\tfull match then put \"^\" at the start and \"$\" at the end of the\n\t\tpattern.\n\t\tListed buffers are found first.  If there is a single match\n\t\twith a listed buffer, that one is returned.  Next unlisted\n\t\tbuffers are searched for.\n\t\tIf the {buf} is a String, but you want to use it as a buffer\n\t\tnumber, force it to be a Number by adding zero to it: >\n\t\t\t:echo bufname(\"3\" + 0)\n<\t\tCan also be used as a |method|: >\n\t\t\techo bufnr->bufname()\n\n<\t\tIf the buffer doesn't exist, or doesn't have a name, an empty\n\t\tstring is returned. >\n\tbufname(\"#\")\t\talternate buffer name\n\tbufname(3)\t\tname of buffer 3\n\tbufname(\"%\")\t\tname of current buffer\n\tbufname(\"file2\")\tname of buffer where \"file2\" matches.",
   "argsStr": "[{buf}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufnr",
   "description": "\t\tThe result is the number of a buffer, as it is displayed by\n\t\tthe `:ls` command.  For the use of {buf}, see |bufname()|\n\t\tabove.\n\t\tIf the buffer doesn't exist, -1 is returned.  Or, if the\n\t\t{create} argument is present and TRUE, a new, unlisted,\n\t\tbuffer is created and its number is returned.\n\t\tbufnr(\"$\") is the last buffer: >\n\t\t\t:let last_buffer = bufnr(\"$\")\n<\t\tThe result is a Number, which is the highest buffer number\n\t\tof existing buffers.  Note that not all buffers with a smaller\n\t\tnumber necessarily exist, because \":bwipeout\" may have removed\n\t\tthem.  Use bufexists() to test for the existence of a buffer.\n\n\t\tCan also be used as a |method|: >\n\t\t\techo bufref->bufnr()",
   "argsStr": "[{buf} [, {create}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufwinid",
   "description": "\t\tThe result is a Number, which is the |window-ID| of the first\n\t\twindow associated with buffer {buf}.  For the use of {buf},\n\t\tsee |bufname()| above.  If buffer {buf} doesn't exist or\n\t\tthere is no such window, -1 is returned.  Example: >\n\n\techo \"A window containing buffer 1 is \" . (bufwinid(1))\n<\n\t\tOnly deals with the current tab page.\n\n\t\tCan also be used as a |method|: >\n\t\t\tFindBuffer()->bufwinid()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufwinnr",
   "description": "\t\tLike |bufwinid()| but return the window number instead of the\n\t\t|window-ID|.\n\t\tIf buffer {buf} doesn't exist or there is no such window, -1\n\t\tis returned.  Example: >\n\n\techo \"A window containing buffer 1 is \" . (bufwinnr(1))\n\n<\t\tThe number can be used with |CTRL-W_w| and \":wincmd w\"\n\t\t|:wincmd|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tFindBuffer()->bufwinnr()",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byte2line",
   "description": "\t\tReturn the line number that contains the character at byte\n\t\tcount {byte} in the current buffer.  This includes the\n\t\tend-of-line character, depending on the 'fileformat' option\n\t\tfor the current buffer.  The first character has byte count\n\t\tone.\n\t\tAlso see |line2byte()|, |go| and |:goto|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetOffset()->byte2line()",
   "argsStr": "{byte}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byteidx",
   "description": "\t\tReturn byte index of the {nr}'th character in the String\n\t\t{expr}.  Use zero for the first character, it then returns\n\t\tzero.\n\t\tIf there are no multibyte characters the returned value is\n\t\tequal to {nr}.\n\t\tComposing characters are not counted separately, their byte\n\t\tlength is added to the preceding base character.  See\n\t\t|byteidxcomp()| below for counting composing characters\n\t\tseparately.\n\t\tExample : >\n\t\t\techo matchstr(str, \".\", byteidx(str, 3))\n<\t\twill display the fourth character.  Another way to do the\n\t\tsame: >\n\t\t\tlet s = strpart(str, byteidx(str, 3))\n\t\t\techo strpart(s, 0, byteidx(s, 1))\n<\t\tAlso see |strgetchar()| and |strcharpart()|.\n\n\t\tIf there are less than {nr} characters -1 is returned.\n\t\tIf there are exactly {nr} characters the length of the string\n\t\tin bytes is returned.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetName()->byteidx(idx)",
   "argsStr": "{expr}, {nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byteidxcomp",
   "description": "\t\tLike byteidx(), except that a composing character is counted\n\t\tas a separate character.  Example: >\n\t\t\tlet s = 'e' . nr2char(0x301)\n\t\t\techo byteidx(s, 1)\n\t\t\techo byteidxcomp(s, 1)\n\t\t\techo byteidxcomp(s, 2)\n<\t\tThe first and third echo result in 3 ('e' plus composing\n\t\tcharacter is 3 bytes), the second echo results in 1 ('e' is\n\t\tone byte).\n\t\tOnly works differently from byteidx() when 'encoding' is set to\n\t\ta Unicode encoding.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetName()->byteidxcomp(idx)",
   "argsStr": "{expr}, {nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "call",
   "description": "\t\tCall function {func} with the items in |List| {arglist} as\n\t\targuments.\n\t\t{func} can either be a |Funcref| or the name of a function.\n\t\ta:firstline and a:lastline are set to the cursor line.\n\t\tReturns the return value of the called function.\n\t\t{dict} is for functions with the \"dict\" attribute.  It will be\n\t\tused to set the local variable \"self\". |Dictionary-function|\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetFunc()->call([arg, arg], dict)",
   "argsStr": "{func}, {arglist} [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ceil",
   "description": "\t\tReturn the smallest integral value greater than or equal to\n\t\t{expr} as a |Float| (round up).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo ceil(1.456)\n<\t\t\t2.0  >\n\t\t\techo ceil(-5.456)\n<\t\t\t-5.0  >\n\t\t\techo ceil(4.0)\n<\t\t\t4.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->ceil()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "changenr",
   "description": "\t\tReturn the number of the most recent change.  This is the same\n\t\tnumber as what is displayed with |:undolist| and can be used\n\t\twith the |:undo| command.\n\t\tWhen a change was made it is the number of that change.  After\n\t\tredo it is the number of the redone change.  After undo it is\n\t\tone less than the number of the undone change.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "chanclose",
   "description": "\t\tClose a channel or a specific stream associated with it.\n\t\tFor a job, {stream} can be one of \"stdin\", \"stdout\",\n\t\t\"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n\t\twith `\"rpc\":v:true`) If {stream} is omitted, all streams\n\t\tare closed. If the channel is a pty, this will then close the\n\t\tpty master, sending SIGHUP to the job process.\n\t\tFor a socket, there is only one stream, and {stream} should be\n\t\tommited.",
   "argsStr": "{id}[, {stream}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "chansend",
   "description": "\t\tSend data to channel {id}. For a job, it writes it to the\n\t\tstdin of the process. For the stdio channel |channel-stdio|,\n\t\tit writes to Nvim's stdout.  Returns the number of bytes\n\t\twritten if the write succeeded, 0 otherwise.\n\t\tSee |channel-bytes| for more information.\n\n\t\t{data} may be a string, string convertible, |Blob|, or a list.\n\t\tIf {data} is a list, the items will be joined by newlines; any\n\t\tnewlines in an item will be sent as NUL. To send a final\n\t\tnewline, include a final empty string. Example: >\n\t\t\t:call chansend(id, [\"abc\", \"123\\n456\", \"\"])\n< \t\twill send \"abc<NL>123<NUL>456<NL>\".\n\n\t\tchansend() writes raw data, not RPC messages.  If the channel\n\t\twas created with `\"rpc\":v:true` then the channel expects RPC\n\t\tmessages, use |rpcnotify()| and |rpcrequest()| instead.",
   "argsStr": "{id}, {data}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "char2nr",
   "description": "\t\tReturn number value of the first char in {string}.\n\t\tExamples: >\n\t\t\tchar2nr(\" \")\t\treturns 32\n\t\t\tchar2nr(\"ABC\")\t\treturns 65\n\t\t\tchar2nr(\"á\")\t\treturns 225\n\t\t\tchar2nr(\"á\"[0])\t\treturns 195\n\t\t\tchar2nr(\"\\<M-x>\")\treturns 128\n<\t\tNon-ASCII characters are always treated as UTF-8 characters.\n\t\t{utf8} is ignored, it exists only for backwards-compatibility.\n\t\tA combining character is a separate character.\n\t\t|nr2char()| does the opposite.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetChar()->char2nr()",
   "argsStr": "{string} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "charidx",
   "description": "\t\tReturn the character index of the byte at {idx} in {string}.\n\t\tThe index of the first character is zero.\n\t\tIf there are no multibyte characters the returned value is\n\t\tequal to {idx}.\n\t\tWhen {countcc} is omitted or |FALSE|, then composing characters\n\t\tare not counted separately, their byte length is\n\t\tadded to the preceding base character.\n\t\tWhen {countcc} is |TRUE|, then composing characters are\n\t\tcounted as separate characters.\n\t\tReturns -1 if the arguments are invalid or if {idx} is greater\n\t\tthan the index of the last byte in {string}.  An error is\n\t\tgiven if the first argument is not a string, the second\n\t\targument is not a number or when the third argument is present\n\t\tand is not zero or one.\n\t\tSee |byteidx()| and |byteidxcomp()| for getting the byte index\n\t\tfrom the character index.\n\t\tExamples: >\n\t\t\techo charidx('áb́ć', 3)\t\treturns 1\n\t\t\techo charidx('áb́ć', 6, 1)\treturns 4\n\t\t\techo charidx('áb́ć', 16)\t\treturns -1",
   "argsStr": "{string}, {idx} [, {countcc}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cindent",
   "description": "\t\tGet the amount of indent for line {lnum} according the C\n\t\tindenting rules, as with 'cindent'.\n\t\tThe indent is counted in spaces, the value of 'tabstop' is\n\t\trelevant.  {lnum} is used just like in |getline()|.\n\t\tWhen {lnum} is invalid -1 is returned.\n\t\tSee |C-indenting|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetLnum()->cindent()",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "clearmatches",
   "description": " \t\tClears all matches previously defined for the current window\n \t\tby |matchadd()| and the |:match| commands.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetWin()->clearmatches()\n<",
   "argsStr": "[{win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "col",
   "description": "The result is a Number, which is the byte index of the column\n\t\tposition given with {expr}.  The accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the end of the cursor line (the result is the\n\t\t\t    number of bytes in the cursor line plus one)\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    v       In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tAdditionally {expr} can be [lnum, col]: a |List| with the line\n\t\tand column number. Most useful when the column is \"$\", to get\n\t\tthe last column of a specific line.  When \"lnum\" or \"col\" is\n\t\tout of range then col() returns zero.\n\t\tTo get the line number use |line()|.  To get both use\n\t\t|getpos()|.\n\t\tFor the screen column position use |virtcol()|.\n\t\tNote that only marks in the current file can be used.\n\t\tExamples: >\n\t\t\tcol(\".\")\t\tcolumn of cursor\n\t\t\tcol(\"$\")\t\tlength of cursor line plus one\n\t\t\tcol(\"'t\")\t\tcolumn of mark t\n\t\t\tcol(\"'\" . markname)\tcolumn of mark markname\n<\t\tThe first column is 1.  0 is returned for an error.\n\t\tFor an uppercase mark the column may actually be in another\n\t\tbuffer.\n\t\tFor the cursor position, when 'virtualedit' is active, the\n\t\tcolumn is one higher if the cursor is after the end of the\n\t\tline.  This can be used to obtain the column in Insert mode: >\n\t\t\t:imap <F2> <C-O>:let save_ve = &ve<CR>\n\t\t\t\t\\<C-O>:set ve=all<CR>\n\t\t\t\t\\<C-O>:echo col(\".\") . \"\\n\" <Bar>\n\t\t\t\t\\let &ve = save_ve<CR>\n\n<\t\tCan also be used as a |method|: >\n\t\t\tGetPos()->col()\n<",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete",
   "description": "\t\tSet the matches for Insert mode completion.\n\t\tCan only be used in Insert mode.  You need to use a mapping\n\t\twith CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n\t\tor with an expression mapping.\n\t\t{startcol} is the byte offset in the line where the completed\n\t\ttext start.  The text up to the cursor is the original text\n\t\tthat will be replaced by the matches.  Use col('.') for an\n\t\tempty string.  \"col('.') - 1\" will replace one character by a\n\t\tmatch.\n\t\t{matches} must be a |List|.  Each |List| item is one match.\n\t\tSee |complete-items| for the kind of items that are possible.\n\t\t\"longest\" in 'completeopt' is ignored.\n\t\tNote that the after calling this function you need to avoid\n\t\tinserting anything that would cause completion to stop.\n\t\tThe match can be selected with CTRL-N and CTRL-P as usual with\n\t\tInsert mode completion.  The popup menu will appear if\n\t\tspecified, see |ins-completion-menu|.\n\t\tExample: >\n\tinoremap <F5> <C-R>=ListMonths()<CR>\n\n\tfunc! ListMonths()\n\t  call complete(col('.'), ['January', 'February', 'March',\n\t\t\\ 'April', 'May', 'June', 'July', 'August', 'September',\n\t\t\\ 'October', 'November', 'December'])\n\t  return ''\n\tendfunc\n<\t\tThis isn't very useful, but it shows how it works.  Note that\n\t\tan empty string is returned to avoid a zero being inserted.\n\n\t\tCan also be used as a |method|, the second argument is passed\n\t\tin: >\n\t\t\tGetMatches()->complete(col('.'))",
   "argsStr": "{startcol}, {matches}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_add",
   "description": "\t\tAdd {expr} to the list of matches.  Only to be used by the\n\t\tfunction specified with the 'completefunc' option.\n\t\tReturns 0 for failure (empty string or out of memory),\n\t\t1 when the match was added, 2 when the match was already in\n\t\tthe list.\n\t\tSee |complete-functions| for an explanation of {expr}.  It is\n\t\tthe same as one item in the list that 'omnifunc' would return.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetMoreMatches()->complete_add()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_check",
   "description": "\t\tCheck for a key typed while looking for completion matches.\n\t\tThis is to be used when looking for matches takes some time.\n\t\tReturns |TRUE| when searching for matches is to be aborted,\n\t\tzero otherwise.\n\t\tOnly to be used by the function specified with the\n\t\t'completefunc' option.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_info",
   "description": "\t\tReturns a |Dictionary| with information about Insert mode\n\t\tcompletion.  See |ins-completion|.\n\t\tThe items are:\n\t\t   mode\t\tCurrent completion mode name string.\n\t\t\t\tSee |complete_info_mode| for the values.\n\t\t   pum_visible\t|TRUE| if popup menu is visible.\n\t\t\t\tSee |pumvisible()|.\n\t\t   items\tList of completion matches.  Each item is a\n\t\t\t\tdictionary containing the entries \"word\",\n\t\t\t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n\t\t\t\tSee |complete-items|.\n\t\t   selected\tSelected item index.  First index is zero.\n\t\t\t\tIndex is -1 if no item is selected (showing\n\t\t\t\ttyped text only, or the last completion after\n\t\t\t\tno item is selected when using the <Up> or\n\t\t\t\t<Down> keys)\n\t\t   inserted\tInserted string. [NOT IMPLEMENT YET]",
   "argsStr": "[{what}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "complete_info_mode",
   "description": "mode values are:\n\t\t   \"\"\t\t     Not in completion mode\n\t\t   \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n\t\t   \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n\t\t   \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n\t\t   \"files\"\t     File names |i_CTRL-X_CTRL-F|\n\t\t   \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n\t\t   \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n\t\t   \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n\t\t   \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n\t\t   \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n\t\t   \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n\t\t   \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n\t\t   \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n\t\t   \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n\t\t   \"eval\"\t     |complete()| completion\n\t\t   \"unknown\"\t     Other internal modes\n\n\t\tIf the optional {what} list argument is supplied, then only\n\t\tthe items listed in {what} are returned.  Unsupported items in\n\t\t{what} are silently ignored.\n\n\t\tTo get the position and size of the popup menu, see\n\t\t|pum_getpos()|. It's also available in |v:event| during the\n\t\t|CompleteChanged| event.\n\n\t\tExamples: >\n\t\t\t\" Get all items\n\t\t\tcall complete_info()\n\t\t\t\" Get only 'mode'\n\t\t\tcall complete_info(['mode'])\n\t\t\t\" Get only 'mode' and 'pum_visible'\n\t\t\tcall complete_info(['mode', 'pum_visible'])\n\n<\t\tCan also be used as a |method|: >\n\t\t\tGetItems()->complete_info()\n<",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "confirm",
   "description": "\t\tConfirm() offers the user a dialog, from which a choice can be\n\t\tmade.  It returns the number of the choice.  For the first\n\t\tchoice this is 1.\n\n\t\t{msg} is displayed in a dialog with {choices} as the\n\t\talternatives.  When {choices} is missing or empty, \"&OK\" is\n\t\tused (and translated).\n\t\t{msg} is a String, use '\\n' to include a newline.  Only on\n\t\tsome systems the string is wrapped when it doesn't fit.\n\n\t\t{choices} is a String, with the individual choices separated\n\t\tby '\\n', e.g. >\n\t\t\tconfirm(\"Save changes?\", \"&Yes\\n&No\\n&Cancel\")\n<\t\tThe letter after the '&' is the shortcut key for that choice.\n\t\tThus you can type 'c' to select \"Cancel\".  The shortcut does\n\t\tnot need to be the first letter: >\n\t\t\tconfirm(\"file has been modified\", \"&Save\\nSave &All\")\n<\t\tFor the console, the first letter of each choice is used as\n\t\tthe default shortcut key.  Case is ignored.\n\n\t\tThe optional {type} String argument gives the type of dialog.\n\t\tIt can be one of these values: \"Error\", \"Question\", \"Info\",\n\t\t\"Warning\" or \"Generic\".  Only the first character is relevant.\n\t\tWhen {type} is omitted, \"Generic\" is used.\n\n\t\tThe optional {type} argument gives the type of dialog.  This\n\t\tis only used for the icon of the Win32 GUI.  It can be one of\n\t\tthese values: \"Error\", \"Question\", \"Info\", \"Warning\" or\n\t\t\"Generic\".  Only the first character is relevant.\n\t\tWhen {type} is omitted, \"Generic\" is used.\n\n\t\tIf the user aborts the dialog by pressing <Esc>, CTRL-C,\n\t\tor another valid interrupt key, confirm() returns 0.\n\n\t\tAn example: >\n   :let choice = confirm(\"What do you want?\", \"&Apples\\n&Oranges\\n&Bananas\", 2)\n   :if choice == 0\n   :\techo \"make up your mind!\"\n   :elseif choice == 3\n   :\techo \"tasteful\"\n   :else\n   :\techo \"I prefer bananas myself.\"\n   :endif\n<\t\tIn a GUI dialog, buttons are used.  The layout of the buttons\n\t\tdepends on the 'v' flag in 'guioptions'.  If it is included,\n\t\tthe buttons are always put vertically.  Otherwise,  confirm()\n\t\ttries to put the buttons in one horizontal line.  If they\n\t\tdon't fit, a vertical layout is used anyway.  For some systems\n\t\tthe horizontal layout is always used.\n\n\t\tCan also be used as a |method|in: >\n\t\t\tBuildMessage()->confirm(\"&Yes\\n&No\")",
   "argsStr": "{msg} [, {choices} [, {default} [, {type}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "copy",
   "description": "Make a copy of {expr}.  For Numbers and Strings this isn't\n\t\tdifferent from using {expr} directly.\n\t\tWhen {expr} is a |List| a shallow copy is created.  This means\n\t\tthat the original |List| can be changed without changing the\n\t\tcopy, and vice versa.  But the items are identical, thus\n\t\tchanging an item changes the contents of both |Lists|.\n\t\tA |Dictionary| is copied in a similar way as a |List|.\n\t\tAlso see |deepcopy()|.\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->copy()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cos",
   "description": "\t\tReturn the cosine of {expr}, measured in radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cos(100)\n<\t\t\t0.862319 >\n\t\t\t:echo cos(-4.01)\n<\t\t\t-0.646043\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->cos()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cosh",
   "description": "\t\tReturn the hyperbolic cosine of {expr} as a |Float| in the range\n\t\t[1, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cosh(0.5)\n<\t\t\t1.127626 >\n\t\t\t:echo cosh(-0.5)\n<\t\t\t-1.127626\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->cosh()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "count",
   "description": "\t\tReturn the number of times an item with value {expr} appears\n\t\tin |String|, |List| or |Dictionary| {comp}.\n\n\t\tIf {start} is given then start with the item with this index.\n\t\t{start} can only be used with a |List|.\n\n\t\tWhen {ic} is given and it's |TRUE| then case is ignored.\n\n\t\tWhen {comp} is a string then the number of not overlapping\n\t\toccurrences of {expr} is returned. Zero is returned when\n\t\t{expr} is an empty string.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->count(val)",
   "argsStr": "{comp}, {expr} [, {ic} [, {start}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cscope_connection",
   "description": "\t\tChecks for the existence of a |cscope| connection.  If no\n\t\tparameters are specified, then the function returns:\n\t\t\t0, if there are no cscope connections;\n\t\t\t1, if there is at least one cscope connection.\n\n\t\tIf parameters are specified, then the value of {num}\n\t\tdetermines how existence of a cscope connection is checked:\n\n\t\t{num}\tDescription of existence check\n\t\t-----\t------------------------------\n\t\t0\tSame as no parameters (e.g., \"cscope_connection()\").\n\t\t1\tIgnore {prepend}, and use partial string matches for\n\t\t\t{dbpath}.\n\t\t2\tIgnore {prepend}, and use exact string matches for\n\t\t\t{dbpath}.\n\t\t3\tUse {prepend}, use partial string matches for both\n\t\t\t{dbpath} and {prepend}.\n\t\t4\tUse {prepend}, use exact string matches for both\n\t\t\t{dbpath} and {prepend}.\n\n\t\tNote: All string comparisons are case sensitive!\n\n\t\tExamples.  Suppose we had the following (from \":cs show\"): >\n\n  # pid    database name\t\t\tprepend path\n  0 27664  cscope.out\t\t\t\t/usr/local\n<\n\t\tInvocation\t\t\t\t\tReturn Val ~\n\t\t----------\t\t\t\t\t---------- >\n\t\tcscope_connection()\t\t\t\t\t1\n\t\tcscope_connection(1, \"out\")\t\t\t\t1\n\t\tcscope_connection(2, \"out\")\t\t\t\t0\n\t\tcscope_connection(3, \"out\")\t\t\t\t0\n\t\tcscope_connection(3, \"out\", \"local\")\t\t\t1\n\t\tcscope_connection(4, \"out\")\t\t\t\t0\n\t\tcscope_connection(4, \"out\", \"local\")\t\t\t0\n\t\tcscope_connection(4, \"cscope.out\", \"/usr/local\")\t1\n<",
   "argsStr": "[{num} , {dbpath} [, {prepend}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxget",
   "description": "\t\tReturns a |Dictionary| representing the |context| at {index}\n\t\tfrom the top of the |context-stack| (see |context-dict|).\n\t\tIf {index} is not given, it is assumed to be 0 (i.e.: top).",
   "argsStr": "[{index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxpop",
   "description": "\t\tPops and restores the |context| at the top of the\n\t\t|context-stack|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxpush",
   "description": "\t\tPushes the current editor state (|context|) on the\n\t\t|context-stack|.\n\t\tIf {types} is given and is a |List| of |String|s, it specifies\n\t\twhich |context-types| to include in the pushed context.\n\t\tOtherwise, all context types are included.",
   "argsStr": "[{types}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxset",
   "description": "\t\tSets the |context| at {index} from the top of the\n\t\t|context-stack| to that represented by {context}.\n\t\t{context} is a Dictionary with context data (|context-dict|).\n\t\tIf {index} is not given, it is assumed to be 0 (i.e.: top).",
   "argsStr": "{context}[, {index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxsize",
   "description": "\t\tReturns the size of the |context-stack|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cursor",
   "description": "cursor({list})\n\t\tPositions the cursor at the column (byte count) {col} in the\n\t\tline {lnum}.  The first column is one.\n\n\t\tWhen there is one argument {list} this is used as a |List|\n\t\twith two, three or four item:\n\t\t\t[{lnum}, {col}]\n\t\t\t[{lnum}, {col}, {off}]\n\t\t\t[{lnum}, {col}, {off}, {curswant}]\n\t\tThis is like the return value of |getpos()| or |getcurpos()|,\n\t\tbut without the first item.\n\n\t\tDoes not change the jumplist.\n\t\tIf {lnum} is greater than the number of lines in the buffer,\n\t\tthe cursor will be positioned at the last line in the buffer.\n\t\tIf {lnum} is zero, the cursor will stay in the current line.\n\t\tIf {col} is greater than the number of bytes in the line,\n\t\tthe cursor will be positioned at the last character in the\n\t\tline.\n\t\tIf {col} is zero, the cursor will stay in the current column.\n\t\tIf {curswant} is given it is used to set the preferred column\n\t\tfor vertical movement.  Otherwise {col} is used.\n\n\t\tWhen 'virtualedit' is used {off} specifies the offset in\n\t\tscreen columns from the start of the character.  E.g., a\n\t\tposition within a <Tab> or after the last character.\n\t\tReturns 0 when the position could be set, -1 otherwise.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetCursorPos()->cursor()",
   "argsStr": "{lnum}, {col} [, {off}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "deepcopy",
   "description": "\t\tMake a copy of {expr}.  For Numbers and Strings this isn't\n\t\tdifferent from using {expr} directly.\n\t\tWhen {expr} is a |List| a full copy is created.  This means\n\t\tthat the original |List| can be changed without changing the\n\t\tcopy, and vice versa.  When an item is a |List|, a copy for it\n\t\tis made, recursively.  Thus changing an item in the copy does\n\t\tnot change the contents of the original |List|.\n\n\t\tWhen {noref} is omitted or zero a contained |List| or\n\t\t|Dictionary| is only copied once.  All references point to\n\t\tthis single copy.  With {noref} set to 1 every occurrence of a\n\t\t|List| or |Dictionary| results in a new copy.  This also means\n\t\tthat a cyclic reference causes deepcopy() to fail.",
   "argsStr": "{expr}[, {noref}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E724",
   "description": "Nesting is possible up to 100 levels.  When there is an item\n\t\tthat refers back to a higher level making a deep copy with\n\t\t{noref} set to 1 will fail.\n\t\tAlso see |copy()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetObject()->deepcopy()",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "delete",
   "description": "\t\tWithout {flags} or with {flags} empty: Deletes the file by the\n\t\tname {fname}.  This also works when {fname} is a symbolic link.\n\t\tA symbolic link itself is deleted, not what it points to.\n\n\t\tWhen {flags} is \"d\": Deletes the directory by the name\n\t\t{fname}.  This fails when directory {fname} is not empty.\n\n\t\tWhen {flags} is \"rf\": Deletes the directory by the name\n\t\t{fname} and everything in it, recursively.  BE CAREFUL!\n\t\tNote: on MS-Windows it is not possible to delete a directory\n\t\tthat is being used.\n\n\t\tThe result is a Number, which is 0/false if the delete\n\t\toperation was successful and -1/true when the deletion failed\n\t\tor partly failed.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetName()->delete()",
   "argsStr": "{fname} [, {flags}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "deletebufline",
   "description": "\t\tDelete lines {first} to {last} (inclusive) from buffer {buf}.\n\t\tIf {last} is omitted then delete line {first} only.\n\t\tOn success 0 is returned, on failure 1 is returned.\n\n\t\tThis function works only for loaded buffers. First call\n\t\t|bufload()| if needed.\n\n\t\tFor the use of {buf}, see |bufname()| above.\n\n\t\t{first} and {last} are used like with |setline()|. Note that\n\t\twhen using |line()| this refers to the current buffer. Use \"$\"\n\t\tto refer to the last line in buffer {buf}.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetBuffer()->deletebufline(1)",
   "argsStr": "{buf}, {first}[, {last}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "dictwatcheradd",
   "description": "\t\tAdds a watcher to a dictionary. A dictionary watcher is\n\t\tidentified by three components:\n\n\t\t- A dictionary({dict});\n\t\t- A key pattern({pattern}).\n\t\t- A function({callback}).\n\n\t\tAfter this is called, every change on {dict} and on keys\n\t\tmatching {pattern} will result in {callback} being invoked.\n\n\t\tFor example, to watch all global variables: >\n\t\t\tsilent! call dictwatcherdel(g:, '*', 'OnDictChanged')\n\t\t\tfunction! OnDictChanged(d,k,z)\n\t\t\t  echomsg string(a:k) string(a:z)\n\t\t\tendfunction\n\t\t\tcall dictwatcheradd(g:, '*', 'OnDictChanged')\n<\n\t\tFor now {pattern} only accepts very simple patterns that can\n\t\tcontain a '*' at the end of the string, in which case it will\n\t\tmatch every key that begins with the substring before the '*'.\n\t\tThat means if '*' is not the last character of {pattern}, only\n\t\tkeys that are exactly equal as {pattern} will be matched.\n\n\t\tThe {callback} receives three arguments:\n\n\t\t- The dictionary being watched.\n\t\t- The key which changed.\n\t\t- A dictionary containing the new and old values for the key.\n\n\t\tThe type of change can be determined by examining the keys\n\t\tpresent on the third argument:\n\n\t\t- If contains both `old` and `new`, the key was updated.\n\t\t- If it contains only `new`, the key was added.\n\t\t- If it contains only `old`, the key was deleted.\n\n\t\tThis function can be used by plugins to implement options with\n\t\tvalidation and parsing logic.",
   "argsStr": "{dict}, {pattern}, {callback}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "dictwatcherdel",
   "description": "\t\tRemoves a watcher added  with |dictwatcheradd()|. All three\n\t\targuments must match the ones passed to |dictwatcheradd()| in\n\t\torder for the watcher to be successfully deleted.",
   "argsStr": "{dict}, {pattern}, {callback}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "did_filetype",
   "description": "Returns |TRUE| when autocommands are being executed and the\n\t\tFileType event has been triggered at least once.  Can be used\n\t\tto avoid triggering the FileType event again in the scripts\n\t\tthat detect the file type. |FileType|\n\t\tReturns |FALSE| when `:setf FALLBACK` was used.\n\t\tWhen editing another file, the counter is reset, thus this\n\t\treally checks if the FileType event has been triggered for the\n\t\tcurrent buffer.  This allows an autocommand that starts\n\t\tediting another buffer to set 'filetype' and load a syntax\n\t\tfile.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "diff_filler",
   "description": "\t\tReturns the number of filler lines above line {lnum}.\n\t\tThese are the lines that were inserted at this point in\n\t\tanother diff'ed window.  These filler lines are shown in the\n\t\tdisplay but don't exist in the buffer.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\tReturns 0 if the current window is not in diff mode.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetLnum()->diff_filler()",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "diff_hlID",
   "description": "\t\tReturns the highlight ID for diff mode at line {lnum} column\n\t\t{col} (byte index).  When the current line does not have a\n\t\tdiff change zero is returned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\t{col} is 1 for the leftmost column, {lnum} is 1 for the first\n\t\tline.\n\t\tThe highlight ID can be used with |synIDattr()| to obtain\n\t\tsyntax information about the highlighting.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetLnum()->diff_hlID(col)",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "empty",
   "description": "\t\tReturn the Number 1 if {expr} is empty, zero otherwise.\n\t\t- A |List| or |Dictionary| is empty when it does not have any\n\t\t  items.\n\t\t- A |String| is empty when its length is zero.\n\t\t- A |Number| and |Float| are empty when their value is zero.\n\t\t- |v:false| and |v:null| are empty, |v:true| is not.\n\t\t- A |Blob| is empty when its length is zero.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->empty()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "environ",
   "description": "\t\tReturn all of environment variables as dictionary. You can\n\t\tcheck if an environment variable exists like this: >\n\t\t\t:echo has_key(environ(), 'HOME')\n<\t\tNote that the variable name may be CamelCase; to ignore case\n\t\tuse this: >\n\t\t\t:echo index(keys(environ()), 'HOME', 0, 1) != -1",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "escape",
   "description": "\t\tEscape the characters in {chars} that occur in {string} with a\n\t\tbackslash.  Example: >\n\t\t\t:echo escape('c:\\program files\\vim', ' \\')\n<\t\tresults in: >\n\t\t\tc:\\\\program\\ files\\\\vim\n<\t\tAlso see |shellescape()| and |fnameescape()|.",
   "argsStr": "{string}, {chars}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "eval",
   "description": "Evaluate {string} and return the result.  Especially useful to\n\t\tturn the result of |string()| back into the original value.\n\t\tThis works for Numbers, Floats, Strings, Blobs and composites\n\t\tof them.  Also works for |Funcref|s that refer to existing\n\t\tfunctions.\n\n\t\tCan also be used as a |method|: >\n\t\t\targv->join()->eval()",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "eventhandler",
   "description": "\t\tReturns 1 when inside an event handler.  That is that Vim got\n\t\tinterrupted while waiting for the user to type a character,\n\t\te.g., when dropping a file on Vim.  This means interactive\n\t\tcommands cannot be used.  Otherwise zero is returned.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "executable",
   "description": "\t\tThis function checks if an executable with the name {expr}\n\t\texists.  {expr} must be the name of the program without any\n\t\targuments.\n\t\texecutable() uses the value of $PATH and/or the normal",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "PATHEXT",
   "description": "\t\tOn MS-Windows the \".exe\", \".bat\", etc. can optionally be\n\t\tincluded.  Then the extensions in $PATHEXT are tried.  Thus if\n\t\t\"foo.exe\" does not exist, \"foo.exe.bat\" can be found.  If\n\t\t$PATHEXT is not set then \".exe;.com;.bat;.cmd\" is used.  A dot\n\t\tby itself can be used in $PATHEXT to try using the name\n\t\twithout an extension.  When 'shell' looks like a Unix shell,\n\t\tthen the name is also tried without adding an extension.\n\t\tOn MS-Windows it only checks if the file exists and is not a\n\t\tdirectory, not if it's really executable.\n\t\tOn Windows an executable in the same directory as Vim is\n\t\talways found (it is added to $PATH at |startup|).\n\t\tThe result is a Number:\n\t\t\t1\texists\n\t\t\t0\tdoes not exist\n\t\t\t-1\tnot implemented on this system\n\t\t|exepath()| can be used to get the full path of an executable.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "execute",
   "description": "\t\tExecute {command} and capture its output.\n\t\tIf {command} is a |String|, returns {command} output.\n\t\tIf {command} is a |List|, returns concatenated outputs.\n\t\tExamples: >\n\t\t\techo execute('echon \"foo\"')\n<\t\t\tfoo >\n\t\t\techo execute(['echon \"foo\"', 'echon \"bar\"'])\n<\t\t\tfoobar\n\n\t\tThe optional {silent} argument can have these values:\n\t\t\t\"\"\t\tno `:silent` used\n\t\t\t\"silent\"\t`:silent` used\n\t\t\t\"silent!\"\t`:silent!` used\n\t\tThe default is \"silent\".  Note that with \"silent!\", unlike\n\t\t`:redir`, error messages are dropped.\n\n\t\tTo get a list of lines use |split()| on the result: >\n\t\t\tsplit(execute('args'), \"\\n\")\n\n<\t\tThis function is not available in the |sandbox|.\n\t\tNote: If nested, an outer execute() will not observe output of\n\t\tthe inner calls.\n\t\tNote: Text attributes (highlights) are not captured.\n\t\tTo execute a command in another window than the current one\n\t\tuse `win_execute()`.",
   "argsStr": "{command} [, {silent}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exepath",
   "description": "\t\tReturns the full path of {expr} if it is an executable and\n\t\tgiven as a (partial or full) path or is found in $PATH.\n\t\tReturns empty string otherwise.\n\t\tIf {expr} starts with \"./\" the |current-directory| is used.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exists",
   "description": "The result is a Number, which is |TRUE| if {expr} is\n\t\tdefined, zero otherwise.\n\n\t\tFor checking for a supported feature use |has()|.\n\t\tFor checking if a file exists use |filereadable()|.\n\n\t\tThe {expr} argument is a string, which contains one of these:\n\t\t\t&option-name\tVim option (only checks if it exists,\n\t\t\t\t\tnot if it really works)\n\t\t\t+option-name\tVim option that works.\n\t\t\t$ENVNAME\tenvironment variable (could also be\n\t\t\t\t\tdone by comparing with an empty\n\t\t\t\t\tstring)\n\t\t\t*funcname\tbuilt-in function (see |functions|)\n\t\t\t\t\tor user defined function (see\n\t\t\t\t\t|user-function|). Also works for a\n\t\t\t\t\tvariable that is a Funcref.\n\t\t\tvarname\t\tinternal variable (see\n\t\t\t\t\t|internal-variables|).  Also works\n\t\t\t\t\tfor |curly-braces-names|, |Dictionary|\n\t\t\t\t\tentries, |List| items, etc.  Beware\n\t\t\t\t\tthat evaluating an index may cause an\n\t\t\t\t\terror message for an invalid\n\t\t\t\t\texpression.  E.g.: >\n\t\t\t\t\t   :let l = [1, 2, 3]\n\t\t\t\t\t   :echo exists(\"l[5]\")\n<\t\t\t\t\t   0 >\n\t\t\t\t\t   :echo exists(\"l[xx]\")\n<\t\t\t\t\t   E121: Undefined variable: xx\n\t\t\t\t\t   0\n\t\t\t:cmdname\tEx command: built-in command, user\n\t\t\t\t\tcommand or command modifier |:command|.\n\t\t\t\t\tReturns:\n\t\t\t\t\t1  for match with start of a command\n\t\t\t\t\t2  full match with a command\n\t\t\t\t\t3  matches several user commands\n\t\t\t\t\tTo check for a supported command\n\t\t\t\t\talways check the return value to be 2.\n\t\t\t:2match\t\tThe |:2match| command.\n\t\t\t:3match\t\tThe |:3match| command.\n\t\t\t#event\t\tautocommand defined for this event\n\t\t\t#event#pattern\tautocommand defined for this event and\n\t\t\t\t\tpattern (the pattern is taken\n\t\t\t\t\tliterally and compared to the\n\t\t\t\t\tautocommand patterns character by\n\t\t\t\t\tcharacter)\n\t\t\t#group\t\tautocommand group exists\n\t\t\t#group#event\tautocommand defined for this group and\n\t\t\t\t\tevent.\n\t\t\t#group#event#pattern\n\t\t\t\t\tautocommand defined for this group,\n\t\t\t\t\tevent and pattern.\n\t\t\t##event\t\tautocommand for this event is\n\t\t\t\t\tsupported.\n\n\t\tExamples: >\n\t\t\texists(\"&mouse\")\n\t\t\texists(\"$HOSTNAME\")\n\t\t\texists(\"*strftime\")\n\t\t\texists(\"*s:MyFunc\")\n\t\t\texists(\"bufcount\")\n\t\t\texists(\":Make\")\n\t\t\texists(\"#CursorHold\")\n\t\t\texists(\"#BufReadPre#*.gz\")\n\t\t\texists(\"#filetypeindent\")\n\t\t\texists(\"#filetypeindent#FileType\")\n\t\t\texists(\"#filetypeindent#FileType#*\")\n\t\t\texists(\"##ColorScheme\")\n<\t\tThere must be no space between the symbol (&/$/*/#) and the\n\t\tname.\n\t\tThere must be no extra characters after the name, although in\n\t\ta few cases this is ignored.  That may become more strict in\n\t\tthe future, thus don't count on it!\n\t\tWorking example: >\n\t\t\texists(\":make\")\n<\t\tNOT working example: >\n\t\t\texists(\":make install\")\n\n<\t\tNote that the argument must be a string, not the name of the\n\t\tvariable itself.  For example: >\n\t\t\texists(bufcount)\n<\t\tThis doesn't check for existence of the \"bufcount\" variable,\n\t\tbut gets the value of \"bufcount\", and checks if that exists.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exp",
   "description": "\t\tReturn the exponential of {expr} as a |Float| in the range\n\t\t[0, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo exp(2)\n<\t\t\t7.389056 >\n\t\t\t:echo exp(-1)\n<\t\t\t0.367879\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->exp()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "debugbreak",
   "description": "\t\tSpecifically used to interrupt a program being debugged.  It\n\t\twill cause process {pid} to get a SIGTRAP.  Behavior for other\n\t\tprocesses is undefined. See |terminal-debugger|.\n\t\t{Sends a SIGINT to a process {pid} other than MS-Windows}\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetPid()->debugbreak()",
   "argsStr": "{pid}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "expand",
   "description": "\t\tExpand wildcards and the following special keywords in \n\t\t{string}.  'wildignorecase' applies.\n\n\t\tIf {list} is given and it is |TRUE|, a List will be returned.\n\t\tOtherwise the result is a String and when there are several\n\t\tmatches, they are separated by <NL> characters.\n\n\t\tIf the expansion fails, the result is an empty string.  A name\n\t\tfor a non-existing file is not included, unless {string} does\n\t\tnot start with '%', '#' or '<', see below.\n\n\t\tWhen {string} starts with '%', '#' or '<', the expansion is\n\t\tdone like for the |cmdline-special| variables with their\n\t\tassociated modifiers.  Here is a short overview:\n\n\t\t\t%\t\tcurrent file name\n\t\t\t#\t\talternate file name\n\t\t\t#n\t\talternate file name n\n\t\t\t<cfile>\t\tfile name under the cursor\n\t\t\t<afile>\t\tautocmd file name\n\t\t\t<abuf>\t\tautocmd buffer number (as a String!)\n\t\t\t<amatch>\tautocmd matched name\n\t\t\t<sfile>\t\tsourced script file or function name\n\t\t\t<slnum>\t\tsourced script line number or function\n\t\t\t\t\tline number\n\t\t\t<sflnum>\tscript file line number, also when in\n\t\t\t\t\ta function\n\t\t\t<SID>\t\t\"<SNR>123_\"  where \"123\" is the\n\t\t\t\t\tcurrent script ID  |<SID>|\n\t\t\t<cword>\t\tword under the cursor\n\t\t\t<cWORD>\t\tWORD under the cursor\n\t\t\t<client>\tthe {clientid} of the last received\n\t\t\t\t\tmessage |server2client()|\n\t\tModifiers:\n\t\t\t:p\t\texpand to full path\n\t\t\t:h\t\thead (last path component removed)\n\t\t\t:t\t\ttail (last path component only)\n\t\t\t:r\t\troot (one extension removed)\n\t\t\t:e\t\textension only\n\n\t\tExample: >\n\t\t\t:let &tags = expand(\"%:p:h\") . \"/tags\"\n<\t\tNote that when expanding a string that starts with '%', '#' or\n\t\t'<', any following text is ignored.  This does NOT work: >\n\t\t\t:let doesntwork = expand(\"%:h.bak\")\n<\t\tUse this: >\n\t\t\t:let doeswork = expand(\"%:h\") . \".bak\"\n<\t\tAlso note that expanding \"<cfile>\" and others only returns the\n\t\treferenced file name without further expansion.  If \"<cfile>\"\n\t\tis \"~/.cshrc\", you need to do another expand() to have the\n\t\t\"~/\" expanded into the path of the home directory: >\n\t\t\t:echo expand(expand(\"<cfile>\"))\n<\n\t\tThere cannot be white space between the variables and the\n\t\tfollowing modifier.  The |fnamemodify()| function can be used\n\t\tto modify normal file names.\n\n\t\tWhen using '%' or '#', and the current or alternate file name\n\t\tis not defined, an empty string is used.  Using \"%:p\" in a\n\t\tbuffer with no name, results in the current directory, with a\n\t\t'/' added.\n\n\t\tWhen {string} does not start with '%', '#' or '<', it is\n\t\texpanded like a file name is expanded on the command line.\n\t\t'suffixes' and 'wildignore' are used, unless the optional\n\t\t{nosuf} argument is given and it is |TRUE|.\n\t\tNames for non-existing files are included.  The \"**\" item can\n\t\tbe used to search in a directory tree.  For example, to find\n\t\tall \"README\" files in the current directory and below: >\n\t\t\t:echo expand(\"**/README\")\n<\n\t\texpand() can also be used to expand variables and environment\n\t\tvariables that are only known in a shell.  But this can be\n\t\tslow, because a shell may be used to do the expansion.  See\n\t\t|expr-env-expand|.\n\t\tThe expanded variable is still handled like a list of file\n\t\tnames.  When an environment variable cannot be expanded, it is\n\t\tleft unchanged.  Thus \":echo expand('$FOOBAR')\" results in\n\t\t\"$FOOBAR\".\n\n\t\tSee |glob()| for finding existing files.  See |system()| for\n\t\tgetting the raw output of an external command.",
   "argsStr": "{string} [, {nosuf} [, {list}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "expandcmd",
   "description": "\t\tExpand special items in {expr} like what is done for an Ex\n\t\tcommand such as `:edit`.  This expands special keywords, like\n\t\twith |expand()|, and environment variables, anywhere in\n\t\t{expr}.  \"~user\" and \"~/path\" are only expanded at the start.\n\t\tReturns the expanded string.  Example: >\n\t\t\t:echo expandcmd('make %<.o')\n<",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "extend",
   "description": "\t\t{expr1} and {expr2} must be both |Lists| or both\n\t\t|Dictionaries|.\n\n\t\tIf they are |Lists|: Append {expr2} to {expr1}.\n\t\tIf {expr3} is given insert the items of {expr2} before the\n\t\titem with index {expr3} in {expr1}.  When {expr3} is zero\n\t\tinsert before the first item.  When {expr3} is equal to\n\t\tlen({expr1}) then {expr2} is appended.\n\t\tExamples: >\n\t\t\t:echo sort(extend(mylist, [7, 5]))\n\t\t\t:call extend(mylist, [2, 3], 1)\n<\t\tWhen {expr1} is the same List as {expr2} then the number of\n\t\titems copied is equal to the original length of the List.\n\t\tE.g., when {expr3} is 1 you get N new copies of the first item\n\t\t(where N is the original length of the List).\n\t\tUse |add()| to concatenate one item to a list.  To concatenate\n\t\ttwo lists into a new list use the + operator: >\n\t\t\t:let newlist = [1, 2, 3] + [4, 5]\n<\n\t\tIf they are |Dictionaries|:\n\t\tAdd all entries from {expr2} to {expr1}.\n\t\tIf a key exists in both {expr1} and {expr2} then {expr3} is\n\t\tused to decide what to do:\n\t\t{expr3} = \"keep\": keep the value of {expr1}\n\t\t{expr3} = \"force\": use the value of {expr2}",
   "argsStr": "{expr1}, {expr2} [, {expr3}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E737",
   "description": "\t\tWhen {expr3} is omitted then \"force\" is assumed.\n\n\t\t{expr1} is changed when {expr2} is not empty.  If necessary\n\t\tmake a copy of {expr1} first.\n\t\t{expr2} remains unchanged.\n\t\tWhen {expr1} is locked and {expr2} is not empty the operation\n\t\tfails.\n\t\tReturns {expr1}.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->extend(otherlist)",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "feedkeys",
   "description": "\t\tCharacters in {string} are queued for processing as if they\n\t\tcome from a mapping or were typed by the user.\n\n\t\tBy default the string is added to the end of the typeahead\n\t\tbuffer, thus if a mapping is still being executed the\n\t\tcharacters come after them.  Use the 'i' flag to insert before\n\t\tother characters, they will be executed next, before any\n\t\tcharacters from a mapping.\n\n\t\tThe function does not wait for processing of keys contained in\n\t\t{string}.\n\n\t\tTo include special keys into {string}, use double-quotes\n\t\tand \"\\...\" notation |expr-quote|. For example,\n\t\tfeedkeys(\"\\<CR>\") simulates pressing of the <Enter> key. But\n\t\tfeedkeys('\\<CR>') pushes 5 characters.\n\t\tThe |<Ignore>| keycode may be used to exit the\n\t\twait-for-character without doing anything.\n\n\t\t{mode} is a String, which can contain these character flags:\n\t\t'm'\tRemap keys. This is default.  If {mode} is absent,\n\t\t\tkeys are remapped.\n\t\t'n'\tDo not remap keys.\n\t\t't'\tHandle keys as if typed; otherwise they are handled as\n\t\t\tif coming from a mapping.  This matters for undo,\n\t\t\topening folds, etc.\n\t\t'i'\tInsert the string instead of appending (see above).\n\t\t'x'\tExecute commands until typeahead is empty.  This is\n\t\t\tsimilar to using \":normal!\".  You can call feedkeys()\n\t\t\tseveral times without 'x' and then one time with 'x'\n\t\t\t(possibly with an empty {string}) to execute all the\n\t\t\ttypeahead.  Note that when Vim ends in Insert mode it\n\t\t\twill behave as if <Esc> is typed, to avoid getting\n\t\t\tstuck, waiting for a character to be typed before the\n\t\t\tscript continues.\n\t\t\tNote that if you manage to call feedkeys() while\n\t\t\texecuting commands, thus calling it recursively, then\n\t\t\tall typehead will be consumed by the last call.\n\t\t'!'\tWhen used with 'x' will not end Insert mode. Can be\n\t\t\tused in a test when a timer is set to exit Insert mode\n\t\t\ta little later.  Useful for testing CursorHoldI.\n\n\t\tReturn value is always 0.",
   "argsStr": "{string} [, {mode}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filereadable",
   "description": "\t\tThe result is a Number, which is |TRUE| when a file with the\n\t\tname {file} exists, and can be read.  If {file} doesn't exist,\n\t\tor is a directory, the result is |FALSE|.  {file} is any\n\t\texpression, which is used as a String.\n\t\tIf you don't care about the file being readable you can use\n\t\t|glob()|.\n\t\t{file} is used as-is, you may want to expand wildcards first: >\n\t\t\techo filereadable('~/.vimrc')\n\t\t\t0\n\t\t\techo filereadable(expand('~/.vimrc'))\n\t\t\t1",
   "argsStr": "{file}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filewritable",
   "description": "\t\tThe result is a Number, which is 1 when a file with the\n\t\tname {file} exists, and can be written.  If {file} doesn't\n\t\texist, or is not writable, the result is 0.  If {file} is a\n\t\tdirectory, and we can write to it, the result is 2.",
   "argsStr": "{file}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filter",
   "description": "\t\t{expr1} must be a |List|, |Blob|, or a |Dictionary|.\n\t\tFor each item in {expr1} evaluate {expr2} and when the result\n\t\tis zero remove the item from the |List| or |Dictionary|. For a\n\t\t|Blob| each byte is removed.\n\n\t\t{expr2} must be a |string| or |Funcref|.\n\n\t\tIf {expr2} is a |string|, inside {expr2} |v:val| has the value\n\t\tof the current item.  For a |Dictionary| |v:key| has the key\n\t\tof the current item and for a |List| |v:key| has the index of\n\t\tthe current item.  For a |Blob| |v:key| has the index of the\n\t\tcurrent byte.\n\n\t\tExamples: >\n\t\t\tcall filter(mylist, 'v:val !~ \"OLD\"')\n<\t\tRemoves the items where \"OLD\" appears. >\n\t\t\tcall filter(mydict, 'v:key >= 8')\n<\t\tRemoves the items with a key below 8. >\n\t\t\tcall filter(var, 0)\n<\t\tRemoves all the items, thus clears the |List| or |Dictionary|.\n\n\t\tNote that {expr2} is the result of expression and is then\n\t\tused as an expression again.  Often it is good to use a\n\t\t|literal-string| to avoid having to double backslashes.\n\n\t\tIf {expr2} is a |Funcref| it must take two arguments:\n\t\t\t1. the key or the index of the current item.\n\t\t\t2. the value of the current item.\n\t\tThe function must return |TRUE| if the item should be kept.\n\t\tExample that keeps the odd items of a list: >\n\t\t\tfunc Odd(idx, val)\n\t\t\t  return a:idx % 2 == 1\n\t\t\tendfunc\n\t\t\tcall filter(mylist, function('Odd'))\n<\t\tIt is shorter when using a |lambda|: >\n\t\t\tcall filter(myList, {idx, val -> idx * val <= 42})\n<\t\tIf you do not use \"val\" you can leave it out: >\n\t\t\tcall filter(myList, {idx -> idx % 2 == 1})\n<\n\t\tThe operation is done in-place.  If you want a |List| or\n\t\t|Dictionary| to remain unmodified make a copy first: >\n\t\t\t:let l = filter(copy(mylist), 'v:val =~ \"KEEP\"')\n\n<\t\tReturns {expr1}, the |List|, |Blob| or |Dictionary| that was\n\t\tfiltered.  When an error is encountered while evaluating\n\t\t{expr2} no further items in {expr1} are processed.  When\n\t\t{expr2} is a Funcref errors inside a function are ignored,\n\t\tunless it was defined with the \"abort\" flag.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->filter(expr2)",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "finddir",
   "description": "\t\tFind directory {name} in {path}.  Supports both downwards and\n\t\tupwards recursive directory searches.  See |file-searching|\n\t\tfor the syntax of {path}.\n\n\t\tReturns the path of the first found match.  When the found\n\t\tdirectory is below the current directory a relative path is\n\t\treturned.  Otherwise a full path is returned.\n\t\tIf {path} is omitted or empty then 'path' is used.\n\n\t\tIf the optional {count} is given, find {count}'s occurrence of\n\t\t{name} in {path} instead of the first one.\n\t\tWhen {count} is negative return all the matches in a |List|.\n\n\t\tThis is quite similar to the ex-command `:find`.",
   "argsStr": "{name} [, {path} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "findfile",
   "description": "\t\tJust like |finddir()|, but find a file instead of a directory.\n\t\tUses 'suffixesadd'.\n\t\tExample: >\n\t\t\t:echo findfile(\"tags.vim\", \".;\")\n<\t\tSearches from the directory of the current file upwards until\n\t\tit finds the file \"tags.vim\".",
   "argsStr": "{name} [, {path} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "flatten",
   "description": "\t\tFlatten {list} up to {maxdepth} levels.  Without {maxdepth}\n\t\tthe result is a |List| without nesting, as if {maxdepth} is\n\t\ta very large number.\n\t\tThe {list} is changed in place, make a copy first if you do\n\t\tnot want that.",
   "argsStr": "{list} [, {maxdepth}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E900",
   "description": "{maxdepth} means how deep in nested lists changes are made.\n\t\t{list} is not modified when {maxdepth} is 0.\n\t\t{maxdepth} must be positive number.\n\n\t\tIf there is an error the number zero is returned.\n\n\t\tExample: >\n\t\t\t:echo flatten([1, [2, [3, 4]], 5])\n<\t\t\t[1, 2, 3, 4, 5] >\n\t\t\t:echo flatten([1, [2, [3, 4]], 5], 1)\n<\t\t\t[1, 2, [3, 4], 5]",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "float2nr",
   "description": "\t\tConvert {expr} to a Number by omitting the part after the\n\t\tdecimal point.\n\t\t{expr} must evaluate to a |Float| or a Number.\n\t\tWhen the value of {expr} is out of range for a |Number| the\n\t\tresult is truncated to 0x7fffffff or -0x7fffffff (or when\n\t\t64-bit Number support is enabled, 0x7fffffffffffffff or\n\t\t-0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n\t\t64-bit Number support is enabled, -0x8000000000000000).\n\t\tExamples: >\n\t\t\techo float2nr(3.95)\n<\t\t\t3  >\n\t\t\techo float2nr(-23.45)\n<\t\t\t-23  >\n\t\t\techo float2nr(1.0e100)\n<\t\t\t2147483647  (or 9223372036854775807) >\n\t\t\techo float2nr(-1.0e150)\n<\t\t\t-2147483647 (or -9223372036854775807) >\n\t\t\techo float2nr(1.0e-100)\n<\t\t\t0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->float2nr()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "floor",
   "description": "\t\tReturn the largest integral value less than or equal to\n\t\t{expr} as a |Float| (round down).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo floor(1.856)\n<\t\t\t1.0  >\n\t\t\techo floor(-5.456)\n<\t\t\t-6.0  >\n\t\t\techo floor(4.0)\n<\t\t\t4.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->floor()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fmod",
   "description": "\t\tReturn the remainder of {expr1} / {expr2}, even if the\n\t\tdivision is not representable.  Returns {expr1} - i * {expr2}\n\t\tfor some integer i such that if {expr2} is non-zero, the\n\t\tresult has the same sign as {expr1} and magnitude less than\n\t\tthe magnitude of {expr2}.  If {expr2} is zero, the value\n\t\treturned is zero.  The value returned is a |Float|.\n\t\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo fmod(12.33, 1.22)\n<\t\t\t0.13 >\n\t\t\t:echo fmod(-12.33, 1.22)\n<\t\t\t-0.13\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->fmod(1.22)",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fnameescape",
   "description": "\t\tEscape {string} for use as file name command argument.  All\n\t\tcharacters that have a special meaning, such as '%' and '|'\n\t\tare escaped with a backslash.\n\t\tFor most systems the characters escaped are\n\t\t\" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\n\t\tappears in a filename, it depends on the value of 'isfname'.\n\t\tA leading '+' and '>' is also escaped (special after |:edit|\n\t\tand |:write|).  And a \"-\" by itself (special after |:cd|).\n\t\tExample: >\n\t\t\t:let fname = '+some str%nge|name'\n\t\t\t:exe \"edit \" . fnameescape(fname)\n<\t\tresults in executing: >\n\t\t\tedit \\+some\\ str\\%nge\\|name",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fnamemodify",
   "description": "\t\tModify file name {fname} according to {mods}.  {mods} is a\n\t\tstring of characters like it is used for file names on the\n\t\tcommand line.  See |filename-modifiers|.\n\t\tExample: >\n\t\t\t:echo fnamemodify(\"main.c\", \":p:h\")\n<\t\tresults in: >\n\t\t\t/home/mool/vim/vim/src\n<\t\tIf {mods} is empty then {fname} is returned.\n\t\tNote: Environment variables don't work in {fname}, use\n\t\t|expand()| first then.",
   "argsStr": "{fname}, {mods}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldclosed",
   "description": "\t\tThe result is a Number.  If the line {lnum} is in a closed\n\t\tfold, the result is the number of the first line in that fold.\n\t\tIf the line {lnum} is not in a closed fold, -1 is returned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldclosedend",
   "description": "\t\tThe result is a Number.  If the line {lnum} is in a closed\n\t\tfold, the result is the number of the last line in that fold.\n\t\tIf the line {lnum} is not in a closed fold, -1 is returned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldlevel",
   "description": "\t\tThe result is a Number, which is the foldlevel of line {lnum}\n\t\tin the current buffer.  For nested folds the deepest level is\n\t\treturned.  If there is no fold at line {lnum}, zero is\n\t\treturned.  It doesn't matter if the folds are open or closed.\n\t\tWhen used while updating folds (from 'foldexpr') -1 is\n\t\treturned for lines where folds are still to be updated and the\n\t\tfoldlevel is unknown.  As a special case the level of the\n\t\tprevious line is usually available.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldtext",
   "description": "Returns a String, to be displayed for a closed fold.  This is\n\t\tthe default function used for the 'foldtext' option and should\n\t\tonly be called from evaluating 'foldtext'.  It uses the\n\t\t|v:foldstart|, |v:foldend| and |v:folddashes| variables.\n\t\tThe returned string looks like this: >\n\t\t\t+-- 45 lines: abcdef\n<\t\tThe number of leading dashes depends on the foldlevel.  The\n\t\t\"45\" is the number of lines in the fold.  \"abcdef\" is the text\n\t\tin the first non-blank line of the fold.  Leading white space,\n\t\t\"//\" or \"/*\" and the text from the 'foldmarker' and\n\t\t'commentstring' options is removed.\n\t\tWhen used to draw the actual foldtext, the rest of the line\n\t\twill be filled with the fold char from the 'fillchars'\n\t\tsetting.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldtextresult",
   "description": "\t\tReturns the text that is displayed for the closed fold at line\n\t\t{lnum}.  Evaluates 'foldtext' in the appropriate context.\n\t\tWhen there is no closed fold at {lnum} an empty string is\n\t\treturned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\tUseful when exporting folded text, e.g., to HTML.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foreground",
   "description": "Move the Vim window to the foreground.  Useful when sent from\n\t\ta client to a Vim server. |remote_send()|\n\t\tOn Win32 systems this might not work, the OS does not always\n\t\tallow a window to bring itself to the foreground.  Use\n\t\t|remote_foreground()| instead.\n\t\t{only in the Win32 GUI and console version}",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "funcref",
   "description": "\t\tJust like |function()|, but the returned Funcref will lookup\n\t\tthe function by reference, not by name.  This matters when the\n\t\tfunction {name} is redefined later.\n\n\t\tUnlike |function()|, {name} must be an existing user function.\n\t\tAlso for autoloaded functions. {name} cannot be a builtin\n\t\tfunction.",
   "argsStr": "{name} [, {arglist}] [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "function",
   "description": "\t\tReturn a |Funcref| variable that refers to function {name}.\n\t\t{name} can be a user defined function or an internal function.\n\n\t\t{name} can also be a Funcref or a partial. When it is a\n\t\tpartial the dict stored in it will be used and the {dict}\n\t\targument is not allowed. E.g.: >\n\t\t\tlet FuncWithArg = function(dict.Func, [arg])\n\t\t\tlet Broken = function(dict.Func, [arg], dict)\n<\n\t\tWhen using the Funcref the function will be found by {name},\n\t\talso when it was redefined later. Use |funcref()| to keep the\n\t\tsame function.\n\n\t\tWhen {arglist} or {dict} is present this creates a partial.\n\t\tThat means the argument list and/or the dictionary is stored in\n\t\tthe Funcref and will be used when the Funcref is called.\n\n\t\tThe arguments are passed to the function in front of other\n\t\targuments, but after any argument from |method|.  Example: >\n\t\t\tfunc Callback(arg1, arg2, name)\n\t\t\t...\n\t\t\tlet Partial = function('Callback', ['one', 'two'])\n\t\t\t...\n\t\t\tcall Partial('name')\n<\t\tInvokes the function as with: >\n\t\t\tcall Callback('one', 'two', 'name')\n\n<\t\tThe Dictionary is only useful when calling a \"dict\" function.\n\t\tIn that case the {dict} is passed in as \"self\". Example: >\n\t\t\tfunction Callback() dict\n\t\t\t   echo \"called for \" . self.name\n\t\t\tendfunction\n\t\t\t...\n\t\t\tlet context = {\"name\": \"example\"}\n\t\t\tlet Func = function('Callback', context)\n\t\t\t...\n\t\t\tcall Func()\t\" will echo: called for example\n\n<\t\tThe argument list and the Dictionary can be combined: >\n\t\t\tfunction Callback(arg1, count) dict\n\t\t\t...\n\t\t\tlet context = {\"name\": \"example\"}\n\t\t\tlet Func = function('Callback', ['one'], context)\n\t\t\t...\n\t\t\tcall Func(500)\n<\t\tInvokes the function as with: >\n\t\t\tcall context.Callback('one', 500)",
   "argsStr": "{name} [, {arglist}] [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "garbagecollect",
   "description": "\t\tCleanup unused |Lists| and |Dictionaries| that have circular\n\t\treferences.\n\n\t\tThere is hardly ever a need to invoke this function, as it is\n\t\tautomatically done when Vim runs out of memory or is waiting\n\t\tfor the user to press a key after 'updatetime'.  Items without\n\t\tcircular references are always freed when they become unused.\n\t\tThis is useful if you have deleted a very big |List| and/or\n\t\t|Dictionary| with circular references in a script that runs\n\t\tfor a long time.\n\n\t\tWhen the optional {atexit} argument is one, garbage\n\t\tcollection will also be done when exiting Vim, if it wasn't\n\t\tdone before.  This is useful when checking for memory leaks.\n\n\t\tThe garbage collection is not done immediately but only when\n\t\tit's safe to perform.  This is when waiting for the user to\n\t\ttype a character.",
   "argsStr": "[{atexit}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "get",
   "description": "\t\tGet item {idx} from |List| {list}.  When this item is not\n\t\tavailable return {default}.  Return zero when {default} is\n\t\tomitted.\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->get(idx)\nget({blob}, {idx} [, {default}])\n\t\tGet byte {idx} from |Blob| {blob}.  When this byte is not\n\t\tavailable return {default}.  Return -1 when {default} is\n\t\tomitted.\nget({dict}, {key} [, {default}])\n\t\tGet item with key {key} from |Dictionary| {dict}.  When this\n\t\titem is not available return {default}.  Return zero when\n\t\t{default} is omitted.  Useful example: >\n\t\t\tlet val = get(g:, 'var_name', 'default')\n<\t\tThis gets the value of g:var_name if it exists, and uses\n\t\t'default' when it does not exist.\nget({func}, {what})\n\t\tGet item {what} from Funcref {func}.  Possible values for\n\t\t{what} are:\n\t\t\t\"name\"\tThe function name\n\t\t\t\"func\"\tThe function\n\t\t\t\"dict\"\tThe dictionary\n\t\t\t\"args\"\tThe list with arguments",
   "argsStr": "{list}, {idx} [, {default}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufinfo",
   "description": "getbufinfo([{dict}])\n\t\tGet information about buffers as a List of Dictionaries.\n\n\t\tWithout an argument information about all the buffers is\n\t\treturned.\n\n\t\tWhen the argument is a |Dictionary| only the buffers matching\n\t\tthe specified criteria are returned.  The following keys can\n\t\tbe specified in {dict}:\n\t\t\tbuflisted\tinclude only listed buffers.\n\t\t\tbufloaded\tinclude only loaded buffers.\n\t\t\tbufmodified\tinclude only modified buffers.\n\n\t\tOtherwise, {buf} specifies a particular buffer to return\n\t\tinformation for.  For the use of {buf}, see |bufname()|\n\t\tabove.  If the buffer is found the returned List has one item.\n\t\tOtherwise the result is an empty list.\n\n\t\tEach returned List item is a dictionary with the following\n\t\tentries:\n\t\t\tbufnr\t\tBuffer number.\n\t\t\tchanged\t\tTRUE if the buffer is modified.\n\t\t\tchangedtick\tNumber of changes made to the buffer.\n\t\t\thidden\t\tTRUE if the buffer is hidden.\n\t\t\tlastused\tTimestamp in seconds, like\n\t\t\t\t\t|localtime()|, when the buffer was\n\t\t\t\t\tlast used.\n\t\t\tlisted\t\tTRUE if the buffer is listed.\n\t\t\tlnum\t\tLine number used for the buffer when\n\t\t\t\t\topened in the current window.\n\t\t\t\t\tOnly valid if the buffer has been\n\t\t\t\t\tdisplayed in the window in the past.\n\t\t\t\t\tIf you want the line number of the\n\t\t\t\t\tlast known cursor position in a given\n\t\t\t\t\twindow, use |line()|: >\n\t\t\t\t\t\t:echo line('.', {winid})\n<\n\t\t\tlinecount\tNumber of lines in the buffer (only\n\t\t\t\t\tvalid when loaded)\n\t\t\tloaded\t\tTRUE if the buffer is loaded.\n\t\t\tname\t\tFull path to the file in the buffer.\n\t\t\tsigns\t\tList of signs placed in the buffer.\n\t\t\t\t\tEach list item is a dictionary with\n\t\t\t\t\tthe following fields:\n\t\t\t\t\t    id\t  sign identifier\n\t\t\t\t\t    lnum  line number\n\t\t\t\t\t    name  sign name\n\t\t\tvariables\tA reference to the dictionary with\n\t\t\t\t\tbuffer-local variables.\n\t\t\twindows\t\tList of |window-ID|s that display this\n\t\t\t\t\tbuffer\n\n\t\tExamples: >\n\t\t\tfor buf in getbufinfo()\n\t\t\t    echo buf.name\n\t\t\tendfor\n\t\t\tfor buf in getbufinfo({'buflisted':1})\n\t\t\t    if buf.changed\n\t\t\t\t....\n\t\t\t    endif\n\t\t\tendfor\n<\n\t\tTo get buffer-local options use: >\n\t\t\tgetbufvar({bufnr}, '&option_name')\n\n<",
   "argsStr": "[{buf}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufline",
   "description": "\t\tReturn a |List| with the lines starting from {lnum} to {end}\n\t\t(inclusive) in the buffer {buf}.  If {end} is omitted, a\n\t\t|List| with only the line {lnum} is returned.\n\n\t\tFor the use of {buf}, see |bufname()| above.\n\n\t\tFor {lnum} and {end} \"$\" can be used for the last line of the\n\t\tbuffer.  Otherwise a number must be used.\n\n\t\tWhen {lnum} is smaller than 1 or bigger than the number of\n\t\tlines in the buffer, an empty |List| is returned.\n\n\t\tWhen {end} is greater than the number of lines in the buffer,\n\t\tit is treated as {end} is set to the number of lines in the\n\t\tbuffer.  When {end} is before {lnum} an empty |List| is\n\t\treturned.\n\n\t\tThis function works only for loaded buffers.  For unloaded and\n\t\tnon-existing buffers, an empty |List| is returned.\n\n\t\tExample: >\n\t\t\t:let lines = getbufline(bufnr(\"myfile\"), 1, \"$\")",
   "argsStr": "{buf}, {lnum} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufvar",
   "description": "\t\tThe result is the value of option or local buffer variable\n\t\t{varname} in buffer {buf}.  Note that the name without \"b:\"\n\t\tmust be used.\n\t\tThe {varname} argument is a string.\n\t\tWhen {varname} is empty returns a |Dictionary| with all the\n\t\tbuffer-local variables.\n\t\tWhen {varname} is equal to \"&\" returns a |Dictionary| with all\n\t\tthe buffer-local options.\n\t\tOtherwise, when {varname} starts with \"&\" returns the value of\n\t\ta buffer-local option.\n\t\tThis also works for a global or buffer-local option, but it\n\t\tdoesn't work for a global variable, window-local variable or\n\t\twindow-local option.\n\t\tFor the use of {buf}, see |bufname()| above.\n\t\tWhen the buffer or variable doesn't exist {def} or an empty\n\t\tstring is returned, there is no error message.\n\t\tExamples: >\n\t\t\t:let bufmodified = getbufvar(1, \"&mod\")\n\t\t\t:echo \"todo myvar = \" . getbufvar(\"todo\", \"myvar\")\n<",
   "argsStr": "{buf}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getchangelist",
   "description": "\t\tReturns the |changelist| for the buffer {buf}. For the use\n\t\tof {buf}, see |bufname()| above. If buffer {buf} doesn't\n\t\texist, an empty list is returned.\n\n\t\tThe returned list contains two entries: a list with the change\n\t\tlocations and the current position in the list.  Each\n\t\tentry in the change list is a dictionary with the following\n\t\tentries:\n\t\t\tcol\t\tcolumn number\n\t\t\tcoladd\t\tcolumn offset for 'virtualedit'\n\t\t\tlnum\t\tline number\n\t\tIf buffer {buf} is the current buffer, then the current\n\t\tposition refers to the position in the list. For other\n\t\tbuffers, it is set to the length of the list.",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getchar",
   "description": "\t\tGet a single character from the user or input stream.\n\t\tIf [expr] is omitted, wait until a character is available.\n\t\tIf [expr] is 0, only get a character when one is available.\n\t\t\tReturn zero otherwise.\n\t\tIf [expr] is 1, only check if a character is available, it is\n\t\t\tnot consumed.  Return zero if no character available.\n\t\tIf you prefer always getting a string use |getcharstr()|.\n\n\t\tWithout [expr] and when [expr] is 0 a whole character or\n\t\tspecial key is returned.  If it is a single character, the\n\t\tresult is a number.  Use nr2char() to convert it to a String.\n\t\tOtherwise a String is returned with the encoded character.\n\t\tFor a special key it's a String with a sequence of bytes\n\t\tstarting with 0x80 (decimal: 128).  This is the same value as\n\t\tthe String \"\\<Key>\", e.g., \"\\<Left>\".  The returned value is\n\t\talso a String when a modifier (shift, control, alt) was used\n\t\tthat is not included in the character.\n\n\t\tWhen [expr] is 0 and Esc is typed, there will be a short delay\n\t\twhile Vim waits to see if this is the start of an escape\n\t\tsequence.\n\n\t\tWhen [expr] is 1 only the first byte is returned.  For a\n\t\tone-byte character it is the character itself as a number.\n\t\tUse nr2char() to convert it to a String.\n\n\t\tUse getcharmod() to obtain any additional modifiers.\n\n\t\tWhen the user clicks a mouse button, the mouse event will be\n\t\treturned.  The position can then be found in |v:mouse_col|,\n\t\t|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.\n\t\tMouse move events will be ignored.\n\t\tThis example positions the mouse as it would normally happen: >\n\t\t\tlet c = getchar()\n\t\t\tif c == \"\\<LeftMouse>\" && v:mouse_win > 0\n\t\t\t  exe v:mouse_win . \"wincmd w\"\n\t\t\t  exe v:mouse_lnum\n\t\t\t  exe \"normal \" . v:mouse_col . \"|\"\n\t\t\tendif\n<\n\t\tThere is no prompt, you will somehow have to make clear to the\n\t\tuser that a character has to be typed.  The screen is not\n\t\tredrawn, e.g. when resizing the window.\n\n\t\tThere is no mapping for the character.\n\t\tKey codes are replaced, thus when the user presses the <Del>\n\t\tkey you get the code for the <Del> key, not the raw character\n\t\tsequence.  Examples: >\n\t\t\tgetchar() == \"\\<Del>\"\n\t\t\tgetchar() == \"\\<S-Left>\"\n<\t\tThis example redefines \"f\" to ignore case: >\n\t\t\t:nmap f :call FindChar()<CR>\n\t\t\t:function FindChar()\n\t\t\t:  let c = nr2char(getchar())\n\t\t\t:  while col('.') < col('$') - 1\n\t\t\t:    normal l\n\t\t\t:    if getline('.')[col('.') - 1] ==? c\n\t\t\t:      break\n\t\t\t:    endif\n\t\t\t:  endwhile\n\t\t\t:endfunction\n<",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcharmod",
   "description": "\t\tThe result is a Number which is the state of the modifiers for\n\t\tthe last obtained character with getchar() or in another way.\n\t\tThese values are added together:\n\t\t\t2\tshift\n\t\t\t4\tcontrol\n\t\t\t8\talt (meta)\n\t\t\t16\tmeta (when it's different from ALT)\n\t\t\t32\tmouse double click\n\t\t\t64\tmouse triple click\n\t\t\t96\tmouse quadruple click (== 32 + 64)\n\t\t\t128\tcommand (Macintosh only)\n\t\tOnly the modifiers that have not been included in the\n\t\tcharacter itself are obtained.  Thus Shift-a results in \"A\"\n\t\twithout a modifier.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcharsearch",
   "description": "\t\tReturn the current character search information as a {dict}\n\t\twith the following entries:\n\n\t\t    char\tcharacter previously used for a character\n\t\t\t\tsearch (|t|, |f|, |T|, or |F|); empty string\n\t\t\t\tif no character search has been performed\n\t\t    forward\tdirection of character search; 1 for forward,\n\t\t\t\t0 for backward\n\t\t    until\ttype of character search; 1 for a |t| or |T|\n\t\t\t\tcharacter search, 0 for an |f| or |F|\n\t\t\t\tcharacter search\n\n\t\tThis can be useful to always have |;| and |,| search\n\t\tforward/backward regardless of the direction of the previous\n\t\tcharacter search: >\n\t\t\t:nnoremap <expr> ; getcharsearch().forward ? ';' : ','\n\t\t\t:nnoremap <expr> , getcharsearch().forward ? ',' : ';'\n<\t\tAlso see |setcharsearch()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcharstr",
   "description": "\t\tGet a single character from the user or input stream as a\n\t\tstring.\n\t\tIf [expr] is omitted, wait until a character is available.\n\t\tIf [expr] is 0 or false, only get a character when one is\n\t\t\tavailable.  Return an empty string otherwise.\n\t\tIf [expr] is 1 or true, only check if a character is\n\t\t\tavailable, it is not consumed.  Return an empty string\n\t\t\tif no character is available.\n\t\tOtherwise this works like |getchar()|, except that a number\n\t\tresult is converted to a string.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdline",
   "description": "\t\tReturn the current command-line.  Only works when the command\n\t\tline is being edited, thus requires use of |c_CTRL-\\_e| or\n\t\t|c_CTRL-R_=|.\n\t\tExample: >\n\t\t\t:cmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n<\t\tAlso see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.\n\t\tReturns an empty string when entering a password or using\n\t\t|inputsecret()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdpos",
   "description": "\t\tReturn the position of the cursor in the command line as a\n\t\tbyte count.  The first column is 1.\n\t\tOnly works when editing the command line, thus requires use of\n\t\t|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n\t\tReturns 0 otherwise.\n\t\tAlso see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdtype",
   "description": "\t\tReturn the current command-line type. Possible return values\n\t\tare:\n\t\t    :\tnormal Ex command\n\t\t    >\tdebug mode command |debug-mode|\n\t\t    /\tforward search command\n\t\t    ?\tbackward search command\n\t\t    @\t|input()| command\n\t\t    -\t|:insert| or |:append| command\n\t\t    =\t|i_CTRL-R_=|\n\t\tOnly works when editing the command line, thus requires use of\n\t\t|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n\t\tReturns an empty string otherwise.\n\t\tAlso see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdwintype",
   "description": "\t\tReturn the current |command-line-window| type. Possible return\n\t\tvalues are the same as |getcmdtype()|. Returns an empty string\n\t\twhen not in the command-line window.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcompletion",
   "description": "\t\tReturn a list of command-line completion matches. The String\n\t\t{type} argument specifies what for.  The following completion\n\t\ttypes are supported:\n\n\t\targlist\t\tfile names in argument list\n\t\taugroup\t\tautocmd groups\n\t\tbuffer\t\tbuffer names\n\t\tbehave\t\t:behave suboptions\n\t\tcmdline\t\t|cmdline-completion| result\n\t\tcolor\t\tcolor schemes\n\t\tcommand\t\tEx command (and arguments)\n\t\tcompiler\tcompilers\n\t\tcscope\t\t|:cscope| suboptions\n\t\tdiff_buffer     |:diffget| and |:diffput| completion\n\t\tdir\t\tdirectory names\n\t\tenvironment\tenvironment variable names\n\t\tevent\t\tautocommand events\n\t\texpression\tVim expression\n\t\tfile\t\tfile and directory names\n\t\tfile_in_path\tfile and directory names in |'path'|\n\t\tfiletype\tfiletype names |'filetype'|\n\t\tfunction\tfunction name\n\t\thelp\t\thelp subjects\n\t\thighlight\thighlight groups\n\t\thistory\t\t:history suboptions\n\t\tlocale\t\tlocale names (as output of locale -a)\n\t\tmapclear\tbuffer argument\n\t\tmapping\t\tmapping name\n\t\tmenu\t\tmenus\n\t\tmessages\t|:messages| suboptions\n\t\toption\t\toptions\n\t\tpackadd\t\toptional package |pack-add| names\n\t\tshellcmd\tShell command\n\t\tsign\t\t|:sign| suboptions\n\t\tsyntax\t\tsyntax file names |'syntax'|\n\t\tsyntime\t\t|:syntime| suboptions\n\t\ttag\t\ttags\n\t\ttag_listfiles\ttags, file names\n\t\tuser\t\tuser names\n\t\tvar\t\tuser variables\n\n\t\tIf {pat} is an empty string, then all the matches are\n\t\treturned.  Otherwise only items matching {pat} are returned.\n\t\tSee |wildcards| for the use of special characters in {pat}.\n\n\t\tIf the optional {filtered} flag is set to 1, then 'wildignore'\n\t\tis applied to filter the results.  Otherwise all the matches\n\t\tare returned. The 'wildignorecase' option always applies.\n\n\t\tIf {type} is \"cmdline\", then the |cmdline-completion| result is\n\t\treturned.  For example, to complete the possible values after\n\t\ta \":call\" command: >\n\t\t\techo getcompletion('call ', 'cmdline')\n<\n\t\tIf there are no matches, an empty list is returned.  An\n\t\tinvalid value for {type} produces an error.",
   "argsStr": "{pat}, {type} [, {filtered}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcurpos",
   "description": "Get the position of the cursor.  This is like getpos('.'), but\n\t\tincludes an extra \"curswant\" in the list:\n\t\t    [0, lnum, col, off, curswant] ~\n\t\tThe \"curswant\" number is the preferred column when moving the\n\t\tcursor vertically.  Also see |getpos()|.\n\t\tThe first \"bufnum\" item is always zero.\n\n \t\tThis can be used to save and restore the cursor position: >\n \t\t\tlet save_cursor = getcurpos()\n \t\t\tMoveTheCursorAround\n \t\t\tcall setpos('.', save_cursor)\n<\t\tNote that this only works within the window.  See\n\t\t|winrestview()| for restoring more state.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcwd",
   "description": "\t\tWith no arguments, returns the name of the effective\n\t\t|current-directory|. With {winnr} or {tabnr} the working\n\t\tdirectory of that scope is returned.\n\t\tTabs and windows are identified by their respective numbers,\n\t\t0 means current tab or window. Missing argument implies 0.\n\t\tThus the following are equivalent: >\n\t\t\tgetcwd()\n\t\t\tgetcwd(0)\n\t\t\tgetcwd(0, 0)\n<\t\tIf {winnr} is -1 it is ignored, only the tab is resolved.\n\t\t{winnr} can be the window number or the |window-ID|.",
   "argsStr": "[{winnr}[, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getenv",
   "description": "\t\tReturn the value of environment variable {name}.  The {name}\n\t\targument is a string, without a leading '$'.  Example: >\n\t\t\tmyHome = getenv('HOME')\n\n<\t\tWhen the variable does not exist |v:null| is returned.  That\n\t\tis different from a variable set to an empty string.\n\t\tSee also |expr-env|.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfontname",
   "description": "\t\tWithout an argument returns the name of the normal font being\n\t\tused.  Like what is used for the Normal highlight group\n\t\t|hl-Normal|.\n\t\tWith an argument a check is done whether String {name} is a\n\t\tvalid font name.  If not then an empty string is returned.\n\t\tOtherwise the actual font name is returned, or {name} if the\n\t\tGUI does not support obtaining the real name.\n\t\tOnly works when the GUI is running, thus not in your vimrc or\n\t\tgvimrc file.  Use the |GUIEnter| autocommand to use this\n\t\tfunction just after the GUI has started.",
   "argsStr": "[{name}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfperm",
   "description": "\t\tThe result is a String, which is the read, write, and execute\n\t\tpermissions of the given file {fname}.\n\t\tIf {fname} does not exist or its directory cannot be read, an\n\t\tempty string is returned.\n\t\tThe result is of the form \"rwxrwxrwx\", where each group of\n\t\t\"rwx\" flags represent, in turn, the permissions of the owner\n\t\tof the file, the group the file belongs to, and other users.\n\t\tIf a user does not have a given permission the flag for this\n\t\tis replaced with the string \"-\".  Examples: >\n\t\t\t:echo getfperm(\"/etc/passwd\")\n\t\t\t:echo getfperm(expand(\"~/.config/nvim/init.vim\"))\n<\t\tThis will hopefully (from a security point of view) display\n\t\tthe string \"rw-r--r--\" or even \"rw-------\".\n\n\t\tFor setting permissions use |setfperm()|.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfsize",
   "description": "\t\tThe result is a Number, which is the size in bytes of the\n\t\tgiven file {fname}.\n\t\tIf {fname} is a directory, 0 is returned.\n\t\tIf the file {fname} can't be found, -1 is returned.\n\t\tIf the size of {fname} is too big to fit in a Number then -2\n\t\tis returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getftime",
   "description": "\t\tThe result is a Number, which is the last modification time of\n\t\tthe given file {fname}.  The value is measured as seconds\n\t\tsince 1st Jan 1970, and may be passed to strftime().  See also\n\t\t|localtime()| and |strftime()|.\n\t\tIf the file {fname} can't be found -1 is returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getftype",
   "description": "\t\tThe result is a String, which is a description of the kind of\n\t\tfile of the given file {fname}.\n\t\tIf {fname} does not exist an empty string is returned.\n\t\tHere is a table over different kinds of files and their\n\t\tresults:\n\t\t\tNormal file\t\t\"file\"\n\t\t\tDirectory\t\t\"dir\"\n\t\t\tSymbolic link\t\t\"link\"\n\t\t\tBlock device\t\t\"bdev\"\n\t\t\tCharacter device\t\"cdev\"\n\t\t\tSocket\t\t\t\"socket\"\n\t\t\tFIFO\t\t\t\"fifo\"\n\t\t\tAll other\t\t\"other\"\n\t\tExample: >\n\t\t\tgetftype(\"/home\")\n<\t\tNote that a type such as \"link\" will only be returned on\n\t\tsystems that support it.  On some systems only \"dir\" and\n\t\t\"file\" are returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getjumplist",
   "description": "\t\tReturns the |jumplist| for the specified window.\n\n\t\tWithout arguments use the current window.\n\t\tWith {winnr} only use this window in the current tab page.\n\t\t{winnr} can also be a |window-ID|.\n\t\tWith {winnr} and {tabnr} use the window in the specified tab\n\t\tpage.\n\n\t\tThe returned list contains two entries: a list with the jump\n\t\tlocations and the last used jump position number in the list.\n\t\tEach entry in the jump location list is a dictionary with\n\t\tthe following entries:\n\t\t\tbufnr\t\tbuffer number\n\t\t\tcol\t\tcolumn number\n\t\t\tcoladd\t\tcolumn offset for 'virtualedit'\n\t\t\tfilename\tfilename if available\n\t\t\tlnum\t\tline number",
   "argsStr": "[{winnr} [, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getline",
   "description": "\t\tWithout {end} the result is a String, which is line {lnum}\n\t\tfrom the current buffer.  Example: >\n\t\t\tgetline(1)\n<\t\tWhen {lnum} is a String that doesn't start with a\n\t\tdigit, |line()| is called to translate the String into a Number.\n\t\tTo get the line under the cursor: >\n\t\t\tgetline(\".\")\n<\t\tWhen {lnum} is smaller than 1 or bigger than the number of\n\t\tlines in the buffer, an empty string is returned.\n\n\t\tWhen {end} is given the result is a |List| where each item is\n\t\ta line from the current buffer in the range {lnum} to {end},\n\t\tincluding line {end}.\n\t\t{end} is used in the same way as {lnum}.\n\t\tNon-existing lines are silently omitted.\n\t\tWhen {end} is before {lnum} an empty |List| is returned.\n\t\tExample: >\n\t\t\t:let start = line('.')\n\t\t\t:let end = search(\"^$\") - 1\n\t\t\t:let lines = getline(start, end)\n\n<\t\tTo get lines from another buffer see |getbufline()|",
   "argsStr": "{lnum} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getloclist",
   "description": "\t\tReturns a |List| with all the entries in the location list for\n\t\twindow {nr}.  {nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero the current window is used.\n\n\t\tFor a location list window, the displayed location list is\n\t\treturned.  For an invalid window number {nr}, an empty list is\n\t\treturned. Otherwise, same as |getqflist()|.\n\n\t\tIf the optional {what} dictionary argument is supplied, then\n\t\treturns the items listed in {what} as a dictionary. Refer to\n\t\t|getqflist()| for the supported items in {what}.\n\t\tIf {what} contains 'filewinid', then returns the id of the\n\t\twindow used to display files from the location list. This\n\t\tfield is applicable only when called from a location list\n\t\twindow. See |location-list-file-window| for more details.\n\n\t\tReturns a |Dictionary| with default values if there is no\n\t\tlocation list for the window {nr}.\n\t\tReturns an empty Dictionary if window {nr} does not exist.\n\n\t\tExamples (See also |getqflist-examples|): >\n\t\t\t:echo getloclist(3, {'all': 0})\n\t\t\t:echo getloclist(5, {'filewinid': 0})",
   "argsStr": "{nr},[, {what}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getmarklist",
   "description": "\t\tWithout the {buf} argument returns a |List| with information\n\t\tabout all the global marks. |mark|\n\n\t\tIf the optional {buf} argument is specified, returns the\n\t\tlocal marks defined in buffer {buf}.  For the use of {buf},\n\t\tsee |bufname()|.\n\n\t\tEach item in the returned List is a |Dict| with the following:\n\t\t    mark   name of the mark prefixed by \"'\"\n\t\t    pos\t   a |List| with the position of the mark:\n\t\t\t\t[bufnum, lnum, col, off]\n\t\t\t   Refer to |getpos()| for more information.\n\t\t    file   file name\n\n\t\tRefer to |getpos()| for getting information about a specific\n\t\tmark.",
   "argsStr": "[{buf}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getmatches",
   "description": "\t\tReturns a |List| with all matches previously defined for the\n\t\tcurrent window by |matchadd()| and the |:match| commands.\n\t\t|getmatches()| is useful in combination with |setmatches()|,\n\t\tas |setmatches()| can restore a list of matches saved by\n\t\t|getmatches()|.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.\n\t\tExample: >\n\t\t\t:echo getmatches()\n<\t\t\t[{'group': 'MyGroup1', 'pattern': 'TODO',\n\t\t\t'priority': 10, 'id': 1}, {'group': 'MyGroup2',\n\t\t\t'pattern': 'FIXME', 'priority': 10, 'id': 2}] >\n\t\t\t:let m = getmatches()\n\t\t\t:call clearmatches()\n\t\t\t:echo getmatches()\n<\t\t\t[] >\n\t\t\t:call setmatches(m)\n\t\t\t:echo getmatches()\n<\t\t\t[{'group': 'MyGroup1', 'pattern': 'TODO',\n\t\t\t'priority': 10, 'id': 1}, {'group': 'MyGroup2',\n\t\t\t'pattern': 'FIXME', 'priority': 10, 'id': 2}] >\n\t\t\t:unlet m\n<",
   "argsStr": "[{win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getpid",
   "description": "Return a Number which is the process ID of the Vim process.\n\t\tThis is a unique number, until Vim exits.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getpos",
   "description": "Get the position for String {expr}.  For possible values of\n\t\t{expr} see |line()|.  For getting the cursor position see\n\t\t|getcurpos()|.\n\t\tThe result is a |List| with four numbers:\n\t\t    [bufnum, lnum, col, off]\n\t\t\"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\n\t\tis the buffer number of the mark.\n\t\t\"lnum\" and \"col\" are the position in the buffer.  The first\n\t\tcolumn is 1.\n\t\tThe \"off\" number is zero, unless 'virtualedit' is used.  Then\n\t\tit is the offset in screen columns from the start of the\n\t\tcharacter.  E.g., a position within a <Tab> or after the last\n\t\tcharacter.\n\t\tNote that for '< and '> Visual mode matters: when it is \"V\"\n\t\t(visual line mode) the column of '< is zero and the column of\n\t\t'> is a large number.\n\t\tThe column number in the returned List is the byte position\n\t\twithin the line.\n\t\tThe column number can be very large, e.g. 2147483647, in which\n\t\tcase it means \"after the end of the line\".\n\t\tThis can be used to save and restore the position of a mark: >\n\t\t\tlet save_a_mark = getpos(\"'a\")\n\t\t\t...\n\t\t\tcall setpos(\"'a\", save_a_mark)\n<\t\tAlso see |getcurpos()| and |setpos()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getqflist",
   "description": "\t\tReturns a |List| with all the current quickfix errors.  Each\n\t\tlist item is a dictionary with these entries:\n\t\t\tbufnr\tnumber of buffer that has the file name, use\n\t\t\t\tbufname() to get the name\n\t\t\tmodule\tmodule name\n\t\t\tlnum\tline number in the buffer (first line is 1)\n\t\t\tend_lnum\n\t\t\t\tend of line number if the item is multiline\n\t\t\tcol\tcolumn number (first column is 1)\n\t\t\tend_col\tend of column number if the item has range\n\t\t\tvcol\t|TRUE|: \"col\" is visual column\n\t\t\t\t|FALSE|: \"col\" is byte index\n\t\t\tnr\terror number\n\t\t\tpattern\tsearch pattern used to locate the error\n\t\t\ttext\tdescription of the error\n\t\t\ttype\ttype of the error, 'E', '1', etc.\n\t\t\tvalid\t|TRUE|: recognized error message\n\n\t\tWhen there is no error list or it's empty, an empty list is\n\t\treturned. Quickfix list entries with a non-existing buffer\n\t\tnumber are returned with \"bufnr\" set to zero (Note: some\n\t\tfunctions accept buffer number zero for the alternate buffer,\n\t\tyou may need to explicitly check for zero).\n\n\t\tUseful application: Find pattern matches in multiple files and\n\t\tdo something with them: >\n\t\t\t:vimgrep /theword/jg *.c\n\t\t\t:for d in getqflist()\n\t\t\t:   echo bufname(d.bufnr) ':' d.lnum '=' d.text\n\t\t\t:endfor\n<\n\t\tIf the optional {what} dictionary argument is supplied, then\n\t\treturns only the items listed in {what} as a dictionary. The\n\t\tfollowing string items are supported in {what}:\n\t\t\tchangedtick\tget the total number of changes made\n\t\t\t\t\tto the list |quickfix-changedtick|\n\t\t\tcontext\tget the |quickfix-context|\n\t\t\tefm\terrorformat to use when parsing \"lines\". If\n\t\t\t\tnot present, then the 'errorformat' option\n\t\t\t\tvalue is used.\n\t\t\tid\tget information for the quickfix list with\n\t\t\t\t|quickfix-ID|; zero means the id for the\n\t\t\t\tcurrent list or the list specified by \"nr\"\n\t\t\tidx\tget information for the quickfix entry at this\n\t\t\t\tindex in the list specified by 'id' or 'nr'.\n\t\t\t\tIf set to zero, then uses the current entry.\n\t\t\t\tSee |quickfix-index|\n\t\t\titems\tquickfix list entries\n\t\t\tlines\tparse a list of lines using 'efm' and return\n\t\t\t\tthe resulting entries.  Only a |List| type is\n\t\t\t\taccepted.  The current quickfix list is not\n\t\t\t\tmodified. See |quickfix-parse|.\n\t\t\tnr\tget information for this quickfix list; zero\n\t\t\t\tmeans the current quickfix list and \"$\" means\n\t\t\t\tthe last quickfix list\n\t\t\tsize\tnumber of entries in the quickfix list\n\t\t\ttitle\tget the list title |quickfix-title|\n\t\t\twinid\tget the quickfix |window-ID|\n\t\t\tall\tall of the above quickfix properties\n\t\tNon-string items in {what} are ignored. To get the value of a\n\t\tparticular item, set it to zero.\n\t\tIf \"nr\" is not present then the current quickfix list is used.\n\t\tIf both \"nr\" and a non-zero \"id\" are specified, then the list\n\t\tspecified by \"id\" is used.\n\t\tTo get the number of lists in the quickfix stack, set \"nr\" to\n\t\t\"$\" in {what}. The \"nr\" value in the returned dictionary\n\t\tcontains the quickfix stack size.\n\t\tWhen \"lines\" is specified, all the other items except \"efm\"\n\t\tare ignored.  The returned dictionary contains the entry\n\t\t\"items\" with the list of entries.\n\n\t\tThe returned dictionary contains the following entries:\n\t\t\tchangedtick\ttotal number of changes made to the\n\t\t\t\t\tlist |quickfix-changedtick|\n\t\t\tcontext\tquickfix list context. See |quickfix-context|\n\t\t\t\tIf not present, set to \"\".\n\t\t\tid\tquickfix list ID |quickfix-ID|. If not\n\t\t\t\tpresent, set to 0.\n\t\t\tidx\tindex of the quickfix entry in the list. If not\n\t\t\t\tpresent, set to 0.\n\t\t\titems\tquickfix list entries. If not present, set to\n\t\t\t\tan empty list.\n\t\t\tnr\tquickfix list number. If not present, set to 0\n\t\t\tsize\tnumber of entries in the quickfix list. If not\n\t\t\t\tpresent, set to 0.\n\t\t\ttitle\tquickfix list title text. If not present, set\n\t\t\t\tto \"\".\n\t\t\twinid\tquickfix |window-ID|. If not present, set to 0\n\n\t\tExamples (See also |getqflist-examples|): >\n\t\t\t:echo getqflist({'all': 1})\n\t\t\t:echo getqflist({'nr': 2, 'title': 1})\n\t\t\t:echo getqflist({'lines' : [\"F1:10:L10\"]})\n<",
   "argsStr": "[{what}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getreg",
   "description": "\t\tThe result is a String, which is the contents of register\n\t\t{regname}.  Example: >\n\t\t\t:let cliptext = getreg('*')\n<\t\tWhen {regname} was not set the result is an empty string.\n\t\tThe {regname} argument is a string.\n\n\t\tgetreg('=') returns the last evaluated value of the expression\n\t\tregister.  (For use in maps.)\n\t\tgetreg('=', 1) returns the expression itself, so that it can\n\t\tbe restored with |setreg()|.  For other registers the extra\n\t\targument is ignored, thus you can always give it.\n\n\t\tIf {list} is present and |TRUE|, the result type is changed\n\t\tto |List|. Each list item is one text line. Use it if you care\n\t\tabout zero bytes possibly present inside register: without\n\t\tthird argument both NLs and zero bytes are represented as NLs\n\t\t(see |NL-used-for-Nul|).\n\t\tWhen the register was not set an empty list is returned.\n\n\t\tIf {regname} is not specified, |v:register| is used.",
   "argsStr": "[{regname} [, 1 [, {list}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getregtype",
   "description": "\t\tThe result is a String, which is type of register {regname}.\n\t\tThe value will be one of:\n\t\t    \"v\"\t\t\tfor |charwise| text\n\t\t    \"V\"\t\t\tfor |linewise| text\n\t\t    \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n\t\t    \"\"\t\t\tfor an empty or unknown register\n\t\t<CTRL-V> is one character with value 0x16.\n\t\tThe {regname} argument is a string.  If {regname} is not\n\t\tspecified, |v:register| is used.",
   "argsStr": "[{regname}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabinfo",
   "description": "\t\tIf {tabnr} is not specified, then information about all the\n\t\ttab pages is returned as a |List|. Each List item is a\n\t\t|Dictionary|.  Otherwise, {tabnr} specifies the tab page\n\t\tnumber and information about that one is returned.  If the tab\n\t\tpage does not exist an empty List is returned.\n\n\t\tEach List item is a |Dictionary| with the following entries:\n\t\t\ttabnr\t\ttab page number.\n\t\t\tvariables\ta reference to the dictionary with\n\t\t\t\t\ttabpage-local variables\n\t\t\twindows\t\tList of |window-ID|s in the tab page.",
   "argsStr": "[{tabnr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabvar",
   "description": "\t\tGet the value of a tab-local variable {varname} in tab page\n\t\t{tabnr}. |t:var|\n\t\tTabs are numbered starting with one.\n\t\tThe {varname} argument is a string.  When {varname} is empty a\n\t\tdictionary with all tab-local variables is returned.\n\t\tNote that the name without \"t:\" must be used.\n\t\tWhen the tab or variable doesn't exist {def} or an empty\n\t\tstring is returned, there is no error message.",
   "argsStr": "{tabnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabwinvar",
   "description": "\t\tGet the value of window-local variable {varname} in window\n\t\t{winnr} in tab page {tabnr}.\n\t\tThe {varname} argument is a string.  When {varname} is empty a\n \t\tdictionary with all window-local variables is returned.\n\t\tWhen {varname} is equal to \"&\" get the values of all\n\t\twindow-local options in a |Dictionary|.\n\t\tOtherwise, when {varname} starts with \"&\" get the value of a\n\t\twindow-local option.\n\t\tNote that {varname} must be the name without \"w:\".\n\t\tTabs are numbered starting with one.  For the current tabpage\n\t\tuse |getwinvar()|.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tWhen {winnr} is zero the current window is used.\n\t\tThis also works for a global option, buffer-local option and\n\t\twindow-local option, but it doesn't work for a global variable\n\t\tor buffer-local variable.\n\t\tWhen the tab, window or variable doesn't exist {def} or an\n\t\tempty string is returned, there is no error message.\n\t\tExamples: >\n\t\t\t:let list_is_on = gettabwinvar(1, 2, '&list')\n\t\t\t:echo \"myvar = \" . gettabwinvar(3, 1, 'myvar')\n<\n\t\tTo obtain all window-local variables use: >\n\t\t\tgettabwinvar({tabnr}, {winnr}, '&')",
   "argsStr": "{tabnr}, {winnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettagstack",
   "description": "\t\tThe result is a Dict, which is the tag stack of window {winnr}.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tWhen {winnr} is not specified, the current window is used.\n\t\tWhen window {winnr} doesn't exist, an empty Dict is returned.\n\n\t\tThe returned dictionary contains the following entries:\n\t\t\tcuridx\t\tCurrent index in the stack. When at\n\t\t\t\t\ttop of the stack, set to (length + 1).\n\t\t\t\t\tIndex of bottom of the stack is 1.\n\t\t\titems\t\tList of items in the stack. Each item\n\t\t\t\t\tis a dictionary containing the\n\t\t\t\t\tentries described below.\n\t\t\tlength\t\tNumber of entries in the stack.\n\n\t\tEach item in the stack is a dictionary with the following\n\t\tentries:\n\t\t\tbufnr\t\tbuffer number of the current jump\n\t\t\tfrom\t\tcursor position before the tag jump.\n\t\t\t\t\tSee |getpos()| for the format of the\n\t\t\t\t\treturned list.\n\t\t\tmatchnr\t\tcurrent matching tag number. Used when\n\t\t\t\t\tmultiple matching tags are found for a\n\t\t\t\t\tname.\n\t\t\ttagname\t\tname of the tag\n\n\t\tSee |tagstack| for more information about the tag stack.",
   "argsStr": "[{winnr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwininfo",
   "description": "\t\tReturns information about windows as a |List| with Dictionaries.\n\n\t\tIf {winid} is given Information about the window with that ID\n\t\tis returned, as a |List| with one item.  If the window does not\n\t\texist the result is an empty list.\n\n\t\tWithout {winid} information about all the windows in all the\n\t\ttab pages is returned.\n\n\t\tEach List item is a |Dictionary| with the following entries:\n\t\t\tbotline\t\tlast complete displayed buffer line\n\t\t\tbufnr\t\tnumber of buffer in the window\n\t\t\theight\t\twindow height (excluding winbar)\n\t\t\tloclist\t\t1 if showing a location list\n\t\t\tquickfix\t1 if quickfix or location list window\n\t\t\tterminal\t1 if a terminal window\n\t\t\ttabnr\t\ttab page number\n\t\t\ttopline\t\tfirst displayed buffer line\n\t\t\tvariables\ta reference to the dictionary with\n\t\t\t\t\twindow-local variables\n\t\t\twidth\t\twindow width\n\t\t\twinbar\t\t1 if the window has a toolbar, 0\n\t\t\t\t\totherwise\n\t\t\twincol\t\tleftmost screen column of the window;\n\t\t\t\t\t\"col\" from |win_screenpos()|\n\t\t\twinid\t\t|window-ID|\n\t\t\twinnr\t\twindow number\n\t\t\twinrow\t\ttopmost screen line of the window;\n\t\t\t\t\t\"row\" from |win_screenpos()|",
   "argsStr": "[{winid}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinpos",
   "description": "\t\tThe result is a |List| with two numbers, the result of\n\t\t|getwinposx()| and |getwinposy()| combined:\n\t\t\t[x-pos, y-pos]\n\t\t{timeout} can be used to specify how long to wait in msec for\n\t\ta response from the terminal.  When omitted 100 msec is used.\n\n\t\tUse a longer time for a remote terminal.\n\t\tWhen using a value less than 10 and no response is received\n\t\twithin that time, a previously reported position is returned,\n\t\tif available.  This can be used to poll for the position and\n\t\tdo some work in the meantime: >\n\t\t\twhile 1\n\t\t\t  let res = getwinpos(1)\n\t\t\t  if res[0] >= 0\n\t\t\t    break\n\t\t\t  endif\n\t\t\t  \" Do some work here\n\t\t\tendwhile\n<",
   "argsStr": "[{timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinposx",
   "description": "The result is a Number, which is the X coordinate in pixels of\n\t\tthe left hand side of the GUI Vim window.  The result will be\n\t\t-1 if the information is not available.\n\t\tThe value can be used with `:winpos`.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinposy",
   "description": "The result is a Number, which is the Y coordinate in pixels of\n\t\tthe top of the GUI Vim window.  The result will be -1 if the\n\t\tinformation is not available.\n\t\tThe value can be used with `:winpos`.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinvar",
   "description": "\t\tLike |gettabwinvar()| for the current tabpage.\n\t\tExamples: >\n\t\t\t:let list_is_on = getwinvar(2, '&list')\n\t\t\t:echo \"myvar = \" . getwinvar(1, 'myvar')\n<",
   "argsStr": "{winnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "glob",
   "description": "\t\tExpand the file wildcards in {expr}.  See |wildcards| for the\n\t\tuse of special characters.\n\n\t\tUnless the optional {nosuf} argument is given and is |TRUE|,\n\t\tthe 'suffixes' and 'wildignore' options apply: Names matching\n\t\tone of the patterns in 'wildignore' will be skipped and\n\t\t'suffixes' affect the ordering of matches.\n\t\t'wildignorecase' always applies.\n\n\t\tWhen {list} is present and it is |TRUE| the result is a |List|\n\t\twith all matching files. The advantage of using a List is,\n\t\tyou also get filenames containing newlines correctly.\n\t\tOtherwise the result is a String and when there are several\n\t\tmatches, they are separated by <NL> characters.\n\n\t\tIf the expansion fails, the result is an empty String or List.\n\n\t\tYou can also use |readdir()| if you need to do complicated\n\t\tthings, such as limiting the number of matches.\n\n\t\tA name for a non-existing file is not included.  A symbolic\n\t\tlink is only included if it points to an existing file.\n\t\tHowever, when the {alllinks} argument is present and it is\n\t\t|TRUE| then all symbolic links are included.\n\n\t\tFor most systems backticks can be used to get files names from\n\t\tany external command.  Example: >\n\t\t\t:let tagfiles = glob(\"`find . -name tags -print`\")\n\t\t\t:let &tags = substitute(tagfiles, \"\\n\", \",\", \"g\")\n<\t\tThe result of the program inside the backticks should be one\n\t\titem per line.  Spaces inside an item are allowed.\n\n\t\tSee |expand()| for expanding special Vim variables.  See\n\t\t|system()| for getting the raw output of an external command.",
   "argsStr": "{expr} [, {nosuf} [, {list} [, {alllinks}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "glob2regpat",
   "description": "\t\tConvert a file pattern, as used by glob(), into a search\n\t\tpattern.  The result can be used to match with a string that\n\t\tis a file name.  E.g. >\n\t\t\tif filename =~ glob2regpat('Make*.mak')\n<\t\tThis is equivalent to: >\n\t\t\tif filename =~ '^Make.*\\.mak$'\n<\t\tWhen {string} is an empty string the result is \"^$\", match an\n\t\tempty string.\n\t\tNote that the result depends on the system.  On MS-Windows\n\t\ta backslash usually means a path separator.",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "globpath",
   "description": "\t\tPerform glob() for String {expr} on all directories in {path}\n\t\tand concatenate the results.  Example: >\n\t\t\t:echo globpath(&rtp, \"syntax/c.vim\")\n<\n\t\t{path} is a comma-separated list of directory names.  Each\n\t\tdirectory name is prepended to {expr} and expanded like with\n\t\t|glob()|.  A path separator is inserted when needed.\n\t\tTo add a comma inside a directory name escape it with a\n\t\tbackslash.  Note that on MS-Windows a directory may have a\n\t\ttrailing backslash, remove it if you put a comma after it.\n\t\tIf the expansion fails for one of the directories, there is no\n\t\terror message.\n\n\t\tUnless the optional {nosuf} argument is given and is |TRUE|,\n\t\tthe 'suffixes' and 'wildignore' options apply: Names matching\n\t\tone of the patterns in 'wildignore' will be skipped and\n\t\t'suffixes' affect the ordering of matches.\n\n\t\tWhen {list} is present and it is |TRUE| the result is a |List|\n\t\twith all matching files. The advantage of using a List is, you\n\t\talso get filenames containing newlines correctly. Otherwise\n\t\tthe result is a String and when there are several matches,\n\t\tthey are separated by <NL> characters.  Example: >\n\t\t\t:echo globpath(&rtp, \"syntax/c.vim\", 0, 1)\n<\n\t\t{allinks} is used as with |glob()|.\n\n\t\tThe \"**\" item can be used to search in a directory tree.\n\t\tFor example, to find all \"README.txt\" files in the directories\n\t\tin 'runtimepath' and below: >\n\t\t\t:echo globpath(&rtp, \"**/README.txt\")\n<\t\tUpwards search and limiting the depth of \"**\" is not\n\t\tsupported, thus using 'path' will not always work properly.",
   "argsStr": "{path}, {expr} [, {nosuf} [, {list} [, {allinks}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "has",
   "description": "Returns 1 if {feature} is supported, 0 otherwise.  The\n\t\t{feature} argument is a feature name like \"nvim-0.2.1\" or\n\t\t\"win32\", see below.  See also |exists()|.\n\n\t\tIf the code has a syntax error, then Nvim may skip the rest\n\t\tof the line and miss |:endif|. >\n\tif has('feature') | let x = this->breaks->without->the->feature | endif\n<\n\t\tPut |:if| and |:endif| on separate lines to avoid the\n\t\tsyntax error. >\n\tif has('feature')\n\t  let x = this->breaks->without->the->feature\n\tendif\n<\n\t\tVim's compile-time feature-names (prefixed with \"+\") are not\n\t\trecognized because Nvim is always compiled with all possible\n\t\tfeatures. |feature-compile|\n\n\t\tFeature names can be:\n\t\t1.  Nvim version. For example the \"nvim-0.2.1\" feature means\n\t\t    that Nvim is version 0.2.1 or later: >\n\t\t\t:if has(\"nvim-0.2.1\")\n\n<\t\t2.  Runtime condition or other pseudo-feature. For example the\n\t\t    \"win32\" feature checks if the current system is Windows: >\n\t\t\t:if has(\"win32\")",
   "argsStr": "{feature}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "feature-list",
   "description": "\t\t    List of supported pseudo-feature names:\n\t\t        acl\t\t|ACL| support\n\t\t\tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n\t\t        iconv\t\tCan use |iconv()| for conversion.\n\t\t        +shellslash\tCan use backslashes in filenames (Windows)\n\t\t\tclipboard\t|clipboard| provider is available.\n\t\t\tfname_case\tCase in file names matters (for Darwin and MS-Windows\n\t\t\t\t\tthis is not present).\n\t\t\tmac\t\tMacOS system.\n\t\t\tnvim\t\tThis is Nvim.\n\t\t\tpython2\t\tLegacy Vim |python2| interface. |has-python|\n\t\t\tpython3\t\tLegacy Vim |python3| interface. |has-python|\n\t\t\tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n\t\t\tttyin\t\tinput is a terminal (tty)\n\t\t\tttyout\t\toutput is a terminal (tty)\n\t\t\tunix\t\tUnix system.\n\t\t\t*vim_starting*\tTrue during |startup|.\n\t\t\twin32\t\tWindows system (32 or 64 bit).\n\t\t\twin64\t\tWindows system (64 bit).\n\t\t\twsl\t\tWSL (Windows Subsystem for Linux) system",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "has-patch",
   "description": "3.  Vim patch. For example the \"patch123\" feature means that\n\t\t    Vim patch 123 at the current |v:version| was included: >\n\t\t\t:if v:version > 602 || v:version == 602 && has(\"patch148\")\n\n<\t\t4.  Vim version. For example the \"patch-7.4.237\" feature means\n\t\t    that Nvim is Vim-compatible to version 7.4.237 or later. >\n\t\t\t:if has(\"patch-7.4.237\")",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "has_key",
   "description": "\t\tThe result is a Number, which is TRUE if |Dictionary| {dict}\n\t\thas an entry with key {key}.  FALSE otherwise. The {key}\n\t\targument is a string.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmydict->has_key(key)",
   "argsStr": "{dict}, {key}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "haslocaldir",
   "description": "\t\tThe result is a Number, which is 1 when the tabpage or window\n\t\thas set a local path via |:tcd| or |:lcd|, otherwise 0.\n\n\t\tTabs and windows are identified by their respective numbers,\n\t\t0 means current tab or window. Missing argument implies 0.\n\t\tThus the following are equivalent: >\n\t\t\thaslocaldir()\n\t\t\thaslocaldir(0)\n\t\t\thaslocaldir(0, 0)\n<\t\tWith {winnr} use that window in the current tabpage.\n\t\tWith {winnr} and {tabnr} use the window in that tabpage.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tIf {winnr} is -1 it is ignored, only the tab is resolved.",
   "argsStr": "[{winnr}[, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hasmapto",
   "description": "\t\tThe result is a Number, which is TRUE if there is a mapping\n\t\tthat contains {what} in somewhere in the rhs (what it is\n\t\tmapped to) and this mapping exists in one of the modes\n\t\tindicated by {mode}.\n\t\tThe arguments {what} and {mode} are strings.\n\t\tWhen {abbr} is there and it is |TRUE| use abbreviations\n\t\tinstead of mappings.  Don't forget to specify Insert and/or\n\t\tCommand-line mode.\n\t\tBoth the global mappings and the mappings local to the current\n\t\tbuffer are checked for a match.\n\t\tIf no matching mapping is found FALSE is returned.\n\t\tThe following characters are recognized in {mode}:\n\t\t\tn\tNormal mode\n\t\t\tv\tVisual mode\n\t\t\to\tOperator-pending mode\n\t\t\ti\tInsert mode\n\t\t\tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n\t\t\tc\tCommand-line mode\n\t\tWhen {mode} is omitted, \"nvo\" is used.\n\n\t\tThis function is useful to check if a mapping already exists\n\t\tto a function in a Vim script.  Example: >\n\t\t\t:if !hasmapto('\\ABCdoit')\n\t\t\t:   map <Leader>d \\ABCdoit\n\t\t\t:endif\n<\t\tThis installs the mapping to \"\\ABCdoit\" only if there isn't\n\t\talready a mapping to \"\\ABCdoit\".",
   "argsStr": "{what} [, {mode} [, {abbr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histadd",
   "description": "\t\tAdd the String {item} to the history {history} which can be",
   "argsStr": "{history}, {item}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "hist-names",
   "description": "\t\t\t\"cmd\"\t or \":\"\t  command line history\n\t\t\t\"search\" or \"/\"   search pattern history\n\t\t\t\"expr\"\t or \"=\"   typed expression history\n\t\t\t\"input\"  or \"@\"\t  input line history\n\t\t\t\"debug\"  or \">\"   debug command history\n\t\t\tempty\t\t  the current or last used history\n\t\tThe {history} string does not need to be the whole name, one\n\t\tcharacter is sufficient.\n\t\tIf {item} does already exist in the history, it will be\n\t\tshifted to become the newest entry.\n\t\tThe result is a Number: TRUE if the operation was successful,\n\t\totherwise FALSE is returned.\n\n\t\tExample: >\n\t\t\t:call histadd(\"input\", strftime(\"%Y %b %d\"))\n\t\t\t:let date=input(\"Enter date: \")\n<\t\tThis function is not available in the |sandbox|.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "histdel",
   "description": "\t\tClear {history}, i.e. delete all its entries.  See |hist-names|\n\t\tfor the possible values of {history}.\n\n\t\tIf the parameter {item} evaluates to a String, it is used as a\n\t\tregular expression.  All entries matching that expression will\n\t\tbe removed from the history (if there are any).\n\t\tUpper/lowercase must match, unless \"\\c\" is used |/\\c|.\n\t\tIf {item} evaluates to a Number, it will be interpreted as\n\t\tan index, see |:history-indexing|.  The respective entry will\n\t\tbe removed if it exists.\n\n\t\tThe result is TRUE for a successful operation, otherwise FALSE\n\t\tis returned.\n\n\t\tExamples:\n\t\tClear expression register history: >\n\t\t\t:call histdel(\"expr\")\n<\n\t\tRemove all entries starting with \"*\" from the search history: >\n\t\t\t:call histdel(\"/\", '^\\*')\n<\n\t\tThe following three are equivalent: >\n\t\t\t:call histdel(\"search\", histnr(\"search\"))\n\t\t\t:call histdel(\"search\", -1)\n\t\t\t:call histdel(\"search\", '^'.histget(\"search\", -1).'$')\n<\n\t\tTo delete the last search pattern and use the last-but-one for\n\t\tthe \"n\" command and 'hlsearch': >\n\t\t\t:call histdel(\"search\", -1)\n\t\t\t:let @/ = histget(\"search\", -1)",
   "argsStr": "{history} [, {item}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histget",
   "description": "\t\tThe result is a String, the entry with Number {index} from\n\t\t{history}.  See |hist-names| for the possible values of\n\t\t{history}, and |:history-indexing| for {index}.  If there is\n\t\tno such entry, an empty String is returned.  When {index} is\n\t\tomitted, the most recent item from the history is used.\n\n\t\tExamples:\n\t\tRedo the second last search from history. >\n\t\t\t:execute '/' . histget(\"search\", -2)\n\n<\t\tDefine an Ex command \":H {num}\" that supports re-execution of\n\t\tthe {num}th entry from the output of |:history|. >\n\t\t\t:command -nargs=1 H execute histget(\"cmd\", 0+<args>)\n<",
   "argsStr": "{history} [, {index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histnr",
   "description": "\t\tThe result is the Number of the current entry in {history}.\n\t\tSee |hist-names| for the possible values of {history}.\n\t\tIf an error occurred, -1 is returned.\n\n\t\tExample: >\n\t\t\t:let inp_index = histnr(\"expr\")\n<",
   "argsStr": "{history}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hlexists",
   "description": "\t\tThe result is a Number, which is TRUE if a highlight group\n\t\tcalled {name} exists.  This is when the group has been\n\t\tdefined in some way.  Not necessarily when highlighting has\n\t\tbeen defined for it, it may also have been used for a syntax\n\t\titem.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hlID",
   "description": "The result is a Number, which is the ID of the highlight group\n\t\twith name {name}.  When the highlight group doesn't exist,\n\t\tzero is returned.\n\t\tThis can be used to retrieve information about the highlight\n\t\tgroup.  For example, to get the background color of the\n\t\t\"Comment\" group: >\n\t:echo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hostname",
   "description": "\t\tThe result is a String, which is the name of the machine on\n\t\twhich Vim is currently running.  Machine names greater than\n\t\t256 characters long are truncated.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "iconv",
   "description": "\t\tThe result is a String, which is the text {string} converted\n\t\tfrom encoding {from} to encoding {to}.\n\t\tWhen the conversion completely fails an empty string is\n\t\treturned.  When some characters could not be converted they\n\t\tare replaced with \"?\".\n\t\tThe encoding names are whatever the iconv() library function\n\t\tcan accept, see \":!man 3 iconv\".\n\t\tNote that Vim uses UTF-8 for all Unicode encodings, conversion\n\t\tfrom/to UCS-2 is automatically changed to use UTF-8.  You\n\t\tcannot use UCS-2 in a string anyway, because of the NUL bytes.",
   "argsStr": "{string}, {from}, {to}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "indent",
   "description": "The result is a Number, which is indent of line {lnum} in the\n\t\tcurrent buffer.  The indent is counted in spaces, the value\n\t\tof 'tabstop' is relevant.  {lnum} is used just like in\n\t\t|getline()|.\n\t\tWhen {lnum} is invalid -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "index",
   "description": "\t\tIf {object} is a |List| return the lowest index where the item\n\t\thas a value equal to {expr}.  There is no automatic\n\t\tconversion, so the String \"4\" is different from the Number 4.\n\t\tAnd the Number 4 is different from the Float 4.0.  The value\n\t\tof 'ignorecase' is not used here, case always matters.\n\n\t\tIf {object} is a |Blob| return the lowest index where the byte\n\t\tvalue is equal to {expr}.\n\n\t\tIf {start} is given then start looking at the item with index\n\t\t{start} (may be negative for an item relative to the end).\n\t\tWhen {ic} is given and it is |TRUE|, ignore case.  Otherwise\n\t\tcase must match.\n\t\t-1 is returned when {expr} is not found in {object}.\n\t\tExample: >\n\t\t\t:let idx = index(words, \"the\")\n\t\t\t:if index(numbers, 123) >= 0",
   "argsStr": "{object}, {expr} [, {start} [, {ic}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "input",
   "description": "input({opts})\n\t\tThe result is a String, which is whatever the user typed on\n\t\tthe command-line.  The {prompt} argument is either a prompt\n\t\tstring, or a blank string (for no prompt).  A '\\n' can be used\n\t\tin the prompt to start a new line.\n\n\t\tIn the second form it accepts a single dictionary with the\n\t\tfollowing keys, any of which may be omitted:\n\n\t\tKey           Default  Description ~\n\t\tprompt        \"\"       Same as {prompt} in the first form.\n\t\tdefault       \"\"       Same as {text} in the first form.\n\t\tcompletion    nothing  Same as {completion} in the first form.\n\t\tcancelreturn  \"\"       The value returned when the dialog is\n\t\t                       cancelled.\n\t\thighlight     nothing  Highlight handler: |Funcref|.\n\n\t\tThe highlighting set with |:echohl| is used for the prompt.\n\t\tThe input is entered just like a command-line, with the same\n\t\tediting commands and mappings.  There is a separate history\n\t\tfor lines typed for input().\n\t\tExample: >\n\t\t\t:if input(\"Coffee or beer? \") == \"beer\"\n\t\t\t:  echo \"Cheers!\"\n\t\t\t:endif\n<\n\t\tIf the optional {text} argument is present and not empty, this\n\t\tis used for the default reply, as if the user typed this.\n\t\tExample: >\n\t\t\t:let color = input(\"Color? \", \"white\")\n\n<\t\tThe optional {completion} argument specifies the type of\n\t\tcompletion supported for the input.  Without it completion is\n\t\tnot performed.  The supported completion types are the same as\n\t\tthat can be supplied to a user-defined command using the\n\t\t\"-complete=\" argument.  Refer to |:command-completion| for\n\t\tmore information.  Example: >\n\t\t\tlet fname = input(\"File: \", \"\", \"file\")",
   "argsStr": "{prompt} [, {text} [, {completion}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "input()-highlight* *E5400* *E5402",
   "description": "\t\tThe optional `highlight` key allows specifying function which\n\t\twill be used for highlighting user input.  This function\n\t\treceives user input as its only argument and must return\n\t\ta list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n\t\twhere\n\t\t\thl_start_col is the first highlighted column,\n\t\t\thl_end_col is the last highlighted column (+ 1!),\n\t\t\thl_group is |:hi| group used for highlighting.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5403* *E5404* *E5405* *E5406",
   "description": "Both hl_start_col and hl_end_col + 1 must point to the start\n\t\tof the multibyte character (highlighting must not break\n\t\tmultibyte characters), hl_end_col + 1 may be equal to the\n\t\tinput length.  Start column must be in range [0, len(input)),\n\t\tend column must be in range (hl_start_col, len(input)],\n\t\tsections must be ordered so that next hl_start_col is greater\n\t\tthen or equal to previous hl_end_col.\n\n\t\tExample (try some input with parentheses): >\n\t\t\thighlight RBP1 guibg=Red ctermbg=red\n\t\t\thighlight RBP2 guibg=Yellow ctermbg=yellow\n\t\t\thighlight RBP3 guibg=Green ctermbg=green\n\t\t\thighlight RBP4 guibg=Blue ctermbg=blue\n\t\t\tlet g:rainbow_levels = 4\n\t\t\tfunction! RainbowParens(cmdline)\n\t\t\t  let ret = []\n\t\t\t  let i = 0\n\t\t\t  let lvl = 0\n\t\t\t  while i < len(a:cmdline)\n\t\t\t    if a:cmdline[i] is# '('\n\t\t\t      call add(ret, [i, i + 1, 'RBP' . ((lvl % g:rainbow_levels) + 1)])\n\t\t\t      let lvl += 1\n\t\t\t    elseif a:cmdline[i] is# ')'\n\t\t\t      let lvl -= 1\n\t\t\t      call add(ret, [i, i + 1, 'RBP' . ((lvl % g:rainbow_levels) + 1)])\n\t\t\t    endif\n\t\t\t    let i += 1\n\t\t\t  endwhile\n\t\t\t  return ret\n\t\t\tendfunction\n\t\t\tcall input({'prompt':'>','highlight':'RainbowParens'})\n<\n\t\tHighlight function is called at least once for each new\n\t\tdisplayed input string, before command-line is redrawn.  It is\n\t\texpected that function is pure for the duration of one input()\n\t\tcall, i.e. it produces the same output for the same input, so\n\t\toutput may be memoized.  Function is run like under |:silent|\n\t\tmodifier. If the function causes any errors, it will be\n\t\tskipped for the duration of the current input() call.\n\n\t\tHighlighting is disabled if command-line contains arabic\n\t\tcharacters.\n\n\t\tNOTE: This function must not be used in a startup file, for\n\t\tthe versions that only run in GUI mode (e.g., the Win32 GUI).\n\t\tNote: When input() is called from within a mapping it will\n\t\tconsume remaining characters from that mapping, because a\n\t\tmapping is handled like the characters were typed.\n\t\tUse |inputsave()| before input() and |inputrestore()|\n\t\tafter input() to avoid that.  Another solution is to avoid\n\t\tthat further characters follow in the mapping, e.g., by using\n\t\t|:execute| or |:normal|.\n\n\t\tExample with a mapping: >\n\t\t\t:nmap \\x :call GetFoo()<CR>:exe \"/\" . Foo<CR>\n\t\t\t:function GetFoo()\n\t\t\t:  call inputsave()\n\t\t\t:  let g:Foo = input(\"enter search pattern: \")\n\t\t\t:  call inputrestore()\n\t\t\t:endfunction",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "inputlist",
   "description": "\t\t{textlist} must be a |List| of strings.  This |List| is\n\t\tdisplayed, one string per line.  The user will be prompted to\n\t\tenter a number, which is returned.\n\t\tThe user can also select an item by clicking on it with the\n\t\tmouse, if the mouse is enabled in the command line ('mouse' is\n\t\t\"a\" or includes \"c\").  For the first string 0 is returned.\n\t\tWhen clicking above the first item a negative number is\n\t\treturned.  When clicking on the prompt one more than the\n\t\tlength of {textlist} is returned.\n\t\tMake sure {textlist} has less than 'lines' entries, otherwise\n\t\tit won't work.  It's a good idea to put the entry number at\n\t\tthe start of the string.  And put a prompt in the first item.\n\t\tExample: >\n\t\t\tlet color = inputlist(['Select color:', '1. red',\n\t\t\t\t\\ '2. green', '3. blue'])",
   "argsStr": "{textlist}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputrestore",
   "description": "\t\tRestore typeahead that was saved with a previous |inputsave()|.\n\t\tShould be called the same number of times inputsave() is\n\t\tcalled.  Calling it more often is harmless though.\n\t\tReturns TRUE when there is nothing to restore, FALSE otherwise.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputsave",
   "description": "\t\tPreserve typeahead (also from mappings) and clear it, so that\n\t\ta following prompt gets input from the user.  Should be\n\t\tfollowed by a matching inputrestore() after the prompt.  Can\n\t\tbe used several times, in which case there must be just as\n\t\tmany inputrestore() calls.\n\t\tReturns TRUE when out of memory, FALSE otherwise.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputsecret",
   "description": "\t\tThis function acts much like the |input()| function with but\n\t\ttwo exceptions:\n\t\ta) the user's response will be displayed as a sequence of\n\t\tasterisks (\"*\") thereby keeping the entry secret, and\n\t\tb) the user's response will not be recorded on the input\n\t\t|history| stack.\n\t\tThe result is a String, which is whatever the user actually\n\t\ttyped on the command-line in response to the issued prompt.\n\t\tNOTE: Command-line completion is not supported.",
   "argsStr": "{prompt} [, {text}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "insert",
   "description": "\t\tWhen {object} is a |List| or a |Blob| insert {item} at the start\n\t\tof it.\n\n\t\tIf {idx} is specified insert {item} before the item with index\n\t\t{idx}.  If {idx} is zero it goes before the first item, just\n\t\tlike omitting {idx}.  A negative {idx} is also possible, see\n\t\t|list-index|.  -1 inserts just before the last item.\n\n\t\tReturns the resulting |List| or |Blob|.  Examples: >\n\t\t\t:let mylist = insert([2, 3, 5], 1)\n\t\t\t:call insert(mylist, 4, -1)\n\t\t\t:call insert(mylist, 6, len(mylist))\n<\t\tThe last example can be done simpler with |add()|.\n\t\tNote that when {item} is a |List| it is inserted as a single\n\t\titem.  Use |extend()| to concatenate |Lists|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->insert(item)",
   "argsStr": "{object}, {item} [, {idx}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "interrupt",
   "description": "\t\tInterrupt script execution.  It works more or less like the\n\t\tuser typing CTRL-C, most commands won't execute and control\n\t\treturns to the user.  This is useful to abort execution\n\t\tfrom lower down, e.g. in an autocommand.  Example: >\n\t\t:function s:check_typoname(file)\n\t\t:   if fnamemodify(a:file, ':t') == '['\n\t\t:       echomsg 'Maybe typo'\n\t\t:       call interrupt()\n\t\t:   endif\n\t\t:endfunction\n\t\t:au BufWritePre * call s:check_typoname(expand('<amatch>'))",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "invert",
   "description": "\t\tBitwise invert.  The argument is converted to a number.  A\n\t\tList, Dict or Float argument causes an error.  Example: >\n\t\t\t:let bits = invert(bits)\n<\t\tCan also be used as a |method|: >\n\t\t\t:let bits = bits->invert()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isdirectory",
   "description": "\t\tThe result is a Number, which is |TRUE| when a directory\n\t\twith the name {directory} exists.  If {directory} doesn't\n\t\texist, or isn't a directory, the result is |FALSE|.  {directory}\n\t\tis any expression, which is used as a String.",
   "argsStr": "{directory}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isinf",
   "description": "\t\tReturn 1 if {expr} is a positive infinity, or -1 a negative\n\t\tinfinity, otherwise 0. >\n\t\t\t:echo isinf(1.0 / 0.0)\n<\t\t\t1 >\n\t\t\t:echo isinf(-1.0 / 0.0)\n<\t\t\t-1\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->isinf()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "islocked",
   "description": "\t\tThe result is a Number, which is |TRUE| when {expr} is the\n\t\tname of a locked variable.\n\t\tThe string argument {expr} must be the name of a variable,\n\t\t|List| item or |Dictionary| entry, not the variable itself!\n\t\tExample: >\n\t\t\t:let alist = [0, ['a', 'b'], 2, 3]\n\t\t\t:lockvar 1 alist\n\t\t\t:echo islocked('alist')\t\t\" 1\n\t\t\t:echo islocked('alist[1]')\t\" 0\n\n<\t\tWhen {expr} is a variable that does not exist you get an error\n\t\tmessage.  Use |exists()| to check for existence.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "id",
   "description": "\t\tReturns a |String| which is a unique identifier of the\n\t\tcontainer type (|List|, |Dict|, |Blob| and |Partial|). It is\n\t\tguaranteed that for the mentioned types `id(v1) ==# id(v2)`\n\t\treturns true iff `type(v1) == type(v2) && v1 is v2`.\n\t\tNote that |v:_null_string|, |v:_null_list|, |v:_null_dict| and\n\t\t|v:_null_blob| have the same `id()` with different types\n\t\tbecause they are internally represented as NULL pointers.\n\t\t`id()` returns a hexadecimal representanion of the pointers to\n\t\tthe containers (i.e. like `0x994a40`), same as `printf(\"%p\",\n\t\t{expr})`, but it is advised against counting on the exact\n\t\tformat of the return value.\n\n\t\tIt is not guaranteed that `id(no_longer_existing_container)`\n\t\twill not be equal to some other `id()`: new containers may\n\t\treuse identifiers of the garbage-collected ones.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "items",
   "description": "\t\tReturn a |List| with all the key-value pairs of {dict}.  Each\n\t\t|List| item is a list with two items: the key of a {dict}\n\t\tentry and the value of this entry.  The |List| is in arbitrary\n\t\torder.  Also see |keys()| and |values()|.\n\t\tExample: >\n\t\t\tfor [key, value] in items(mydict)\n\t\t\t   echo key . ': ' . value\n\t\t\tendfor\n\n<\t\tCan also be used as a |method|: >\n\t\t\tmydict->items()",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isnan",
   "description": "\t\tReturn |TRUE| if {expr} is a float with value NaN. >\n\t\t\techo isnan(0.0 / 0.0)\n<\t\t\t1\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->isnan()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobpid",
   "description": "\t\tReturn the PID (process id) of |job-id| {job}.",
   "argsStr": "{job}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobresize",
   "description": "\t\tResize the pseudo terminal window of |job-id| {job} to {width}\n\t\tcolumns and {height} rows.\n\t\tFails if the job was not started with `\"pty\":v:true`.",
   "argsStr": "{job}, {width}, {height}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobstart",
   "description": "\t\tSpawns {cmd} as a job.\n\t\tIf {cmd} is a List it runs directly (no 'shell').\n\t\tIf {cmd} is a String it runs in the 'shell', like this: >\n\t\t  :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n<\t\t(See |shell-unquoting| for details.)\n\n\t\tExample: >\n\t\t  :call jobstart('nvim -h', {'on_stdout':{j,d,e->append(line('.'),d)}})\n<\n\t\tReturns |job-id| on success, 0 on invalid arguments (or job\n\t\ttable is full), -1 if {cmd}[0] or 'shell' is not executable.\n\t\tThe returned job-id is a valid |channel-id| representing the\n\t\tjob's stdio streams. Use |chansend()| (or |rpcnotify()| and\n\t\t|rpcrequest()| if \"rpc\" was enabled) to send data to stdin and\n\t\t|chanclose()| to close the streams without stopping the job.\n\n\t\tSee |job-control| and |RPC|.\n\n\t\tNOTE: on Windows if {cmd} is a List:\n\t\t  - cmd[0] must be an executable (not a \"built-in\"). If it is\n\t\t    in $PATH it can be called by name, without an extension: >\n\t\t      :call jobstart(['ping', 'neovim.io'])\n<\t\t    If it is a full or partial path, extension is required: >\n\t\t      :call jobstart(['System32\\ping.exe', 'neovim.io'])\n<\t\t  - {cmd} is collapsed to a string of quoted args as expected\n\t\t    by CommandLineToArgvW https://msdn.microsoft.com/bb776391\n\t\t    unless cmd[0] is some form of \"cmd.exe\".",
   "argsStr": "{cmd}[, {opts}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "jobstart-options",
   "description": "{opts} is a dictionary with these keys:\n\t\t  clear_env:  (boolean) `env` defines the job environment\n\t\t\t      exactly, instead of merging current environment.\n\t\t  cwd:\t      (string, default=|current-directory|) Working\n\t\t\t      directory of the job.\n\t\t  detach:     (boolean) Detach the job process: it will not be\n\t\t\t      killed when Nvim exits. If the process exits\n\t\t\t      before Nvim, `on_exit` will be invoked.\n\t\t  env:\t      (dict) Map of environment variable name:value\n\t\t\t      pairs extending (or replacing if |clear_env|)\n\t\t\t      the current environment.\n\t\t  height:     (number) Height of the `pty` terminal.\n\t\t  |on_exit|:    (function) Callback invoked when the job exits.\n\t\t  |on_stdout|:  (function) Callback invoked when the job emits\n\t\t\t      stdout data.\n\t\t  |on_stderr|:  (function) Callback invoked when the job emits\n\t\t\t      stderr data.\n\t\t  overlapped: (boolean) Set FILE_FLAG_OVERLAPPED for the\n\t\t\t      standard input/output passed to the child process.\n\t\t\t      Normally you do not need to set this.\n\t\t\t      (Only available on MS-Windows, On other\n\t\t\t      platforms, this option is silently ignored.)\n\t\t  pty:\t      (boolean) Connect the job to a new pseudo\n\t\t\t      terminal, and its streams to the master file\n\t\t\t      descriptor. Then  `on_stderr` is ignored,\n\t\t\t      `on_stdout` receives all output.\n\t\t  rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n\t\t\t      the job over stdio. Then `on_stdout` is ignored,\n\t\t\t      but `on_stderr` can still be used.\n\t\t  stderr_buffered: (boolean) Collect data until EOF (stream closed)\n\t\t\t      before invoking `on_stderr`. |channel-buffered|\n\t\t  stdout_buffered: (boolean) Collect data until EOF (stream\n\t\t\t      closed) before invoking `on_stdout`. |channel-buffered|\n\t\t  stdin:      (string) Either \"pipe\" (default) to connect the\n\t\t\t      job's stdin to a channel or \"null\" to disconnect\n\t\t\t      stdin.\n\t\t  width:      (number) Width of the `pty` terminal.\n\n\t\t{opts} is passed as |self| dictionary to the callback; the\n\t\tcaller may set other keys to pass application-specific data.\n\n\t\tReturns:\n\t\t  - |channel-id| on success\n\t\t  - 0 on invalid arguments\n\t\t  - -1 if {cmd}[0] is not executable.\n\t\tSee also |job-control|, |channel|, |msgpack-rpc|.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "jobstop",
   "description": "\t\tStop |job-id| {id} by sending SIGTERM to the job process. If\n\t\tthe process does not terminate after a timeout then SIGKILL\n\t\twill be sent. When the job terminates its |on_exit| handler\n\t\t(if any) will be invoked.\n\t\tSee |job-control|.\n\n\t\tReturns 1 for valid job id, 0 for invalid id, including jobs have\n\t\texited or stopped.",
   "argsStr": "{id}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobwait",
   "description": "\t\tWaits for jobs and their |on_exit| handlers to complete.\n\n\t\t{jobs} is a List of |job-id|s to wait for.\n\t\t{timeout} is the maximum waiting time in milliseconds. If\n\t\tomitted or -1, wait forever.\n\n\t\tTimeout of 0 can be used to check the status of a job: >\n\t\t\tlet running = jobwait([{job-id}], 0)[0] == -1\n<\n\t\tDuring jobwait() callbacks for jobs not in the {jobs} list may\n\t\tbe invoked. The screen will not redraw unless |:redraw| is\n\t\tinvoked by a callback.\n\n\t\tReturns a list of len({jobs}) integers, where each integer is\n\t\tthe status of the corresponding job:\n\t\t\tExit-code, if the job exited\n\t\t\t-1 if the timeout was exceeded\n\t\t\t-2 if the job was interrupted (by |CTRL-C|)\n\t\t\t-3 if the job-id is invalid",
   "argsStr": "{jobs}[, {timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "join",
   "description": "\t\tJoin the items in {list} together into one String.\n\t\tWhen {sep} is specified it is put in between the items.  If\n\t\t{sep} is omitted a single space is used.\n\t\tNote that {sep} is not added at the end.  You might want to\n\t\tadd it there too: >\n\t\t\tlet lines = join(mylist, \"\\n\") . \"\\n\"\n<\t\tString items are used as-is.  |Lists| and |Dictionaries| are\n\t\tconverted into a string like with |string()|.\n\t\tThe opposite function is |split()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->join()",
   "argsStr": "{list} [, {sep}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "json_decode",
   "description": "\t\tConvert {expr} from JSON object.  Accepts |readfile()|-style\n\t\tlist as the input, as well as regular string.  May output any\n\t\tVim value. In the following cases it will output\n\t\t|msgpack-special-dict|:\n\t\t1. Dictionary contains duplicate key.\n\t\t2. Dictionary contains empty key.\n\t\t3. String contains NUL byte.  Two special dictionaries: for\n\t\t   dictionary and for string will be emitted in case string\n\t\t   with NUL byte was a dictionary key.\n\n\t\tNote: function treats its input as UTF-8 always.  The JSON\n\t\tstandard allows only a few encodings, of which UTF-8 is\n\t\trecommended and the only one required to be supported.\n\t\tNon-UTF-8 characters are an error.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "json_encode",
   "description": "\t\tConvert {expr} into a JSON string.  Accepts\n\t\t|msgpack-special-dict| as the input.  Will not convert\n\t\t|Funcref|s, mappings with non-string keys (can be created as\n\t\t|msgpack-special-dict|), values with self-referencing\n\t\tcontainers, strings which contain non-UTF-8 characters,\n\t\tpseudo-UTF-8 strings which contain codepoints reserved for\n\t\tsurrogate pairs (such strings are not valid UTF-8 strings).\n\t\tNon-printable characters are converted into \"\\u1234\" escapes\n\t\tor special escapes like \"\\t\", other are dumped as-is.\n\t\t|Blob|s are converted to arrays of the individual bytes.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "keys",
   "description": "\t\tReturn a |List| with all the keys of {dict}.  The |List| is in\n\t\tarbitrary order.  Also see |items()| and |values()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmydict->keys()",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "len()* *E701",
   "description": "len({expr})\tThe result is a Number, which is the length of the argument.\n\t\tWhen {expr} is a String or a Number the length in bytes is\n\t\tused, as with |strlen()|.\n\t\tWhen {expr} is a |List| the number of items in the |List| is\n\t\treturned.\n\t\tWhen {expr} is a |Blob| the number of bytes is returned.\n\t\tWhen {expr} is a |Dictionary| the number of entries in the\n\t\t|Dictionary| is returned.\n\t\tOtherwise an error is given.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->len()",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "libcall()* *E364* *E368",
   "description": "libcall({libname}, {funcname}, {argument})\n\t\tCall function {funcname} in the run-time library {libname}\n\t\twith single argument {argument}.\n\t\tThis is useful to call functions in a library that you\n\t\tespecially made to be used with Vim.  Since only one argument\n\t\tis possible, calling standard library functions is rather\n\t\tlimited.\n\t\tThe result is the String returned by the function.  If the\n\t\tfunction returns NULL, this will appear as an empty string \"\"\n\t\tto Vim.\n\t\tIf the function returns a number, use libcallnr()!\n\t\tIf {argument} is a number, it is passed to the function as an\n\t\tint; if {argument} is a string, it is passed as a\n\t\tnull-terminated string.\n\n\t\tlibcall() allows you to write your own 'plug-in' extensions to\n\t\tVim without having to recompile the program.  It is NOT a\n\t\tmeans to call system functions!  If you try to do so Vim will\n\t\tvery probably crash.\n\n\t\tFor Win32, the functions you write must be placed in a DLL\n\t\tand use the normal C calling convention (NOT Pascal which is\n\t\tused in Windows System DLLs).  The function must take exactly\n\t\tone parameter, either a character pointer or a long integer,\n\t\tand must return a character pointer or NULL.  The character\n\t\tpointer returned must point to memory that will remain valid\n\t\tafter the function has returned (e.g. in static data in the\n\t\tDLL).  If it points to allocated memory, that memory will\n\t\tleak away.  Using a static buffer in the function should work,\n\t\tit's then freed when the DLL is unloaded.\n\n\t\tWARNING: If the function returns a non-valid pointer, Vim may\n\t\tcrash!\tThis also happens if the function returns a number,\n\t\tbecause Vim thinks it's a pointer.\n\t\tFor Win32 systems, {libname} should be the filename of the DLL\n\t\twithout the \".DLL\" suffix.  A full path is only required if\n\t\tthe DLL is not in the usual places.\n\t\tFor Unix: When compiling your own plugins, remember that the\n\t\tobject code must be compiled as position-independent ('PIC').\n\t\tExamples: >\n\t\t\t:echo libcall(\"libc.so\", \"getenv\", \"HOME\")\n<",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "libcallnr",
   "description": "\t\tJust like |libcall()|, but used for a function that returns an\n\t\tint instead of a string.\n\t\tExamples: >\n\t\t\t:echo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n\t\t\t:call libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n\t\t\t:call libcallnr(\"libc.so\", \"sleep\", 10)\n<",
   "argsStr": "{libname}, {funcname}, {argument}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "line",
   "description": "The result is a Number, which is the line number of the file\n\t\tposition given with {expr}.  The {expr} argument is a string.\n\t\tThe accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the last line in the current buffer\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    w0\t    first line visible in current window (one if the\n\t\t\t    display isn't updated, e.g. in silent Ex mode)\n\t\t    w$\t    last line visible in current window (this is one\n\t\t\t    less than \"w0\" if no lines are visible)\n\t\t    v\t    In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tNote that a mark in another file can be used.  The line number\n\t\tthen applies to another buffer.\n\t\tTo get the column number use |col()|.  To get both use\n\t\t|getpos()|.\n\t\tExamples: >\n\t\t\tline(\".\")\t\tline number of the cursor\n\t\t\tline(\"'t\")\t\tline number of mark t\n\t\t\tline(\"'\" . marker)\tline number of mark marker",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "line2byte",
   "description": "\t\tReturn the byte count from the start of the buffer for line\n\t\t{lnum}.  This includes the end-of-line character, depending on\n\t\tthe 'fileformat' option for the current buffer.  The first\n\t\tline returns 1. UTF-8 encoding is used, 'fileencoding' is\n\t\tignored.  This can also be used to get the byte count for the\n\t\tline just below the last line: >\n\t\t\tline2byte(line(\"$\") + 1)\n<\t\tThis is the buffer size plus one.  If 'fileencoding' is empty\n\t\tit is the file size plus one.  {lnum} is used like with\n\t\t|getline()|.  When {lnum} is invalid -1 is returned.\n\t\tAlso see |byte2line()|, |go| and |:goto|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "lispindent",
   "description": "\t\tGet the amount of indent for line {lnum} according the lisp\n\t\tindenting rules, as with 'lisp'.\n\t\tThe indent is counted in spaces, the value of 'tabstop' is\n\t\trelevant.  {lnum} is used just like in |getline()|.\n\t\tWhen {lnum} is invalid, -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "list2str",
   "description": "\t\tConvert each number in {list} to a character string can\n\t\tconcatenate them all.  Examples: >\n\t\t\tlist2str([32])\t\treturns \" \"\n\t\t\tlist2str([65, 66, 67])\treturns \"ABC\"\n<\t\tThe same can be done (slowly) with: >\n\t\t\tjoin(map(list, {nr, val -> nr2char(val)}), '')\n<\t\t|str2list()| does the opposite.\n\n\t\tWhen {utf8} is omitted or zero, the current 'encoding' is used.\n\t\tWith {utf8} is 1, always return utf-8 characters.\n\t\tWith utf-8 composing characters work as expected: >\n\t\t\tlist2str([97, 769])\treturns \"á\"\n<",
   "argsStr": "{list} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "localtime",
   "description": "\t\tReturn the current time, measured as seconds since 1st Jan\n\t\t1970.  See also |strftime()|, |strptime()| and |getftime()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "log",
   "description": "\t\tReturn the natural logarithm (base e) of {expr} as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t(0, inf].\n\t\tExamples: >\n\t\t\t:echo log(10)\n<\t\t\t2.302585 >\n\t\t\t:echo log(exp(5))\n<\t\t\t5.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->log()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "log10",
   "description": "\t\tReturn the logarithm of Float {expr} to base 10 as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo log10(1000)\n<\t\t\t3.0 >\n\t\t\t:echo log10(0.01)\n<\t\t\t-2.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->log10()\n\nluaeval({expr}[, {expr}])\n\t\tEvaluate Lua expression {expr} and return its result converted\n\t\tto Vim data structures. See |lua-eval| for more details.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "map",
   "description": "\t\t{expr1} must be a |List|, |Blob| or |Dictionary|.\n\t\tReplace each item in {expr1} with the result of evaluating\n\t\t{expr2}.  For a |Blob| each byte is replaced.\n\n\t\t{expr2} must be a |string| or |Funcref|.\n\n\t\tIf {expr2} is a |string|, inside {expr2} |v:val| has the value\n\t\tof the current item.  For a |Dictionary| |v:key| has the key\n\t\tof the current item and for a |List| |v:key| has the index of\n\t\tthe current item.  For a |Blob| |v:key| has the index of the\n\t\tcurrent byte.\n\t\tExample: >\n\t\t\t:call map(mylist, '\"> \" . v:val . \" <\"')\n<\t\tThis puts \"> \" before and \" <\" after each item in \"mylist\".\n\n\t\tNote that {expr2} is the result of an expression and is then\n\t\tused as an expression again.  Often it is good to use a\n\t\t|literal-string| to avoid having to double backslashes.  You\n\t\tstill have to double ' quotes\n\n\t\tIf {expr2} is a |Funcref| it is called with two arguments:\n\t\t\t1. The key or the index of the current item.\n\t\t\t2. the value of the current item.\n\t\tThe function must return the new value of the item. Example\n\t\tthat changes each value by \"key-value\": >\n\t\t\tfunc KeyValue(key, val)\n\t\t\t  return a:key . '-' . a:val\n\t\t\tendfunc\n\t\t\tcall map(myDict, function('KeyValue'))\n<\t\tIt is shorter when using a |lambda|: >\n\t\t\tcall map(myDict, {key, val -> key . '-' . val})\n<\t\tIf you do not use \"val\" you can leave it out: >\n\t\t\tcall map(myDict, {key -> 'item: ' . key})\n<\t\tIf you do not use \"key\" you can use a short name: >\n\t\t\tcall map(myDict, {_, val -> 'item: ' . val})\n<\n\t\tThe operation is done in-place.  If you want a |List| or\n\t\t|Dictionary| to remain unmodified make a copy first: >\n\t\t\t:let tlist = map(copy(mylist), ' v:val . \"\\t\"')\n\n<\t\tReturns {expr1}, the |List|, |Blob| or |Dictionary| that was\n\t\tfiltered.  When an error is encountered while evaluating\n\t\t{expr2} no further items in {expr1} are processed.  When\n\t\t{expr2} is a Funcref errors inside a function are ignored,\n\t\tunless it was defined with the \"abort\" flag.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->map(expr2)",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "maparg",
   "description": "\t\tWhen {dict} is omitted or zero: Return the rhs of mapping\n\t\t{name} in mode {mode}.  The returned String has special\n\t\tcharacters translated like in the output of the \":map\" command\n\t\tlisting.\n\n\t\tWhen there is no mapping for {name}, an empty String is\n\t\treturned.  When the mapping for {name} is empty, then \"<Nop>\"\n\t\tis returned.\n\n\t\tThe {name} can have special key names, like in the \":map\"\n\t\tcommand.\n\n\t\t{mode} can be one of these strings:\n\t\t\t\"n\"\tNormal\n\t\t\t\"v\"\tVisual (including Select)\n\t\t\t\"o\"\tOperator-pending\n\t\t\t\"i\"\tInsert\n\t\t\t\"c\"\tCmd-line\n\t\t\t\"s\"\tSelect\n\t\t\t\"x\"\tVisual\n\t\t\t\"l\"\tlangmap |language-mapping|\n\t\t\t\"t\"\tTerminal\n\t\t\t\"\"\tNormal, Visual and Operator-pending\n\t\tWhen {mode} is omitted, the modes for \"\" are used.\n\n\t\tWhen {abbr} is there and it is |TRUE| use abbreviations\n\t\tinstead of mappings.\n\n\t\tWhen {dict} is there and it is |TRUE| return a dictionary\n\t\tcontaining all the information of the mapping with the\n\t\tfollowing items:\n\t\t  \"lhs\"\t     The {lhs} of the mapping.\n\t\t  \"rhs\"\t     The {rhs} of the mapping as typed.\n\t\t  \"silent\"   1 for a |:map-silent| mapping, else 0.\n\t\t  \"noremap\"  1 if the {rhs} of the mapping is not remappable.\n\t\t  \"script\"   1 if mapping was defined with <script>.\n\t\t  \"expr\"     1 for an expression mapping (|:map-<expr>|).\n\t\t  \"buffer\"   1 for a buffer local mapping (|:map-local|).\n\t\t  \"mode\"     Modes for which the mapping is defined. In\n\t\t\t     addition to the modes mentioned above, these\n\t\t\t     characters will be used:\n\t\t\t     \" \"     Normal, Visual and Operator-pending\n\t\t\t     \"!\"     Insert and Commandline mode\n\t\t\t\t     (|mapmode-ic|)\n\t\t  \"sid\"\t     The script local ID, used for <sid> mappings\n\t\t\t     (|<SID>|).\n\t\t  \"lnum\"     The line number in \"sid\", zero if unknown.\n\t\t  \"nowait\"   Do not wait for other, longer mappings.\n\t\t\t     (|:map-<nowait>|).\n\n\t\tThe mappings local to the current buffer are checked first,\n\t\tthen the global mappings.\n\t\tThis function can be used to map a key even when it's already\n\t\tmapped, and have it do the original mapping too.  Sketch: >\n\t\t\texe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')",
   "argsStr": "{name} [, {mode} [, {abbr} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mapcheck",
   "description": "\t\tCheck if there is a mapping that matches with {name} in mode\n\t\t{mode}.  See |maparg()| for {mode} and special names in\n\t\t{name}.\n\t\tWhen {abbr} is there and it is non-zero use abbreviations\n\t\tinstead of mappings.\n\t\tA match happens with a mapping that starts with {name} and\n\t\twith a mapping which is equal to the start of {name}.\n\n\t\t\tmatches mapping \"a\"\t\"ab\"\t\"abc\" ~\n\t\t   mapcheck(\"a\")\tyes\tyes\t yes\n\t\t   mapcheck(\"abc\")\tyes\tyes\t yes\n\t\t   mapcheck(\"ax\")\tyes\tno\t no\n\t\t   mapcheck(\"b\")\tno\tno\t no\n\n\t\tThe difference with maparg() is that mapcheck() finds a\n\t\tmapping that matches with {name}, while maparg() only finds a\n\t\tmapping for {name} exactly.\n\t\tWhen there is no mapping that starts with {name}, an empty\n\t\tString is returned.  If there is one, the RHS of that mapping\n\t\tis returned.  If there are several mappings that start with\n\t\t{name}, the RHS of one of them is returned.  This will be\n\t\t\"<Nop>\" if the RHS is empty.\n\t\tThe mappings local to the current buffer are checked first,\n\t\tthen the global mappings.\n\t\tThis function can be used to check if a mapping can be added\n\t\twithout being ambiguous.  Example: >\n\t:if mapcheck(\"_vv\") == \"\"\n\t:   map _vv :set guifont=7x13<CR>\n\t:endif\n<\t\tThis avoids adding the \"_vv\" mapping when there already is a\n\t\tmapping for \"_v\" or for \"_vvv\".",
   "argsStr": "{name} [, {mode} [, {abbr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "match",
   "description": "\t\tWhen {expr} is a |List| then this returns the index of the\n\t\tfirst item where {pat} matches.  Each item is used as a\n\t\tString, |Lists| and |Dictionaries| are used as echoed.\n\n\t\tOtherwise, {expr} is used as a String.  The result is a\n\t\tNumber, which gives the index (byte offset) in {expr} where\n\t\t{pat} matches.\n\n\t\tA match at the first character or |List| item returns zero.\n\t\tIf there is no match -1 is returned.\n\n\t\tFor getting submatches see |matchlist()|.\n\t\tExample: >\n\t\t\t:echo match(\"testing\", \"ing\")\t\" results in 4\n\t\t\t:echo match([1, 'x'], '\\a')\t\" results in 1\n<\t\tSee |string-match| for how {pat} is used.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strpbrk",
   "description": "Vim doesn't have a strpbrk() function.  But you can do: >\n\t\t\t:let sepidx = match(line, '[.,;: \\t]')",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strcasestr",
   "description": "\t\tVim doesn't have a strcasestr() function.  But you can add\n\t\t\"\\c\" to the pattern to ignore case: >\n\t\t\t:let idx = match(haystack, '\\cneedle')\n<\n\t\tIf {start} is given, the search starts from byte index\n\t\t{start} in a String or item {start} in a |List|.\n\t\tThe result, however, is still the index counted from the\n\t\tfirst character/item.  Example: >\n\t\t\t:echo match(\"testing\", \"ing\", 2)\n<\t\tresult is again \"4\". >\n\t\t\t:echo match(\"testing\", \"ing\", 4)\n<\t\tresult is again \"4\". >\n\t\t\t:echo match(\"testing\", \"t\", 2)\n<\t\tresult is \"3\".\n\t\tFor a String, if {start} > 0 then it is like the string starts\n\t\t{start} bytes later, thus \"^\" will match at {start}.  Except\n\t\twhen {count} is given, then it's like matches before the\n\t\t{start} byte are ignored (this is a bit complicated to keep it\n\t\tbackwards compatible).\n\t\tFor a String, if {start} < 0, it will be set to 0.  For a list\n\t\tthe index is counted from the end.\n\t\tIf {start} is out of range ({start} > strlen({expr}) for a\n\t\tString or {start} > len({expr}) for a |List|) -1 is returned.\n\n\t\tWhen {count} is given use the {count}'th match.  When a match\n\t\tis found in a String the search for the next one starts one\n\t\tcharacter further.  Thus this example results in 1: >\n\t\t\techo match(\"testing\", \"..\", 0, 2)\n<\t\tIn a |List| the search continues in the next item.\n\t\tNote that when {count} is added the way {start} works changes,\n\t\tsee above.\n\n\t\tSee |pattern| for the patterns that are accepted.\n\t\tThe 'ignorecase' option is used to set the ignore-caseness of\n\t\tthe pattern.  'smartcase' is NOT used.  The matching is always\n\t\tdone like 'magic' is set and 'cpoptions' is empty.\n\t\tNote that a match at the start is preferred, thus when the\n\t\tpattern is using \"*\" (any number of matches) it tends to find\n\t\tzero matches at the start instead of a number of matches\n\t\tfurther down in the text.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchadd",
   "description": "\t\tDefines a pattern to be highlighted in the current window (a\n\t\t\"match\").  It will be highlighted with {group}.  Returns an\n\t\tidentification number (ID), which can be used to delete the\n\t\tmatch using |matchdelete()|.  The ID is bound to the window.\n\t\tMatching is case sensitive and magic, unless case sensitivity\n\t\tor magicness are explicitly overridden in {pattern}.  The\n\t\t'magic', 'smartcase' and 'ignorecase' options are not used.\n\t\tThe \"Conceal\" value is special, it causes the match to be\n\t\tconcealed.\n\n\t\tThe optional {priority} argument assigns a priority to the\n\t\tmatch.  A match with a high priority will have its\n\t\thighlighting overrule that of a match with a lower priority.\n\t\tA priority is specified as an integer (negative numbers are no\n\t\texception).  If the {priority} argument is not specified, the\n\t\tdefault priority is 10.  The priority of 'hlsearch' is zero,\n\t\thence all matches with a priority greater than zero will\n\t\toverrule it.  Syntax highlighting (see 'syntax') is a separate\n\t\tmechanism, and regardless of the chosen priority a match will\n\t\talways overrule syntax highlighting.\n\n\t\tThe optional {id} argument allows the request for a specific\n\t\tmatch ID.  If a specified ID is already taken, an error\n\t\tmessage will appear and the match will not be added.  An ID\n\t\tis specified as a positive integer (zero excluded).  IDs 1, 2\n\t\tand 3 are reserved for |:match|, |:2match| and |:3match|,\n\t\trespectively.  If the {id} argument is not specified or -1,\n\t\t|matchadd()| automatically chooses a free ID.\n\n\t\tThe optional {dict} argument allows for further custom\n\t\tvalues. Currently this is used to specify a match specific\n\t\tconceal character that will be shown for |hl-Conceal|\n\t\thighlighted matches. The dict can have the following members:\n\n\t\t\tconceal\t    Special character to show instead of the\n\t\t\t\t    match (only for |hl-Conceal| highlighed\n\t\t\t\t    matches, see |:syn-cchar|)\n\t\t\twindow\t    Instead of the current window use the\n\t\t\t\t    window with this number or window ID.\n\n\t\tThe number of matches is not limited, as it is the case with\n\t\tthe |:match| commands.\n\n\t\tExample: >\n\t\t\t:highlight MyGroup ctermbg=green guibg=green\n\t\t\t:let m = matchadd(\"MyGroup\", \"TODO\")\n<\t\tDeletion of the pattern: >\n\t\t\t:call matchdelete(m)\n\n<\t\tA list of matches defined by |matchadd()| and |:match| are\n\t\tavailable from |getmatches()|.  All matches can be deleted in\n\t\tone operation by |clearmatches()|.",
   "argsStr": "{group}, {pattern}[, {priority}[, {id} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchaddpos",
   "description": "\t\tSame as |matchadd()|, but requires a list of positions {pos}\n\t\tinstead of a pattern. This command is faster than |matchadd()|\n\t\tbecause it does not require to handle regular expressions and\n\t\tsets buffer line boundaries to redraw screen. It is supposed\n\t\tto be used when fast match additions and deletions are\n\t\trequired, for example to highlight matching parentheses.",
   "argsStr": "{group}, {pos} [, {priority} [, {id} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5030* *E5031",
   "description": "{pos} is a list of positions.  Each position can be one of\n\t\tthese:\n\t\t- A number.  This whole line will be highlighted.  The first\n\t\t  line has number 1.\n\t\t- A list with one number, e.g., [23]. The whole line with this\n\t\t  number will be highlighted.\n\t\t- A list with two numbers, e.g., [23, 11]. The first number is\n\t\t  the line number, the second one is the column number (first\n\t\t  column is 1, the value must correspond to the byte index as\n\t\t  |col()| would return).  The character at this position will\n\t\t  be highlighted.\n\t\t- A list with three numbers, e.g., [23, 11, 3]. As above, but\n\t\t  the third number gives the length of the highlight in bytes.\n\n\t\tEntries with zero and negative line numbers are silently\n\t\tignored, as well as entries with negative column numbers and\n\t\tlengths.\n\n\t\tThe maximum number of positions in {pos} is 8.\n\n\t\tExample: >\n\t\t\t:highlight MyGroup ctermbg=green guibg=green\n\t\t\t:let m = matchaddpos(\"MyGroup\", [[23, 24], 34])\n<\t\tDeletion of the pattern: >\n\t\t\t:call matchdelete(m)\n\n<\t\tMatches added by |matchaddpos()| are returned by\n\t\t|getmatches()|.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "matcharg",
   "description": "\t\tSelects the {nr} match item, as set with a |:match|,\n\t\t|:2match| or |:3match| command.\n\t\tReturn a |List| with two elements:\n\t\t\tThe name of the highlight group used\n\t\t\tThe pattern used.\n\t\tWhen {nr} is not 1, 2 or 3 returns an empty |List|.\n\t\tWhen there is no match item set returns ['', ''].\n\t\tThis is useful to save and restore a |:match|.\n\t\tHighlighting matches using the |:match| commands are limited\n\t\tto three matches. |matchadd()| does not have this limitation.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchdelete",
   "description": "\t\tDeletes a match with ID {id} previously defined by |matchadd()|\n\t\tor one of the |:match| commands.  Returns 0 if successful,\n\t\totherwise -1.  See example for |matchadd()|.  All matches can\n\t\tbe deleted in one operation by |clearmatches()|.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsStr": "{id} [, {win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchend",
   "description": "\t\tSame as |match()|, but return the index of first character\n\t\tafter the match.  Example: >\n\t\t\t:echo matchend(\"testing\", \"ing\")\n<\t\tresults in \"7\".",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strspn()* *strcspn",
   "description": "Vim doesn't have a strspn() or strcspn() function, but you can\n\t\tdo it with matchend(): >\n\t\t\t:let span = matchend(line, '[a-zA-Z]')\n\t\t\t:let span = matchend(line, '[^a-zA-Z]')\n<\t\tExcept that -1 is returned when there are no matches.\n\n\t\tThe {start}, if given, has the same meaning as for |match()|. >\n\t\t\t:echo matchend(\"testing\", \"ing\", 2)\n<\t\tresults in \"7\". >\n\t\t\t:echo matchend(\"testing\", \"ing\", 5)\n<\t\tresult is \"-1\".\n\t\tWhen {expr} is a |List| the result is equal to |match()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchlist",
   "description": "\t\tSame as |match()|, but return a |List|.  The first item in the\n\t\tlist is the matched string, same as what matchstr() would\n\t\treturn.  Following items are submatches, like \"\\1\", \"\\2\", etc.\n\t\tin |:substitute|.  When an optional submatch didn't match an\n\t\tempty string is used.  Example: >\n\t\t\techo matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)')\n<\t\tResults in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']\n\t\tWhen there is no match an empty list is returned.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchstr",
   "description": "\t\tSame as |match()|, but return the matched string.  Example: >\n\t\t\t:echo matchstr(\"testing\", \"ing\")\n<\t\tresults in \"ing\".\n\t\tWhen there is no match \"\" is returned.\n\t\tThe {start}, if given, has the same meaning as for |match()|. >\n\t\t\t:echo matchstr(\"testing\", \"ing\", 2)\n<\t\tresults in \"ing\". >\n\t\t\t:echo matchstr(\"testing\", \"ing\", 5)\n<\t\tresult is \"\".\n\t\tWhen {expr} is a |List| then the matching item is returned.\n\t\tThe type isn't changed, it's not necessarily a String.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchstrpos",
   "description": "\t\tSame as |matchstr()|, but return the matched string, the start\n\t\tposition and the end position of the match.  Example: >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\")\n<\t\tresults in [\"ing\", 4, 7].\n\t\tWhen there is no match [\"\", -1, -1] is returned.\n\t\tThe {start}, if given, has the same meaning as for |match()|. >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\", 2)\n<\t\tresults in [\"ing\", 4, 7]. >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\", 5)\n<\t\tresult is [\"\", -1, -1].\n\t\tWhen {expr} is a |List| then the matching item, the index\n\t\tof first item where {pat} matches, the start position and the\n\t\tend position of the match are returned. >\n\t\t\t:echo matchstrpos([1, '__x'], '\\a')\n<\t\tresult is [\"x\", 1, 2, 3].\n\t\tThe type isn't changed, it's not necessarily a String.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "max",
   "description": "Return the maximum value of all items in {expr}.\n\t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\n\t\tit returns the maximum of all values in the Dictionary.\n\t\tIf {expr} is neither a List nor a Dictionary, or one of the\n\t\titems in {expr} cannot be used as a Number this results in\n                an error.  An empty |List| or |Dictionary| results in zero.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->max()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "menu_get",
   "description": "\t\tReturns a |List| of |Dictionaries| describing |menus| (defined\n\t\tby |:menu|, |:amenu|, …), including |hidden-menus|.\n\n\t\t{path} matches a menu by name, or all menus if {path} is an\n\t\tempty string.  Example: >\n\t\t\t:echo menu_get('File','')\n\t\t\t:echo menu_get('')\n<\n\t\t{modes} is a string of zero or more modes (see |maparg()| or\n\t\t|creating-menus| for the list of modes). \"a\" means \"all\".\n\n\t\tExample: >\n\t\t\tnnoremenu &Test.Test inormal\n\t\t\tinoremenu Test.Test insert\n\t\t\tvnoremenu Test.Test x\n\t\t\techo menu_get(\"\")\n\n<\t\treturns something like this: >\n\n\t\t\t[ {\n\t\t\t  \"hidden\": 0,\n\t\t\t  \"name\": \"Test\",\n\t\t\t  \"priority\": 500,\n\t\t\t  \"shortcut\": 84,\n\t\t\t  \"submenus\": [ {\n\t\t\t    \"hidden\": 0,\n\t\t\t    \"mappings\": {\n\t\t\t      i\": {\n\t\t\t\t\"enabled\": 1,\n\t\t\t\t\"noremap\": 1,\n\t\t\t\t\"rhs\": \"insert\",\n\t\t\t\t\"sid\": 1,\n\t\t\t\t\"silent\": 0\n\t\t\t      },\n\t\t\t      n\": { ... },\n\t\t\t      s\": { ... },\n\t\t\t      v\": { ... }\n\t\t\t    },\n\t\t\t    \"name\": \"Test\",\n\t\t\t    \"priority\": 500,\n\t\t\t    \"shortcut\": 0\n\t\t\t  } ]\n\t\t\t} ]\n<",
   "argsStr": "{path} [, {modes}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "min",
   "description": "Return the minimum value of all items in {expr}.\n\t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\n\t\tit returns the minimum of all values in the Dictionary.\n\t\tIf {expr} is neither a List nor a Dictionary, or one of the\n\t\titems in {expr} cannot be used as a Number this results in\n\t\tan error.  An empty |List| or |Dictionary| results in zero.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->min()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mkdir()* *E739",
   "description": "mkdir({name} [, {path} [, {prot}]])\n\t\tCreate directory {name}.\n\t\tIf {path} is \"p\" then intermediate directories are created as\n\t\tnecessary.  Otherwise it must be \"\".\n\t\tIf {prot} is given it is used to set the protection bits of\n\t\tthe new directory.  The default is 0o755 (rwxr-xr-x: r/w for\n\t\tthe user, readable for others).  Use 0o700 to make it\n\t\tunreadable for others.\n\n\t\t{prot} is applied for all parts of {name}.  Thus if you create\n\t\t/tmp/foo/bar then /tmp/foo will be created with 0700. Example: >\n\t\t\t:call mkdir($HOME . \"/tmp/foo/bar\", \"p\", 0700)\n<\t\tThis function is not available in the |sandbox|.\n\n\t\tIf you try to create an existing directory with {path} set to\n\t\t\"p\" mkdir() will silently exit.\n\n\t\tThe function result is a Number, which is TRUE if the call was\n\t\tsuccessful or FALSE if the directory creation failed or partly\n\t\tfailed.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mode",
   "description": "Return a string that indicates the current mode.\n\t\tIf [expr] is supplied and it evaluates to a non-zero Number or\n\t\ta non-empty String (|non-zero-arg|), then the full mode is\n\t\treturned, otherwise only the first letter is returned.\n\n\t\t   n\t    Normal\n\t\t   no\t    Operator-pending\n\t\t   nov\t    Operator-pending (forced charwise |o_v|)\n\t\t   noV\t    Operator-pending (forced linewise |o_V|)\n\t\t   noCTRL-V Operator-pending (forced blockwise |o_CTRL-V|)\n\t\t\t\tCTRL-V is one character\n\t\t   niI\t    Normal using |i_CTRL-O| in |Insert-mode|\n\t\t   niR\t    Normal using |i_CTRL-O| in |Replace-mode|\n\t\t   niV\t    Normal using |i_CTRL-O| in |Virtual-Replace-mode|\n\t\t   v\t    Visual by character\n\t\t   V\t    Visual by line\n\t\t   CTRL-V   Visual blockwise\n\t\t   s\t    Select by character\n\t\t   S\t    Select by line\n\t\t   CTRL-S   Select blockwise\n\t\t   vs\t    Visual by character using |v_CTRL-O| from\n\t\t\t\tSelect mode\n\t\t   Vs\t    Visual by line using |v_CTRL-O| from Select mode\n\t\t   CTRL-Vs  Visual blockwise using |v_CTRL-O| from Select mode\n\t\t   i\t    Insert\n\t\t   ic\t    Insert mode completion |compl-generic|\n\t\t   ix\t    Insert mode |i_CTRL-X| completion\n\t\t   R\t    Replace |R|\n\t\t   Rc\t    Replace mode completion |compl-generic|\n\t\t   Rv\t    Virtual Replace |gR|\n\t\t   Rx\t    Replace mode |i_CTRL-X| completion\n\t\t   c\t    Command-line editing\n\t\t   cv\t    Vim Ex mode |Q| or |gQ|\n\t\t   r\t    Hit-enter prompt\n\t\t   rm\t    The -- more -- prompt\n\t\t   r?\t    |:confirm| query of some sort\n\t\t   !\t    Shell or external command is executing\n\t\t   t\t    Terminal mode: keys go to the job\n\t\tThis is useful in the 'statusline' option or when used\n\t\twith |remote_expr()| In most other places it always returns\n\t\t\"c\" or \"n\".\n\t\tNote that in the future more modes and more specific modes may\n\t\tbe added. It's better not to compare the whole string but only\n\t\tthe leading character(s).\n\t\tAlso see |visualmode()|.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "msgpackdump",
   "description": "\t\tConvert a list of VimL objects to msgpack. Returned value is a\n\t\t|readfile()|-style list. When {type} contains \"B\", a |Blob| is\n\t\treturned instead. Example: >\n\t\t\tcall writefile(msgpackdump([{}]), 'fname.mpack', 'b')\n<\t\tor, using a |Blob|: >\n\t\t\tcall writefile(msgpackdump([{}], 'B'), 'fname.mpack')\n<\n\t\tThis will write the single 0x80 byte to a `fname.mpack` file\n\t\t(dictionary with zero items is represented by 0x80 byte in\n\t\tmessagepack).",
   "argsStr": "{list} [, {type}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5004* *E5005",
   "description": "\t\t1. |Funcref|s cannot be dumped.\n\t\t2. Containers that reference themselves cannot be dumped.\n\t\t3. Dictionary keys are always dumped as STR strings.\n\t\t4. Other strings and |Blob|s are always dumped as BIN strings.\n\t\t5. Points 3. and 4. do not apply to |msgpack-special-dict|s.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "msgpackparse",
   "description": "\t\tConvert a |readfile()|-style list or a |Blob| to a list of\n\t\tVimL objects.\n\t\tExample: >\n\t\t\tlet fname = expand('~/.config/nvim/shada/main.shada')\n\t\t\tlet mpack = readfile(fname, 'b')\n\t\t\tlet shada_objects = msgpackparse(mpack)\n<\t\tThis will read ~/.config/nvim/shada/main.shada file to\n\t\t`shada_objects` list.\n\n\t\tLimitations:\n\t\t1. Mapping ordering is not preserved unless messagepack\n\t\t   mapping is dumped using generic mapping\n\t\t   (|msgpack-special-map|).\n\t\t2. Since the parser aims to preserve all data untouched\n\t\t   (except for 1.) some strings are parsed to\n\t\t   |msgpack-special-dict| format which is not convenient to\n\t\t   use.",
   "argsStr": "{data}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "msgpack-special-dict",
   "description": "Some messagepack strings may be parsed to special\n\t\tdictionaries. Special dictionaries are dictionaries which\n\n\t\t1. Contain exactly two keys: `_TYPE` and `_VAL`.\n\t\t2. `_TYPE` key is one of the types found in |v:msgpack_types|\n\t\t   variable.\n\t\t3. Value for `_VAL` has the following format (Key column\n\t\t   contains name of the key from |v:msgpack_types|):\n\n\t\tKey\tValue ~\n\t\tnil\tZero, ignored when dumping.  Not returned by\n\t\t\t|msgpackparse()| since |v:null| was introduced.\n\t\tboolean\tOne or zero.  When dumping it is only checked that\n\t\t\tvalue is a |Number|.  Not returned by |msgpackparse()|\n\t\t\tsince |v:true| and |v:false| were introduced.\n\t\tinteger\t|List| with four numbers: sign (-1 or 1), highest two\n\t\t\tbits, number with bits from 62nd to 31st, lowest 31\n\t\t\tbits. I.e. to get actual number one will need to use\n\t\t\tcode like >\n\t\t\t\t_VAL[0] * ((_VAL[1] << 62)\n\t\t\t\t           & (_VAL[2] << 31)\n\t\t\t\t           & _VAL[3])\n<\t\t\tSpecial dictionary with this type will appear in\n\t\t\t|msgpackparse()| output under one of the following\n\t\t\tcircumstances:\n\t\t\t1. |Number| is 32-bit and value is either above\n\t\t\t   INT32_MAX or below INT32_MIN.\n\t\t\t2. |Number| is 64-bit and value is above INT64_MAX. It\n\t\t\t   cannot possibly be below INT64_MIN because msgpack\n\t\t\t   C parser does not support such values.\n\t\tfloat\t|Float|. This value cannot possibly appear in\n\t\t\t|msgpackparse()| output.\n\t\tstring\t|readfile()|-style list of strings. This value will\n\t\t\tappear in |msgpackparse()| output if string contains\n\t\t\tzero byte or if string is a mapping key and mapping is\n\t\t\tbeing represented as special dictionary for other\n\t\t\treasons.\n\t\tbinary\t|String|, or |Blob| if binary string contains zero\n\t\t\tbyte. This value cannot appear in |msgpackparse()|\n\t\t\toutput since blobs were introduced.\n\t\tarray\t|List|. This value cannot appear in |msgpackparse()|\n\t\t\toutput.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "msgpack-special-map",
   "description": "map|List| of |List|s with two items (key and value) each.\n\t\t\tThis value will appear in |msgpackparse()| output if\n\t\t\tparsed mapping contains one of the following keys:\n\t\t\t1. Any key that is not a string (including keys which\n\t\t\t   are binary strings).\n\t\t\t2. String with NUL byte inside.\n\t\t\t3. Duplicate key.\n\t\t\t4. Empty key.\n\t\text\t|List| with two values: first is a signed integer\n\t\t\trepresenting extension type. Second is\n\t\t\t|readfile()|-style list of strings.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "nextnonblank",
   "description": "\t\tReturn the line number of the first line at or below {lnum}\n\t\tthat is not blank.  Example: >\n\t\t\tif getline(nextnonblank(1)) =~ \"Java\"\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\n\t\tbelow it, zero is returned.\n\t\t{lnum} is used like with |getline()|.\n\t\tSee also |prevnonblank()|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "nr2char",
   "description": "\t\tReturn a string with a single character, which has the number\n\t\tvalue {expr}.  Examples: >\n\t\t\tnr2char(64)\t\treturns \"@\"\n\t\t\tnr2char(32)\t\treturns \" \"\n<\t\tExample for \"utf-8\": >\n\t\t\tnr2char(300)\t\treturns I with bow character\n<\t\tUTF-8 encoding is always used, {utf8} option has no effect,\n\t\tand exists only for backwards-compatibility.\n\t\tNote that a NUL character in the file is specified with\n\t\tnr2char(10), because NULs are represented with newline\n\t\tcharacters.  nr2char(0) is a real NUL and terminates the\n\t\tstring, thus results in an empty string.",
   "argsStr": "{expr} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "nvim_...",
   "description": "\t\tCall nvim |api| functions. The type checking of arguments will\n\t\tbe stricter than for most other builtins. For instance,\n\t\tif Integer is expected, a |Number| must be passed in, a\n\t\t|String| will not be autoconverted.\n\t\tBuffer numbers, as returned by |bufnr()| could be used as\n\t\tfirst argument to nvim_buf_... functions.  All functions\n\t\texpecting an object (buffer, window or tabpage) can\n\t\talso take the numerical value 0 to indicate the current\n\t\t(focused) object.",
   "argsStr": "{...}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "or",
   "description": "\t\tBitwise OR on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let bits = or(bits, 0x80)\n<\t\tCan also be used as a |method|: >\n\t\t\t:let bits = bits->or(0x80)",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pathshorten",
   "description": "\t\tShorten directory names in the path {path} and return the\n\t\tresult.  The tail, the file name, is kept as-is.  The other\n\t\tcomponents in the path are reduced to single letters.  Leading\n\t\t'~' and '.' characters are kept.  Example: >\n\t\t\t:echo pathshorten('~/.config/nvim/autoload/file1.vim')\n<\t\t\t~/.c/n/a/file1.vim ~\n\t\tIt doesn't matter if the path exists or not.",
   "argsStr": "{path}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "perleval",
   "description": "\t\tEvaluate |perl| expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type,\n\t\tnon-string keys result in error.\n\n\t\tNote: If you want an array or hash, {expr} must return a\n\t\treference to it.\n\t\tExample: >\n\t\t\t:echo perleval('[1 .. 4]')\n<\t\t\t[1, 2, 3, 4]",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pow",
   "description": "\t\tReturn the power of {x} to the exponent {y} as a |Float|.\n\t\t{x} and {y} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo pow(3, 3)\n<\t\t\t27.0 >\n\t\t\t:echo pow(2, 16)\n<\t\t\t65536.0 >\n\t\t\t:echo pow(32, 0.20)\n<\t\t\t2.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->pow(3)",
   "argsStr": "{x}, {y}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prevnonblank",
   "description": "\t\tReturn the line number of the first line at or above {lnum}\n\t\tthat is not blank.  Example: >\n\t\t\tlet ind = indent(prevnonblank(v:lnum - 1))\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\n\t\tabove it, zero is returned.\n\t\t{lnum} is used like with |getline()|.\n\t\tAlso see |nextnonblank()|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "printf",
   "description": "\t\tReturn a String with {fmt}, where \"%\" items are replaced by\n\t\tthe formatted form of their respective arguments.  Example: >\n\t\t\tprintf(\"%4d: E%d %.30s\", lnum, errno, msg)\n<\t\tMay result in:\n\t\t\t\"  99: E42 asdfasdfasdfasdfasdfasdfasdfas\" ~\n\n\t\tWhen used as a |method| the base is passed as the second\n\t\targument: >\n\t\t\tCompute()->printf(\"result: %d\")\n\n<\t\tOften used items are:\n\t\t  %s\tstring\n\t\t  %6S\tstring right-aligned in 6 display cells\n\t\t  %6s\tstring right-aligned in 6 bytes\n\t\t  %.9s\tstring truncated to 9 bytes\n\t\t  %c\tsingle byte\n\t\t  %d\tdecimal number\n\t\t  %5d\tdecimal number padded with spaces to 5 characters\n\t\t  %b\tbinary number\n\t\t  %08b\tbinary number padded with zeros to at least 8 characters\n\t\t  %B\tbinary number using upper case letters\n\t\t  %x\thex number\n\t\t  %04x\thex number padded with zeros to at least 4 characters\n\t\t  %X\thex number using upper case letters\n\t\t  %o\toctal number\n\t\t  %f\tfloating point number as 12.23, inf, -inf or nan\n\t\t  %F\tfloating point number as 12.23, INF, -INF or NAN\n\t\t  %e\tfloating point number as 1.23e3, inf, -inf or nan\n\t\t  %E\tfloating point number as 1.23E3, INF, -INF or NAN\n\t\t  %g\tfloating point number, as %f or %e depending on value\n\t\t  %G\tfloating point number, as %F or %E depending on value\n\t\t  %%\tthe % character itself\n\t\t  %p\trepresentation of the pointer to the container\n\n\t\tConversion specifications start with '%' and end with the\n\t\tconversion type.  All other characters are copied unchanged to\n\t\tthe result.\n\n\t\tThe \"%\" starts a conversion specification.  The following\n\t\targuments appear in sequence:\n\n\t\t\t%  [flags]  [field-width]  [.precision]  type\n\n\t\tflags\n\t\t\tZero or more of the following flags:\n\n\t\t    #\t      The value should be converted to an \"alternate\n\t\t\t      form\".  For c, d, and s conversions, this option\n\t\t\t      has no effect.  For o conversions, the precision\n\t\t\t      of the number is increased to force the first\n\t\t\t      character of the output string to a zero (except\n\t\t\t      if a zero value is printed with an explicit\n\t\t\t      precision of zero).\n\t\t\t      For x and X conversions, a non-zero result has\n\t\t\t      the string \"0x\" (or \"0X\" for X conversions)\n\t\t\t      prepended to it.\n\n\t\t    0 (zero)  Zero padding.  For all conversions the converted\n\t\t\t      value is padded on the left with zeros rather\n\t\t\t      than blanks.  If a precision is given with a\n\t\t\t      numeric conversion (d, o, x, and X), the 0 flag\n\t\t\t      is ignored.\n\n\t\t    -\t      A negative field width flag; the converted value\n\t\t\t      is to be left adjusted on the field boundary.\n\t\t\t      The converted value is padded on the right with\n\t\t\t      blanks, rather than on the left with blanks or\n\t\t\t      zeros.  A - overrides a 0 if both are given.\n\n\t\t    ' ' (space)  A blank should be left before a positive\n\t\t\t      number produced by a signed conversion (d).\n\n\t\t    +\t      A sign must always be placed before a number\n\t\t\t      produced by a signed conversion.  A + overrides\n\t\t\t      a space if both are used.\n\n\t\tfield-width\n\t\t\tAn optional decimal digit string specifying a minimum\n\t\t\tfield width.  If the converted value has fewer bytes\n\t\t\tthan the field width, it will be padded with spaces on\n\t\t\tthe left (or right, if the left-adjustment flag has\n\t\t\tbeen given) to fill out the field width.\n\n\t\t.precision\n\t\t\tAn optional precision, in the form of a period '.'\n\t\t\tfollowed by an optional digit string.  If the digit\n\t\t\tstring is omitted, the precision is taken as zero.\n\t\t\tThis gives the minimum number of digits to appear for\n\t\t\td, o, x, and X conversions, or the maximum number of\n\t\t\tbytes to be printed from a string for s conversions.\n\t\t\tFor floating point it is the number of digits after\n\t\t\tthe decimal point.\n\n\t\ttype\n\t\t\tA character that specifies the type of conversion to\n\t\t\tbe applied, see below.\n\n\t\tA field width or precision, or both, may be indicated by an\n\t\tasterisk '*' instead of a digit string.  In this case, a\n\t\tNumber argument supplies the field width or precision.  A\n\t\tnegative field width is treated as a left adjustment flag\n\t\tfollowed by a positive field width; a negative precision is\n\t\ttreated as though it were missing.  Example: >\n\t\t\t:echo printf(\"%d: %.*s\", nr, width, line)\n<\t\tThis limits the length of the text used from \"line\" to\n\t\t\"width\" bytes.\n\n\t\tThe conversion specifiers and their meanings are:",
   "argsStr": "{fmt}, {expr1} ...",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X",
   "description": "dbBoxXThe Number argument is converted to signed decimal (d),\n\t\t\tunsigned binary (b and B), unsigned octal (o), or\n\t\t\tunsigned hexadecimal (x and X) notation.  The letters\n\t\t\t\"abcdef\" are used for x conversions; the letters\n\t\t\t\"ABCDEF\" are used for X conversions.  The precision, if\n\t\t\tany, gives the minimum number of digits that must\n\t\t\tappear; if the converted value requires fewer digits, it\n\t\t\tis padded on the left with zeros.  In no case does a\n\t\t\tnon-existent or small field width cause truncation of a\n\t\t\tnumeric field; if the result of a conversion is wider\n\t\t\tthan the field width, the field is expanded to contain\n\t\t\tthe conversion result.\n\t\t\tThe 'h' modifier indicates the argument is 16 bits.\n\t\t\tThe 'l' modifier indicates the argument is 32 bits.\n\t\t\tThe 'L' modifier indicates the argument is 64 bits.\n\t\t\tGenerally, these modifiers are not useful. They are\n\t\t\tignored when type is known from the argument.\n\n\t\ti\talias for d\n\t\tD\talias for ld\n\t\tU\talias for lu\n\t\tO\talias for lo",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-c",
   "description": "cThe Number argument is converted to a byte, and the\n\t\t\tresulting character is written.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-s",
   "description": "sThe text of the String argument is used.  If a\n\t\t\tprecision is specified, no more bytes than the number\n\t\t\tspecified are used.\n\t\t\tIf the argument is not a String type, it is\n\t\t\tautomatically converted to text with the same format\n\t\t\tas \":echo\".",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-S",
   "description": "SThe text of the String argument is used.  If a\n\t\t\tprecision is specified, no more display cells than the\n\t\t\tnumber specified are used.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-f* *E807",
   "description": "f FThe Float argument is converted into a string of the\n\t\t\tform 123.456.  The precision specifies the number of\n\t\t\tdigits after the decimal point.  When the precision is\n\t\t\tzero the decimal point is omitted.  When the precision\n\t\t\tis not specified 6 is used.  A really big number\n\t\t\t(out of range or dividing by zero) results in \"inf\"\n\t\t\t or \"-inf\" with %f (INF or -INF with %F).\n\t\t\t \"0.0 / 0.0\" results in \"nan\" with %f (NAN with %F).\n\t\t\tExample: >\n\t\t\t\techo printf(\"%.2f\", 12.115)\n<\t\t\t\t12.12\n\t\t\tNote that roundoff depends on the system libraries.\n\t\t\tUse |round()| when in doubt.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-e* *printf-E",
   "description": "e EThe Float argument is converted into a string of the\n\t\t\tform 1.234e+03 or 1.234E+03 when using 'E'.  The\n\t\t\tprecision specifies the number of digits after the\n\t\t\tdecimal point, like with 'f'.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-g* *printf-G",
   "description": "g GThe Float argument is converted like with 'f' if the\n\t\t\tvalue is between 0.001 (inclusive) and 10000000.0\n\t\t\t(exclusive).  Otherwise 'e' is used for 'g' and 'E'\n\t\t\tfor 'G'.  When no precision is specified superfluous\n\t\t\tzeroes and '+' signs are removed, except for the zero\n\t\t\timmediately after the decimal point.  Thus 10000000.0\n\t\t\tresults in 1.0e7.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-%",
   "description": "%A '%' is written.  No argument is converted.  The\n\t\t\tcomplete conversion specification is \"%%\".\n\n\t\tWhen a Number argument is expected a String argument is also\n\t\taccepted and automatically converted.\n\t\tWhen a Float or String argument is expected a Number argument\n\t\tis also accepted and automatically converted.\n\t\tAny other argument type results in an error message.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "E766* *E767",
   "description": "The number of {exprN} arguments must exactly match the number\n\t\tof \"%\" items.  If there are not sufficient or too many\n\t\targuments an error is given.  Up to 18 arguments can be used.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "prompt_getprompt",
   "description": "\t\tReturns the effective prompt text for buffer {buf}.  {buf} can\n\t\tbe a buffer name or number.  See |prompt-buffer|.\n\n\t\tIf the buffer doesn't exist or isn't a prompt buffer, an empty\n\t\tstring is returned.",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prompt_setcallback",
   "description": "\t\tSet prompt callback for buffer {buf} to {expr}.  When {expr}\n\t\tis an empty string the callback is removed.  This has only\n\t\teffect if {buf} has 'buftype' set to \"prompt\".\n\n\t\tThe callback is invoked when pressing Enter.  The current\n\t\tbuffer will always be the prompt buffer.  A new line for a\n\t\tprompt is added before invoking the callback, thus the prompt\n\t\tfor which the callback was invoked will be in the last but one\n\t\tline.\n\t\tIf the callback wants to add text to the buffer, it must\n\t\tinsert it above the last line, since that is where the current\n\t\tprompt is.  This can also be done asynchronously.\n\t\tThe callback is invoked with one argument, which is the text\n\t\tthat was entered at the prompt.  This can be an empty string\n\t\tif the user only typed Enter.\n\t\tExample: >\n\t\t   call prompt_setcallback(bufnr(''), function('s:TextEntered'))\n\t\t   func s:TextEntered(text)\n\t\t     if a:text == 'exit' || a:text == 'quit'\n\t\t       stopinsert\n\t\t       close\n\t\t     else\n\t\t       call append(line('$') - 1, 'Entered: \"' . a:text . '\"')\n\t\t       \" Reset 'modified' to allow the buffer to be closed.\n\t\t       set nomodified\n\t\t     endif\n\t\t   endfunc",
   "argsStr": "{buf}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prompt_setinterrupt",
   "description": "\t\tSet a callback for buffer {buf} to {expr}.  When {expr} is an\n\t\tempty string the callback is removed.  This has only effect if\n\t\t{buf} has 'buftype' set to \"prompt\".\n\n\t\tThis callback will be invoked when pressing CTRL-C in Insert\n\t\tmode.  Without setting a callback Vim will exit Insert mode,\n\t\tas in any buffer.",
   "argsStr": "{buf}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prompt_setprompt",
   "description": "\t\tSet prompt for buffer {buf} to {text}.  You most likely want\n\t\t{text} to end in a space.\n\t\tThe result is only visible if {buf} has 'buftype' set to\n\t\t\"prompt\".  Example: >\n\t\t\tcall prompt_setprompt(bufnr(''), 'command: ')",
   "argsStr": "{buf}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pum_getpos",
   "description": "\t\tIf the popup menu (see |ins-completion-menu|) is not visible,\n\t\treturns an empty |Dictionary|, otherwise, returns a\n\t\t|Dictionary| with the following keys:\n\t\t\theight\t\tnr of items visible\n\t\t\twidth\t\tscreen cells\n\t\t\trow\t\ttop screen row (0 first row)\n\t\t\tcol\t\tleftmost screen column (0 first col)\n\t\t\tsize\t\ttotal nr of items\n\t\t\tscrollbar\t|TRUE| if scrollbar is visible\n\n  \t\tThe values are the same as in |v:event| during |CompleteChanged|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pumvisible",
   "description": "\t\tReturns non-zero when the popup menu is visible, zero\n\t\totherwise.  See |ins-completion-menu|.\n\t\tThis can be used to avoid some things that would remove the\n\t\tpopup menu.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "py3eval",
   "description": "\t\tEvaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though, Unicode strings are additionally converted to\n\t\tUTF-8).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type with\n\t\tkeys converted to strings.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pyeval",
   "description": "*pyeval()*\n\t\tEvaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type,\n\t\tnon-string keys result in error.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pyxeval",
   "description": "\t\tEvaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tUses Python 2 or 3, see |python_x| and 'pyxversion'.\n\t\tSee also: |pyeval()|, |py3eval()|",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "range",
   "description": "*range()*\n\t\tReturns a |List| with Numbers:\n\t\t- If only {expr} is specified: [0, 1, ..., {expr} - 1]\n\t\t- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]\n\t\t- If {stride} is specified: [{expr}, {expr} + {stride}, ...,\n\t\t  {max}] (increasing {expr} with {stride} each time, not\n\t\t  producing a value past {max}).\n\t\tWhen the maximum is one before the start the result is an\n\t\tempty list.  When the maximum is more than one before the\n\t\tstart this is an error.\n\t\tExamples: >\n\t\t\trange(4)\t\t\" [0, 1, 2, 3]\n\t\t\trange(2, 4)\t\t\" [2, 3, 4]\n\t\t\trange(2, 9, 3)\t\t\" [2, 5, 8]\n\t\t\trange(2, -2, -1)\t\" [2, 1, 0, -1, -2]\n\t\t\trange(0)\t\t\" []\n\t\t\trange(2, 0)\t\t\" error!\n<",
   "argsStr": "{expr} [, {max} [, {stride}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "readdir",
   "description": "\t\tReturn a list with file and directory names in {directory}.\n\n\t\tWhen {expr} is omitted all entries are included.\n\t\tWhen {expr} is given, it is evaluated to check what to do:\n\t\t\tIf {expr} results in -1 then no further entries will\n\t\t\tbe handled.\n\t\t\tIf {expr} results in 0 then this entry will not be\n\t\t\tadded to the list.\n\t\t\tIf {expr} results in 1 then this entry will be added\n\t\t\tto the list.\n\t\tEach time {expr} is evaluated |v:val| is set to the entry name.\n\t\tWhen {expr} is a function the name is passed as the argument.\n\t\tFor example, to get a list of files ending in \".txt\": >\n\t\t  readdir(dirname, {n -> n =~ '.txt$'})\n<\t\tTo skip hidden and backup files: >\n\t\t  readdir(dirname, {n -> n !~ '^\\.\\|\\~$'})\n\n<\t\tIf you want to get a directory tree: >\n                  function! s:tree(dir)\n                      return {a:dir : map(readdir(a:dir),\n\t\t      \\ {_, x -> isdirectory(x) ?\n\t\t      \\          {x : s:tree(a:dir . '/' . x)} : x})}\n                  endfunction\n                  echo s:tree(\".\")\n<",
   "argsStr": "{directory} [, {expr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "readfile",
   "description": "\t\tRead file {fname} and return a |List|, each line of the file\n\t\tas an item.  Lines are broken at NL characters.  Macintosh\n\t\tfiles separated with CR will result in a single long line\n\t\t(unless a NL appears somewhere).\n\t\tAll NUL characters are replaced with a NL character.\n\t\tWhen {type} contains \"b\" binary mode is used:\n\t\t- When the last line ends in a NL an extra empty list item is\n\t\t  added.\n\t\t- No CR characters are removed.\n\t\tWhen {type} contains \"B\" a |Blob| is returned with the binary\n\t\tdata of the file unmodified.\n\t\tOtherwise:\n\t\t- CR characters that appear before a NL are removed.\n\t\t- Whether the last line ends in a NL or not does not matter.\n\t\t- Any UTF-8 byte order mark is removed from the text.\n\t\tWhen {max} is given this specifies the maximum number of lines\n\t\tto be read.  Useful if you only want to check the first ten\n\t\tlines of a file: >\n\t\t\t:for line in readfile(fname, '', 10)\n\t\t\t:  if line =~ 'Date' | echo line | endif\n\t\t\t:endfor\n<\t\tWhen {max} is negative -{max} lines from the end of the file\n\t\tare returned, or as many as there are.\n\t\tWhen {max} is zero the result is an empty list.\n\t\tNote that without {max} the whole file is read into memory.\n\t\tAlso note that there is no recognition of encoding.  Read a\n\t\tfile into a buffer if you need to.\n\t\tWhen the file can't be opened an error message is given and\n\t\tthe result is an empty list.\n\t\tAlso see |writefile()|.",
   "argsStr": "{fname} [, {type} [, {max}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reg_executing",
   "description": "\t\tReturns the single letter name of the register being executed.\n\t\tReturns an empty string when no register is being executed.\n\t\tSee |@|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reg_recording",
   "description": "\t\tReturns the single letter name of the register being recorded.\n\t\tReturns an empty string string when not recording.  See |q|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltime",
   "description": "\t\tReturn an item that represents a time value.  The item is a\n\t\tlist with items that depend on the system.\n\t\tThe item can be passed to |reltimestr()| to convert it to a\n\t\tstring or |reltimefloat()| to convert to a Float.\n\n\t\tWithout an argument it returns the current \"relative time\", an\n\t\timplementation-defined value meaningful only when used as an\n\t\targument to |reltime()|, |reltimestr()| and |reltimefloat()|.\n\n\t\tWith one argument it returns the time passed since the time\n\t\tspecified in the argument.\n\t\tWith two arguments it returns the time passed between {start}\n\t\tand {end}.\n\n\t\tThe {start} and {end} arguments must be values returned by\n\t\treltime().\n\n\t\tNote: |localtime()| returns the current (non-relative) time.",
   "argsStr": "[{start} [, {end}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltimefloat",
   "description": "\t\tReturn a Float that represents the time value of {time}.\n\t\tUnit of time is seconds.\n\t\tExample:\n\t\t\tlet start = reltime()\n\t\t\tcall MyFunction()\n\t\t\tlet seconds = reltimefloat(reltime(start))\n\t\tSee the note of reltimestr() about overhead.\n\t\tAlso see |profiling|.\n\t\tIf there is an error an empty string is returned",
   "argsStr": "{time}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltimestr",
   "description": "\t\tReturn a String that represents the time value of {time}.\n\t\tThis is the number of seconds, a dot and the number of\n\t\tmicroseconds.  Example: >\n\t\t\tlet start = reltime()\n\t\t\tcall MyFunction()\n\t\t\techo reltimestr(reltime(start))\n<\t\tNote that overhead for the commands will be added to the time.\n\t\tLeading spaces are used to make the string align nicely.  You\n\t\tcan use split() to remove it. >\n\t\t\techo split(reltimestr(reltime(start)))[0]\n<\t\tAlso see |profiling|.\n\t\tIf there is an error an empty string is returned",
   "argsStr": "{time}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_expr",
   "description": "\t\tSend the {string} to {server}.  The string is sent as an\n\t\texpression and the result is returned after evaluation.\n\t\tThe result must be a String or a |List|.  A |List| is turned\n\t\tinto a String by joining the items with a line break in\n\t\tbetween (not at the end), like with join(expr, \"\\n\").\n\t\tIf {idvar} is present and not empty, it is taken as the name\n\t\tof a variable and a {serverid} for later use with\n\t\t|remote_read()| is stored there.\n\t\tIf {timeout} is given the read times out after this many\n\t\tseconds.  Otherwise a timeout of 600 seconds is used.\n\t\tSee also |clientserver| |RemoteReply|.\n\t\tThis function is not available in the |sandbox|.\n\t\tNote: Any errors will cause a local error message to be issued\n\t\tand the result will be the empty string.\n\n\t\tVariables will be evaluated in the global namespace,\n\t\tindependent of a function currently being active.  Except\n\t\twhen in debug mode, then local function variables and\n\t\targuments can be evaluated.\n\n\t\tExamples: >\n\t\t\t:echo remote_expr(\"gvim\", \"2+2\")\n\t\t\t:echo remote_expr(\"gvim1\", \"b:current_syntax\")\n<",
   "argsStr": "{server}, {string} [, {idvar} [, {timeout}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_foreground",
   "description": "\t\tMove the Vim server with the name {server} to the foreground.\n\t\tThe {server} argument is a string.\n\t\tThis works like: >\n\t\t\tremote_expr({server}, \"foreground()\")\n<\t\tExcept that on Win32 systems the client does the work, to work\n\t\taround the problem that the OS doesn't always allow the server\n\t\tto bring itself to the foreground.\n\t\tNote: This does not restore the window if it was minimized,\n\t\tlike foreground() does.\n\t\tThis function is not available in the |sandbox|.\n\t\t{only in the Win32 GUI and the Win32 console version}",
   "argsStr": "{server}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_peek",
   "description": "\t\tReturns a positive number if there are available strings\n\t\tfrom {serverid}.  Copies any reply string into the variable\n\t\t{retvar} if specified.  {retvar} must be a string with the\n\t\tname of a variable.\n\t\tReturns zero if none are available.\n\t\tReturns -1 if something is wrong.\n\t\tSee also |clientserver|.\n\t\tThis function is not available in the |sandbox|.\n\t\tExamples: >\n\t\t\t:let repl = \"\"\n\t\t\t:echo \"PEEK: \".remote_peek(id, \"repl\").\": \".repl",
   "argsStr": "{serverid} [, {retvar}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_read",
   "description": "\t\tReturn the oldest available reply from {serverid} and consume\n\t\tit.  Unless a {timeout} in seconds is given, it blocks until a\n\t\treply is available.\n\t\tSee also |clientserver|.\n\t\tThis function is not available in the |sandbox|.\n\t\tExample: >\n\t\t\t:echo remote_read(id)\n<",
   "argsStr": "{serverid}, [{timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_send",
   "description": "\t\tSend the {string} to {server}.  The string is sent as input\n\t\tkeys and the function returns immediately.  At the Vim server\n\t\tthe keys are not mapped |:map|.\n\t\tIf {idvar} is present, it is taken as the name of a variable\n\t\tand a {serverid} for later use with remote_read() is stored\n\t\tthere.\n\t\tSee also |clientserver| |RemoteReply|.\n\t\tThis function is not available in the |sandbox|.\n\n\t\tNote: Any errors will be reported in the server and may mess\n\t\tup the display.\n\t\tExamples: >\n\t\t:echo remote_send(\"gvim\", \":DropAndReply \".file, \"serverid\").\n\t\t \\ remote_read(serverid)\n\n\t\t:autocmd NONE RemoteReply *\n\t\t \\ echo remote_read(expand(\"<amatch>\"))\n\t\t:echo remote_send(\"gvim\", \":sleep 10 | echo \".\n\t\t \\ 'server2client(expand(\"<client>\"), \"HELLO\")<CR>')\n<",
   "argsStr": "{server}, {string} [, {idvar}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_startserver",
   "description": "\t\tBecome the server {name}.  This fails if already running as a\n\t\tserver, when |v:servername| is not empty.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remove",
   "description": "\t\tWithout {end}: Remove the item at {idx} from |List| {list} and\n\t\treturn the item.\n\t\tWith {end}: Remove items from {idx} to {end} (inclusive) and\n\t\treturn a |List| with these items.  When {idx} points to the same\n\t\titem as {end} a list with one item is returned.  When {end}\n\t\tpoints to an item before {idx} this is an error.\n\t\tSee |list-index| for possible values of {idx} and {end}.\n\t\tExample: >\n\t\t\t:echo \"last item: \" . remove(mylist, -1)\n\t\t\t:call remove(mylist, 0, 9)\n\n<\t\tCan also be used as a |method|: >\n\t\t\tmylist->remove(idx)\n\nremove({blob}, {idx} [, {end}])\n\t\tWithout {end}: Remove the byte at {idx} from |Blob| {blob} and\n\t\treturn the byte.\n\t\tWith {end}: Remove bytes from {idx} to {end} (inclusive) and\n\t\treturn a |Blob| with these bytes.  When {idx} points to the same\n\t\tbyte as {end} a |Blob| with one byte is returned.  When {end}\n\t\tpoints to a byte before {idx} this is an error.\n\t\tExample: >\n\t\t\t:echo \"last byte: \" . remove(myblob, -1)\n\t\t\t:call remove(mylist, 0, 9)\n\nremove({dict}, {key})\n\t\tRemove the entry from {dict} with key {key} and return it.\n\t\tExample: >\n\t\t\t:echo \"removed \" . remove(dict, \"one\")\n<\t\tIf there is no {key} in {dict} this is an error.\n\n\t\tUse |delete()| to remove a file.",
   "argsStr": "{list}, {idx} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rename",
   "description": "\t\tRename the file by the name {from} to the name {to}.  This\n\t\tshould also work to move files across file systems.  The\n\t\tresult is a Number, which is 0 if the file was renamed\n\t\tsuccessfully, and non-zero when the renaming failed.\n\t\tNOTE: If {to} exists it is overwritten without warning.\n\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{from}, {to}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "repeat",
   "description": "\t\tRepeat {expr} {count} times and return the concatenated\n\t\tresult.  Example: >\n\t\t\t:let separator = repeat('-', 80)\n<\t\tWhen {count} is zero or negative the result is empty.\n\t\tWhen {expr} is a |List| the result is {expr} concatenated\n\t\t{count} times.  Example: >\n\t\t\t:let longlist = repeat(['a', 'b'], 3)\n<\t\tResults in ['a', 'b', 'a', 'b', 'a', 'b'].\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->repeat(count)",
   "argsStr": "{expr}, {count}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "resolve",
   "description": "\t\tOn MS-Windows, when {filename} is a shortcut (a .lnk file),\n\t\treturns the path the shortcut points to in a simplified form.\n\t\tOn Unix, repeat resolving symbolic links in all path\n\t\tcomponents of {filename} and return the simplified result.\n\t\tTo cope with link cycles, resolving of symbolic links is\n\t\tstopped after 100 iterations.\n\t\tOn other systems, return the simplified {filename}.\n\t\tThe simplification step is done as by |simplify()|.\n\t\tresolve() keeps a leading path component specifying the\n\t\tcurrent directory (provided the result is still a relative\n\t\tpath name) and also keeps a trailing path separator.",
   "argsStr": "{filename}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reverse",
   "description": "\t\tReverse the order of items in {object} in-place.\n\t\t{object} can be a |List| or a |Blob|.\n\t\tReturns {object}.\n\t\tIf you want an object to remain unmodified make a copy first: >\n\t\t\t:let revlist = reverse(copy(mylist))\n<\t\tCan also be used as a |method|: >\n\t\t\tmylist->reverse()",
   "argsStr": "{object}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "round",
   "description": "\t\tRound off {expr} to the nearest integral value and return it\n\t\tas a |Float|.  If {expr} lies halfway between two integral\n\t\tvalues, then use the larger one (away from zero).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo round(0.456)\n<\t\t\t0.0  >\n\t\t\techo round(4.5)\n<\t\t\t5.0 >\n\t\t\techo round(-4.5)\n<\t\t\t-5.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->round()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcnotify",
   "description": "\t\tSends {event} to {channel} via |RPC| and returns immediately.\n\t\tIf {channel} is 0, the event is broadcast to all channels.\n\t\tExample: >\n\t\t\t:au VimLeave call rpcnotify(0, \"leaving\")",
   "argsStr": "{channel}, {event}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcrequest",
   "description": "\t\tSends a request to {channel} to invoke {method} via\n\t\t|RPC| and blocks until a response is received.\n\t\tExample: >\n\t\t\t:let result = rpcrequest(rpc_chan, \"func\", 1, 2, 3)",
   "argsStr": "{channel}, {method}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcstart",
   "description": "\t\tDeprecated. Replace  >\n\t\t\t:let id = rpcstart('prog', ['arg1', 'arg2'])\n<\t\twith >\n\t\t\t:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})",
   "argsStr": "{prog}[, {argv}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rubyeval",
   "description": "\t\tEvaluate Ruby expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers, floats and strings are returned as they are (strings\n\t\tare copied though).\n\t\tArrays are represented as Vim |List| type.\n\t\tHashes are represented as Vim |Dictionary| type.\n\t\tOther objects are represented as strings resulted from their\n\t\t\"Object#to_s\" method.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenattr",
   "description": "\t\tLike |screenchar()|, but return the attribute.  This is a rather\n\t\tarbitrary number that can only be used to compare to the\n\t\tattribute at other positions.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenchar",
   "description": "\t\tThe result is a Number, which is the character at position\n\t\t[row, col] on the screen.  This works for every possible\n\t\tscreen position, also status lines, window separators and the\n\t\tcommand line.  The top left position is row one, column one\n\t\tThe character excludes composing characters.  For double-byte\n\t\tencodings it may only be the first byte.\n\t\tThis is mainly to be used for testing.\n\t\tReturns -1 when row or col is out of range.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenchars",
   "description": "\t\tThe result is a List of Numbers.  The first number is the same\n\t\tas what |screenchar()| returns.  Further numbers are\n\t\tcomposing characters on top of the base character.\n\t\tThis is mainly to be used for testing.\n\t\tReturns an empty List when row or col is out of range.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screencol",
   "description": "\t\tThe result is a Number, which is the current screen column of\n\t\tthe cursor. The leftmost column has number 1.\n\t\tThis function is mainly used for testing.\n\n\t\tNote: Always returns the current screen column, thus if used\n\t\tin a command (e.g. \":echo screencol()\") it will return the\n\t\tcolumn inside the command line, which is 1 when the command is\n\t\texecuted. To get the cursor position in the file use one of\n\t\tthe following mappings: >\n\t\t\tnnoremap <expr> GG \":echom \".screencol().\"\\n\"\n\t\t\tnnoremap <silent> GG :echom screencol()<CR>\n\t\t\tnoremap GG <Cmd>echom screencol()<Cr>\n<",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenpos",
   "description": "\t\tThe result is a Dict with the screen position of the text\n\t\tcharacter in window {winid} at buffer line {lnum} and column\n\t\t{col}.  {col} is a one-based byte index.\n\t\tThe Dict has these members:\n\t\t\trow\tscreen row\n\t\t\tcol\tfirst screen column\n\t\t\tendcol\tlast screen column\n\t\t\tcurscol\tcursor screen column\n\t\tIf the specified position is not visible, all values are zero.\n\t\tThe \"endcol\" value differs from \"col\" when the character\n\t\toccupies more than one screen cell.  E.g. for a Tab \"col\" can\n\t\tbe 1 and \"endcol\" can be 8.\n\t\tThe \"curscol\" value is where the cursor would be placed.  For\n\t\ta Tab it would be the same as \"endcol\", while for a double\n\t\twidth character it would be the same as \"col\".\n\t\tThe |conceal| feature is ignored here, the column numbers are\n \t\tas if 'conceallevel' is zero.  You can set the cursor to the\n \t\tright position and use |screencol()| to get the value with\n \t\t|conceal| taken into account.",
   "argsStr": "{winid}, {lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenrow",
   "description": "\t\tThe result is a Number, which is the current screen row of the\n\t\tcursor.  The top line has number one.\n\t\tThis function is mainly used for testing.\n\t\tAlternatively you can use |winline()|.\n\n\t\tNote: Same restrictions as with |screencol()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenstring",
   "description": "\t\tThe result is a String that contains the base character and\n\t\tany composing characters at position [row, col] on the screen.\n\t\tThis is like |screenchars()| but returning a String with the\n\t\tcharacters.\n\t\tThis is mainly to be used for testing.\n\t\tReturns an empty String when row or col is out of range.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "search",
   "description": "\t\tSearch for regexp pattern {pattern}.  The search starts at the\n\t\tcursor position (you can use |cursor()| to set it).\n\n\t\tWhen a match has been found its line number is returned.\n\t\tIf there is no match a 0 is returned and the cursor doesn't\n\t\tmove.  No error message is given.\n\n\t\t{flags} is a String, which can contain these character flags:\n\t\t'b'\tsearch Backward instead of forward\n\t\t'c'\taccept a match at the Cursor position\n\t\t'e'\tmove to the End of the match\n\t\t'n'\tdo Not move the cursor\n\t\t'p'\treturn number of matching sub-Pattern (see below)\n\t\t's'\tSet the ' mark at the previous location of the cursor\n\t\t'w'\tWrap around the end of the file\n\t\t'W'\tdon't Wrap around the end of the file\n\t\t'z'\tstart searching at the cursor column instead of Zero\n\t\tIf neither 'w' or 'W' is given, the 'wrapscan' option applies.\n\n\t\tIf the 's' flag is supplied, the ' mark is set, only if the\n\t\tcursor is moved. The 's' flag cannot be combined with the 'n'\n\t\tflag.\n\n\t\t'ignorecase', 'smartcase' and 'magic' are used.\n\n\t\tWhen the 'z' flag is not given, forward searching always\n\t\tstarts in column zero and then matches before the cursor are\n\t\tskipped.  When the 'c' flag is present in 'cpo' the next\n\t\tsearch starts after the match.  Without the 'c' flag the next\n\t\tsearch starts one column further.  This matters for\n\t\toverlapping matches.\n\t\tWhen searching backwards and the 'z' flag is given then the\n\t\tsearch starts in column zero, thus no match in the current\n\t\tline will be found (unless wrapping around the end of the\n\t\tfile).\n\n\t\tWhen the {stopline} argument is given then the search stops\n\t\tafter searching this line.  This is useful to restrict the\n\t\tsearch to a range of lines.  Examples: >\n\t\t\tlet match = search('(', 'b', line(\"w0\"))\n\t\t\tlet end = search('END', '', line(\"w$\"))\n<\t\tWhen {stopline} is used and it is not zero this also implies\n\t\tthat the search does not wrap around the end of the file.\n\t\tA zero value is equal to not giving the argument.\n\n\t\tWhen the {timeout} argument is given the search stops when\n\t\tmore than this many milliseconds have passed.  Thus when\n\t\t{timeout} is 500 the search stops after half a second.\n\t\tThe value must not be negative.  A zero value is like not\n\t\tgiving the argument.",
   "argsStr": "{pattern} [, {flags} [, {stopline} [, {timeout}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "search()-sub-match",
   "description": "With the 'p' flag the returned value is one more than the\n\t\tfirst sub-match in \\(\\).  One if none of them matched but the\n\t\twhole pattern did match.\n\t\tTo get the column number too use |searchpos()|.\n\n\t\tThe cursor will be positioned at the match, unless the 'n'\n\t\tflag is used.\n\n\t\tExample (goes over all files in the argument list): >\n\t\t    :let n = 1\n\t\t    :while n <= argc()\t    \" loop over all files in arglist\n\t\t    :  exe \"argument \" . n\n\t\t    :  \" start at the last char in the file and wrap for the\n\t\t    :  \" first search to find match at start of file\n\t\t    :  normal G$\n\t\t    :  let flags = \"w\"\n\t\t    :  while search(\"foo\", flags) > 0\n\t\t    :\t s/foo/bar/g\n\t\t    :\t let flags = \"W\"\n\t\t    :  endwhile\n\t\t    :  update\t\t    \" write the file if modified\n\t\t    :  let n = n + 1\n\t\t    :endwhile\n<\n\t\tExample for using some flags: >\n\t\t    :echo search('\\<if\\|\\(else\\)\\|\\(endif\\)', 'ncpe')\n<\t\tThis will search for the keywords \"if\", \"else\", and \"endif\"\n\t\tunder or after the cursor.  Because of the 'p' flag, it\n\t\treturns 1, 2, or 3 depending on which keyword is found, or 0\n\t\tif the search fails.  With the cursor on the first word of the\n\t\tline:\n\t\t    if (foo == 0) | let foo = foo + 1 | endif ~\n\t\tthe function returns 1.  Without the 'c' flag, the function\n\t\tfinds the \"endif\" and returns 3.  The same thing happens\n\t\twithout the 'e' flag if the cursor is on the \"f\" of \"if\".\n\t\tThe 'n' flag tells the function not to move the cursor.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchcount",
   "description": "\t\tGet or update the last search count, like what is displayed\n\t\twithout the \"S\" flag in 'shortmess'.  This works even if\n\t\t'shortmess' does contain the \"S\" flag.\n\n\t\tThis returns a Dictionary. The dictionary is empty if the\n\t\tprevious pattern was not set and \"pattern\" was not specified.\n\n\t\t  key\t\ttype\t\tmeaning ~\n\t\t  current\t|Number|\tcurrent position of match;\n\t\t\t\t\t\t0 if the cursor position is\n\t\t\t\t\t\tbefore the first match\n\t\t  exact_match\t|Boolean|\t1 if \"current\" is matched on\n\t\t\t\t\t\t\"pos\", otherwise 0\n\t\t  total\t\t|Number|\ttotal count of matches found\n\t\t  incomplete\t|Number|\t0: search was fully completed\n\t\t\t\t\t\t1: recomputing was timed out\n\t\t\t\t\t\t2: max count exceeded\n\n\t\tFor {options} see further down.\n\n\t\tTo get the last search count when |n| or |N| was pressed, call\n\t\tthis function with `recompute: 0` . This sometimes returns\n\t\twrong information because |n| and |N|'s maximum count is 99.\n\t\tIf it exceeded 99 the result must be max count + 1 (100). If\n\t\tyou want to get correct information, specify `recompute: 1`: >\n\n\t\t\t\" result == maxcount + 1 (100) when many matches\n\t\t\tlet result = searchcount(#{recompute: 0})\n\n\t\t\t\" Below returns correct result (recompute defaults\n\t\t\t\" to 1)\n\t\t\tlet result = searchcount()\n<\n\t\tThe function is useful to add the count to |statusline|: >\n\t\t\tfunction! LastSearchCount() abort\n\t\t\t  let result = searchcount(#{recompute: 0})\n\t\t\t  if empty(result)\n\t\t\t    return ''\n\t\t\t  endif\n\t\t\t  if result.incomplete ==# 1     \" timed out\n\t\t\t    return printf(' /%s [?/??]', @/)\n\t\t\t  elseif result.incomplete ==# 2 \" max count exceeded\n\t\t\t    if result.total > result.maxcount &&\n\t\t\t    \\  result.current > result.maxcount\n\t\t\t      return printf(' /%s [>%d/>%d]', @/,\n\t\t\t      \\             result.current, result.total)\n\t\t\t    elseif result.total > result.maxcount\n\t\t\t      return printf(' /%s [%d/>%d]', @/,\n\t\t\t      \\             result.current, result.total)\n\t\t\t    endif\n\t\t\t  endif\n\t\t\t  return printf(' /%s [%d/%d]', @/,\n\t\t\t  \\             result.current, result.total)\n\t\t\tendfunction\n\t\t\tlet &statusline .= '%{LastSearchCount()}'\n\n\t\t\t\" Or if you want to show the count only when\n\t\t\t\" 'hlsearch' was on\n\t\t\t\" let &statusline .=\n\t\t\t\" \\   '%{v:hlsearch ? LastSearchCount() : \"\"}'\n<\n\t\tYou can also update the search count, which can be useful in a\n\t\t|CursorMoved| or |CursorMovedI| autocommand: >\n\n\t\t\tautocmd CursorMoved,CursorMovedI *\n\t\t\t  \\ let s:searchcount_timer = timer_start(\n\t\t\t  \\   200, function('s:update_searchcount'))\n\t\t\tfunction! s:update_searchcount(timer) abort\n\t\t\t  if a:timer ==# s:searchcount_timer\n\t\t\t    call searchcount(#{\n\t\t\t    \\ recompute: 1, maxcount: 0, timeout: 100})\n\t\t\t    redrawstatus\n\t\t\t  endif\n\t\t\tendfunction\n<\n\t\tThis can also be used to count matched texts with specified\n\t\tpattern in the current buffer using \"pattern\":  >\n\n\t\t\t\" Count '\\<foo\\>' in this buffer\n\t\t\t\" (Note that it also updates search count)\n\t\t\tlet result = searchcount(#{pattern: '\\<foo\\>'})\n\n\t\t\t\" To restore old search count by old pattern,\n\t\t\t\" search again\n\t\t\tcall searchcount()\n<\n\t\t{options} must be a Dictionary. It can contain:\n\t\t  key\t\ttype\t\tmeaning ~\n\t\t  recompute\t|Boolean|\tif |TRUE|, recompute the count\n\t\t\t\t\t\tlike |n| or |N| was executed.\n\t\t\t\t\t\totherwise returns the last\n\t\t\t\t\t\tresult by |n|, |N|, or this\n\t\t\t\t\t\tfunction is returned.\n\t\t\t\t\t\t(default: |TRUE|)\n\t\t  pattern\t|String|\trecompute if this was given\n\t\t\t\t\t\tand different with |@/|.\n\t\t\t\t\t\tthis works as same as the\n\t\t\t\t\t\tbelow command is executed\n\t\t\t\t\t\tbefore calling this function >\n\t\t\t\t\t\t  let @/ = pattern\n<\t\t\t\t\t\t(default: |@/|)\n\t\t  timeout\t|Number|\t0 or negative number is no\n\t\t\t\t\t\ttimeout. timeout milliseconds\n\t\t\t\t\t\tfor recomputing the result\n\t\t\t\t\t\t(default: 0)\n\t\t  maxcount\t|Number|\t0 or negative number is no\n\t\t\t\t\t\tlimit. max count of matched\n\t\t\t\t\t\ttext while recomputing the\n\t\t\t\t\t\tresult.  if search exceeded\n\t\t\t\t\t\ttotal count, \"total\" value\n\t\t\t\t\t\tbecomes `maxcount + 1`\n\t\t\t\t\t\t(default: 0)\n\t\t  pos\t\t|List|\t\t`[lnum, col, off]` value\n\t\t\t\t\t\twhen recomputing the result.\n\t\t\t\t\t\tthis changes \"current\" result\n\t\t\t\t\t\tvalue. see |cursor()|, |getpos()\n\t\t\t\t\t\t(default: cursor's position)",
   "argsStr": "[{options}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchdecl",
   "description": "\t\tSearch for the declaration of {name}.\n\n\t\tWith a non-zero {global} argument it works like |gD|, find\n\t\tfirst match in the file.  Otherwise it works like |gd|, find\n\t\tfirst match in the function.\n\n\t\tWith a non-zero {thisblock} argument matches in a {} block\n\t\tthat ends before the cursor position are ignored.  Avoids\n\t\tfinding variable declarations only valid in another scope.\n\n\t\tMoves the cursor to the found match.\n\t\tReturns zero for success, non-zero for failure.\n\t\tExample: >\n\t\t\tif searchdecl('myvar') == 0\n\t\t\t   echo getline('.')\n\t\t\tendif\n<",
   "argsStr": "{name} [, {global} [, {thisblock}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpair",
   "description": "\t\t\t\t[, {stopline} [, {timeout}]]]])\n\t\tSearch for the match of a nested start-end pair.  This can be\n\t\tused to find the \"endif\" that matches an \"if\", while other\n\t\tif/endif pairs in between are ignored.\n\t\tThe search starts at the cursor.  The default is to search\n\t\tforward, include 'b' in {flags} to search backward.\n\t\tIf a match is found, the cursor is positioned at it and the\n\t\tline number is returned.  If no match is found 0 or -1 is\n\t\treturned and the cursor doesn't move.  No error message is\n\t\tgiven.\n\n\t\t{start}, {middle} and {end} are patterns, see |pattern|.  They\n\t\tmust not contain \\( \\) pairs.  Use of \\%( \\) is allowed.  When\n\t\t{middle} is not empty, it is found when searching from either\n\t\tdirection, but only when not in a nested start-end pair.  A\n\t\ttypical use is: >\n\t\t\tsearchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>')\n<\t\tBy leaving {middle} empty the \"else\" is skipped.\n\n\t\t{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with\n\t\t|search()|.  Additionally:\n\t\t'r'\tRepeat until no more matches found; will find the\n\t\t\touter pair.  Implies the 'W' flag.\n\t\t'm'\tReturn number of matches instead of line number with\n\t\t\tthe match; will be > 1 when 'r' is used.\n\t\tNote: it's nearly always a good idea to use the 'W' flag, to\n\t\tavoid wrapping around the end of the file.\n\n\t\tWhen a match for {start}, {middle} or {end} is found, the\n\t\t{skip} expression is evaluated with the cursor positioned on\n\t\tthe start of the match.  It should return non-zero if this\n\t\tmatch is to be skipped.  E.g., because it is inside a comment\n\t\tor a string.\n\t\tWhen {skip} is omitted or empty, every match is accepted.\n\t\tWhen evaluating {skip} causes an error the search is aborted\n\t\tand -1 returned.\n \t\t{skip} can be a string, a lambda, a funcref or a partial.\n\t\tAnything else makes the function fail.\n\n\t\tFor {stopline} and {timeout} see |search()|.\n\n\t\tThe value of 'ignorecase' is used.  'magic' is ignored, the\n\t\tpatterns are used like it's on.\n\n\t\tThe search starts exactly at the cursor.  A match with\n\t\t{start}, {middle} or {end} at the next character, in the\n\t\tdirection of searching, is the first one found.  Example: >\n\t\t\tif 1\n\t\t\t  if 2\n\t\t\t  endif 2\n\t\t\tendif 1\n<\t\tWhen starting at the \"if 2\", with the cursor on the \"i\", and\n\t\tsearching forwards, the \"endif 2\" is found.  When starting on\n\t\tthe character just before the \"if 2\", the \"endif 1\" will be\n\t\tfound.  That's because the \"if 2\" will be found first, and\n\t\tthen this is considered to be a nested if/endif from \"if 2\" to\n\t\t\"endif 2\".\n\t\tWhen searching backwards and {end} is more than one character,\n\t\tit may be useful to put \"\\zs\" at the end of the pattern, so\n\t\tthat when the cursor is inside a match with the end it finds\n\t\tthe matching start.\n\n\t\tExample, to find the \"endif\" command in a Vim script: >\n\n\t:echo searchpair('\\<if\\>', '\\<el\\%[seif]\\>', '\\<en\\%[dif]\\>', 'W',\n\t\t\t\\ 'getline(\".\") =~ \"^\\\\s*\\\"\"')\n\n<\t\tThe cursor must be at or after the \"if\" for which a match is\n\t\tto be found.  Note that single-quote strings are used to avoid\n\t\thaving to double the backslashes.  The skip expression only\n\t\tcatches comments at the start of a line, not after a command.\n\t\tAlso, a word \"en\" or \"if\" halfway through a line is considered\n\t\ta match.\n\t\tAnother example, to search for the matching \"{\" of a \"}\": >\n\n\t:echo searchpair('{', '', '}', 'bW')\n\n<\t\tThis works when the cursor is at or before the \"}\" for which a\n\t\tmatch is to be found.  To reject matches that syntax\n\t\thighlighting recognized as strings: >\n\n\t:echo searchpair('{', '', '}', 'bW',\n\t     \\ 'synIDattr(synID(line(\".\"), col(\".\"), 0), \"name\") =~? \"string\"')\n<",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpairpos",
   "description": "\t\t\t\t[, {stopline} [, {timeout}]]]])\n\t\tSame as |searchpair()|, but returns a |List| with the line and\n\t\tcolumn position of the match. The first element of the |List|\n\t\tis the line number and the second element is the byte index of\n\t\tthe column position of the match.  If no match is found,\n\t\treturns [0, 0]. >\n\n\t\t\t:let [lnum,col] = searchpairpos('{', '', '}', 'n')\n<\n\t\tSee |match-parens| for a bigger and more useful example.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpos",
   "description": "\t\tSame as |search()|, but returns a |List| with the line and\n\t\tcolumn position of the match. The first element of the |List|\n\t\tis the line number and the second element is the byte index of\n\t\tthe column position of the match. If no match is found,\n\t\treturns [0, 0].\n\t\tExample: >\n\t:let [lnum, col] = searchpos('mypattern', 'n')\n\n<\t\tWhen the 'p' flag is given then there is an extra item with\n\t\tthe sub-pattern match number |search()-sub-match|.  Example: >\n\t:let [lnum, col, submatch] = searchpos('\\(\\l\\)\\|\\(\\u\\)', 'np')\n<\t\tIn this example \"submatch\" is 2 when a lowercase letter is\n\t\tfound |/\\l|, 3 when an uppercase letter is found |/\\u|.",
   "argsStr": "{pattern} [, {flags} [, {stopline} [, {timeout}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "server2client",
   "description": "\t\tSend a reply string to {clientid}.  The most recent {clientid}\n\t\tthat sent a string can be retrieved with expand(\"<client>\").\n\t\tNote:\n\t\tReturns zero for success, -1 for failure.\n\t\tThis id has to be stored before the next command can be\n\t\treceived.  I.e. before returning from the received command and\n\t\tbefore calling any commands that waits for input.\n\t\tSee also |clientserver|.\n\t\tExample: >\n\t\t\t:echo server2client(expand(\"<client>\"), \"HELLO\")\n<",
   "argsStr": "{clientid}, {string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverlist",
   "description": "\t\tReturns a list of server addresses, or empty if all servers\n\t\twere stopped. |serverstart()| |serverstop()|\n\t\tExample: >\n\t\t\t:echo serverlist()",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverstart",
   "description": "\t\tOpens a socket or named pipe at {address} and listens for\n\t\t|RPC| messages. Clients can send |API| commands to the address\n\t\tto control Nvim. Returns the address string.\n\n\t\tIf {address} does not contain a colon \":\" it is interpreted as\n\t\ta named pipe or Unix domain socket path.\n\n\t\tExample: >\n\t\t\tif has('win32')\n\t\t\t  call serverstart('\\\\.\\pipe\\nvim-pipe-1234')\n\t\t\telse\n\t\t\t  call serverstart('nvim.sock')\n\t\t\tendif\n<\n\t\tIf {address} contains a colon \":\" it is interpreted as a TCP\n\t\taddress where the last \":\" separates the host and port.\n\t\tAssigns a random port if it is empty or 0. Supports IPv4/IPv6.\n\n\t\tExample: >\n\t\t\t:call serverstart('::1:12345')\n<\n\t\tIf no address is given, it is equivalent to: >\n\t\t\t:call serverstart(tempname())\n\n< \t\t|$NVIM_LISTEN_ADDRESS| is set to {address} if not already set.",
   "argsStr": "[{address}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverstop",
   "description": "\t\tCloses the pipe or socket at {address}.\n\t\tReturns TRUE if {address} is valid, else FALSE.\n\t\tIf |$NVIM_LISTEN_ADDRESS| is stopped it is unset.\n\t\tIf |v:servername| is stopped it is set to the next available\n\t\taddress returned by |serverlist()|.",
   "argsStr": "{address}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setbufline",
   "description": "\t\tSet line {lnum} to {text} in buffer {buf}.  This works like\n\t\t|setline()| for the specified buffer.\n\n\t\tThis function works only for loaded buffers. First call\n\t\t|bufload()| if needed.\n\n\t\tTo insert lines use |appendbufline()|.\n\t\tAny text properties in {lnum} are cleared.\n\n\t\t{text} can be a string to set one line, or a list of strings\n\t\tto set multiple lines.  If the list extends below the last\n\t\tline then those lines are added.\n\n\t\tFor the use of {buf}, see |bufname()| above.\n\n\t\t{lnum} is used like with |setline()|.\n\t\tWhen {lnum} is just below the last line the {text} will be\n\t\tadded below the last line.\n\t\tOn success 0 is returned, on failure 1 is returned.\n\n\t\tIf {buf} is not a valid buffer or {lnum} is not valid, an\n\t\terror message is given.",
   "argsStr": "{buf}, {lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setbufvar",
   "description": "\t\tSet option or local variable {varname} in buffer {buf} to\n\t\t{val}.\n\t\tThis also works for a global or local window option, but it\n\t\tdoesn't work for a global or local window variable.\n\t\tFor a local window option the global value is unchanged.\n\t\tFor the use of {buf}, see |bufname()| above.\n\t\tThe {varname} argument is a string.\n\t\tNote that the variable name without \"b:\" must be used.\n\t\tExamples: >\n\t\t\t:call setbufvar(1, \"&mod\", 1)\n\t\t\t:call setbufvar(\"todo\", \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{buf}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setcharsearch",
   "description": "\t\tSet the current character search information to {dict},\n\t\twhich contains one or more of the following entries:\n\n\t\t    char\tcharacter which will be used for a subsequent\n\t\t\t\t|,| or |;| command; an empty string clears the\n\t\t\t\tcharacter search\n\t\t    forward\tdirection of character search; 1 for forward,\n\t\t\t\t0 for backward\n\t\t    until\ttype of character search; 1 for a |t| or |T|\n\t\t\t\tcharacter search, 0 for an |f| or |F|\n\t\t\t\tcharacter search\n\n\t\tThis can be useful to save/restore a user's character search\n\t\tfrom a script: >\n\t\t\t:let prevsearch = getcharsearch()\n\t\t\t:\" Perform a command which clobbers user's search\n\t\t\t:call setcharsearch(prevsearch)\n<\t\tAlso see |getcharsearch()|.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setcmdpos",
   "description": "\t\tSet the cursor position in the command line to byte position\n\t\t{pos}.  The first position is 1.\n\t\tUse |getcmdpos()| to obtain the current position.\n\t\tOnly works while editing the command line, thus you must use\n\t\t|c_CTRL-\\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For\n\t\t|c_CTRL-\\_e| and |c_CTRL-R_CTRL-R| with '=' the position is\n\t\tset after the command line is set to the expression.  For\n\t\t|c_CTRL-R_=| it is set after evaluating the expression but\n\t\tbefore inserting the resulting text.\n\t\tWhen the number is too big the cursor is put at the end of the\n\t\tline.  A number smaller than one has undefined results.\n\t\tReturns FALSE when successful, TRUE when not editing the\n\t\tcommand line.",
   "argsStr": "{pos}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setenv",
   "description": "\t\tSet environment variable {name} to {val}.  Example: >\n\t\t\tcall setenv('HOME', '/home/myhome')\n\n<\t\tWhen {val} is |v:null| the environment variable is deleted.\n\t\tSee also |expr-env|.",
   "argsStr": "{name}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setfperm",
   "description": "\t\tSet the file permissions for {fname} to {mode}.\n\t\t{mode} must be a string with 9 characters.  It is of the form\n\t\t\"rwxrwxrwx\", where each group of \"rwx\" flags represent, in\n\t\tturn, the permissions of the owner of the file, the group the\n\t\tfile belongs to, and other users.  A '-' character means the\n\t\tpermission is off, any other character means on.  Multi-byte\n\t\tcharacters are not supported.\n\n\t\tFor example \"rw-r-----\" means read-write for the user,\n\t\treadable by the group, not accessible by others.  \"xx-x-----\"\n\t\twould do the same thing.\n\n\t\tReturns non-zero for success, zero for failure.\n\n\t\tTo read permissions see |getfperm()|.",
   "argsStr": "{fname}, {mode}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setline",
   "description": "\t\tSet line {lnum} of the current buffer to {text}.  To insert\n\t\tlines use |append()|. To set lines in another buffer use\n\t\t|setbufline()|.\n\n\t\t{lnum} is used like with |getline()|.\n\t\tWhen {lnum} is just below the last line the {text} will be\n\t\tadded below the last line.\n\n\t\tIf this succeeds, FALSE is returned.  If this fails (most likely\n\t\tbecause {lnum} is invalid) TRUE is returned.\n\n\t\tExample: >\n\t\t\t:call setline(5, strftime(\"%c\"))\n\n<\t\tWhen {text} is a |List| then line {lnum} and following lines\n\t\twill be set to the items in the list.  Example: >\n\t\t\t:call setline(5, ['aaa', 'bbb', 'ccc'])\n<\t\tThis is equivalent to: >\n\t\t\t:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]\n\t\t\t:  call setline(n, l)\n\t\t\t:endfor\n\n<\t\tNote: The '[ and '] marks are not set.",
   "argsStr": "{lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setloclist",
   "description": "\t\tCreate or replace or add to the location list for window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero the current window is used.\n\n\t\tFor a location list window, the displayed location list is\n\t\tmodified.  For an invalid window number {nr}, -1 is returned.\n\t\tOtherwise, same as |setqflist()|.\n\t\tAlso see |location-list|.\n\n\t\tFor {action} see |setqflist-action|.\n\n\t\tIf the optional {what} dictionary argument is supplied, then\n\t\tonly the items listed in {what} are set. Refer to |setqflist()|\n\t\tfor the list of supported keys in {what}.",
   "argsStr": "{nr}, {list}[, {action}[, {what}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setmatches",
   "description": "\t\tRestores a list of matches saved by |getmatches() for the\n\t\tcurrent window|.  Returns 0 if successful, otherwise -1.  All\n\t\tcurrent matches are cleared before the list is restored.  See\n\t\texample for |getmatches()|.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsStr": "{list} [, {win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setpos",
   "description": "\t\tSet the position for String {expr}.  Possible values:\n\t\t\t.\tthe cursor\n\t\t\t'x\tmark x\n\n\t\t{list} must be a |List| with four or five numbers:\n\t\t    [bufnum, lnum, col, off]\n\t\t    [bufnum, lnum, col, off, curswant]\n\n\t\t\"bufnum\" is the buffer number.\tZero can be used for the\n\t\tcurrent buffer.  When setting an uppercase mark \"bufnum\" is\n\t\tused for the mark position.  For other marks it specifies the\n\t\tbuffer to set the mark in.  You can use the |bufnr()| function\n\t\tto turn a file name into a buffer number.\n\t\tFor setting the cursor and the ' mark \"bufnum\" is ignored,\n\t\tsince these are associated with a window, not a buffer.\n\t\tDoes not change the jumplist.\n\n\t\t\"lnum\" and \"col\" are the position in the buffer.  The first\n\t\tcolumn is 1.  Use a zero \"lnum\" to delete a mark.  If \"col\" is\n\t\tsmaller than 1 then 1 is used.\n\n\t\tThe \"off\" number is only used when 'virtualedit' is set. Then\n\t\tit is the offset in screen columns from the start of the\n\t\tcharacter.  E.g., a position within a <Tab> or after the last\n\t\tcharacter.\n\n\t\tThe \"curswant\" number is only used when setting the cursor\n\t\tposition.  It sets the preferred column for when moving the\n\t\tcursor vertically.  When the \"curswant\" number is missing the\n\t\tpreferred column is not set.  When it is present and setting a\n\t\tmark position it is not used.\n\n\t\tNote that for '< and '> changing the line number may result in\n\t\tthe marks to be effectively be swapped, so that '< is always\n\t\tbefore '>.\n\n\t\tReturns 0 when the position could be set, -1 otherwise.\n\t\tAn error message is given if {expr} is invalid.\n\n\t\tAlso see |getpos()| and |getcurpos()|.\n\n\t\tThis does not restore the preferred column for moving\n\t\tvertically; if you set the cursor position with this, |j| and\n\t\t|k| motions will jump to previous columns!  Use |cursor()| to\n\t\talso set the preferred column.  Also see the \"curswant\" key in\n\t\t|winrestview()|.",
   "argsStr": "{expr}, {list}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setqflist",
   "description": "\t\tCreate or replace or add to the quickfix list.\n\n\t\tIf the optional {what} dictionary argument is supplied, then\n\t\tonly the items listed in {what} are set. The first {list}\n\t\targument is ignored.  See below for the supported items in\n\t\t{what}.",
   "argsStr": "{list} [, {action}[, {what}]]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "setqflist-what",
   "description": "When {what} is not present, the items in {list} are used.  Each\n\t\titem must be a dictionary.  Non-dictionary items in {list} are\n\t\tignored.  Each dictionary item can contain the following\n\t\tentries:\n\n\t\t    bufnr\tbuffer number; must be the number of a valid\n\t\t\t\tbuffer\n\t\t    filename\tname of a file; only used when \"bufnr\" is not\n\t\t\t\tpresent or it is invalid.\n\t\t    module\tname of a module; if given it will be used in\n\t\t\t\tquickfix error window instead of the filename\n\t\t    lnum\tline number in the file\n\t\t    pattern\tsearch pattern used to locate the error\n\t\t    col\t\tcolumn number\n\t\t    vcol\twhen non-zero: \"col\" is visual column\n\t\t\t\twhen zero: \"col\" is byte index\n\t\t    nr\t\terror number\n\t\t    text\tdescription of the error\n\t\t    type\tsingle-character error type, 'E', 'W', etc.\n\t\t    valid\trecognized error message\n\n\t\tThe \"col\", \"vcol\", \"nr\", \"type\" and \"text\" entries are\n\t\toptional.  Either \"lnum\" or \"pattern\" entry can be used to\n\t\tlocate a matching error line.\n\t\tIf the \"filename\" and \"bufnr\" entries are not present or\n\t\tneither the \"lnum\" or \"pattern\" entries are present, then the\n\t\titem will not be handled as an error line.\n\t\tIf both \"pattern\" and \"lnum\" are present then \"pattern\" will\n\t\tbe used.\n\t\tIf the \"valid\" entry is not supplied, then the valid flag is\n\t\tset when \"bufnr\" is a valid buffer or \"filename\" exists.\n\t\tIf you supply an empty {list}, the quickfix list will be\n\t\tcleared.\n\t\tNote that the list is not exactly the same as what\n\t\t|getqflist()| returns.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "setqflist-action* *E927",
   "description": "\t\t'a'\tThe items from {list} are added to the existing\n\t\t\tquickfix list. If there is no existing list, then a\n\t\t\tnew list is created.\n\n\t\t'r'\tThe items from the current quickfix list are replaced\n\t\t\twith the items from {list}.  This can also be used to\n\t\t\tclear the list: >\n\t\t\t\t:call setqflist([], 'r')\n<\n\t\t'f'\tAll the quickfix lists in the quickfix stack are\n\t\t\tfreed.\n\n\t\tIf {action} is not present or is set to ' ', then a new list\n\t\tis created. The new quickfix list is added after the current\n\t\tquickfix list in the stack and all the following lists are\n\t\tfreed. To add a new quickfix list at the end of the stack,\n\t\tset \"nr\" in {what} to \"$\".\n\n\t\tThe following items can be specified in dictionary {what}:\n\t\t    context\tquickfix list context. See |quickfix-context|\n\t\t    efm\t\terrorformat to use when parsing text from\n\t\t\t\t\"lines\". If this is not present, then the\n\t\t\t\t'errorformat' option value is used.\n\t\t\t\tSee |quickfix-parse|\n\t\t    id\t\tquickfix list identifier |quickfix-ID|\n\t\t    idx\t\tindex of the current entry in the quickfix\n\t\t\t\tlist specified by 'id' or 'nr'. If set to '$',\n\t\t\t\tthen the last entry in the list is set as the\n\t\t\t\tcurrent entry.  See |quickfix-index|\n\t\t    items\tlist of quickfix entries. Same as the {list}\n\t\t\t\targument.\n\t\t    lines\tuse 'errorformat' to parse a list of lines and\n\t\t\t\tadd the resulting entries to the quickfix list\n\t\t\t\t{nr} or {id}.  Only a |List| value is supported.\n\t\t\t\tSee |quickfix-parse|\n\t\t    nr\t\tlist number in the quickfix stack; zero\n\t\t\t\tmeans the current quickfix list and \"$\" means\n\t\t\t\tthe last quickfix list.\n\t\t    quickfixtextfunc\n\t\t\t\tfunction to get the text to display in the\n\t\t\t\tquickfix window.  The value can be the name of\n\t\t\t\ta function or a funcref or a lambda.  Refer to\n\t\t\t\t|quickfix-window-function| for an explanation\n\t\t\t\tof how to write the function and an example.\n\t\t    title\tquickfix list title text. See |quickfix-title|\n\t\tUnsupported keys in {what} are ignored.\n\t\tIf the \"nr\" item is not present, then the current quickfix list\n\t\tis modified. When creating a new quickfix list, \"nr\" can be\n\t\tset to a value one greater than the quickfix stack size.\n\t\tWhen modifying a quickfix list, to guarantee that the correct\n\t\tlist is modified, \"id\" should be used instead of \"nr\" to\n\t\tspecify the list.\n\n\t\tExamples (See also |setqflist-examples|): >\n\t\t   :call setqflist([], 'r', {'title': 'My search'})\n\t\t   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})\n\t\t   :call setqflist([], 'a', {'id':qfid, 'lines':[\"F1:10:L10\"]})\n<\n\t\tReturns zero for success, -1 for failure.\n\n\t\tThis function can be used to create a quickfix list\n\t\tindependent of the 'errorformat' setting.  Use a command like\n\t\t`:cc 1` to jump to the first position.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "setreg",
   "description": "\t\tSet the register {regname} to {value}.\n\t\tThe {regname} argument is a string.\n\n\t\t{value} may be any value returned by |getreg()|, including\n\t\ta |List|.\n\t\tIf {options} contains \"a\" or {regname} is upper case,\n\t\tthen the value is appended.\n\n\t\t{options} can also contain a register type specification:\n\t\t    \"c\" or \"v\"\t      |charwise| mode\n\t\t    \"l\" or \"V\"\t      |linewise| mode\n\t\t    \"b\" or \"<CTRL-V>\" |blockwise-visual| mode\n\t\tIf a number immediately follows \"b\" or \"<CTRL-V>\" then this is\n\t\tused as the width of the selection - if it is not specified\n\t\tthen the width of the block is set to the number of characters\n\t\tin the longest line (counting a <Tab> as 1 character).\n\t\tIf {options} contains \"u\" or '\"', then the unnamed register is\n\t\tset to point to register {regname}.\n\n\t\tIf {options} contains no register settings, then the default\n\t\tis to use character mode unless {value} ends in a <NL> for\n\t\tstring {value} and linewise mode for list {value}. Blockwise\n\t\tmode is never selected automatically.\n\t\tReturns zero for success, non-zero for failure.",
   "argsStr": "{regname}, {value} [, {options}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E883",
   "description": "Note: you may not use |List| containing more than one item to\n\t\t      set search and expression registers. Lists containing no\n\t\t      items act like empty strings.\n\n\t\tExamples: >\n\t\t\t:call setreg(v:register, @*)\n\t\t\t:call setreg('*', @%, 'ac')\n\t\t\t:call setreg('a', \"1\\n2\\n3\", 'b5')\n\n<\t\tThis example shows using the functions to save and restore a\n\t\tregister: >\n\t\t\t:let var_a = getreg('a', 1, 1)\n\t\t\t:let var_amode = getregtype('a')\n\t\t\t    ....\n\t\t\t:call setreg('a', var_a, var_amode)\n<\t\tNote: you may not reliably restore register value\n\t\twithout using the third argument to |getreg()| as without it\n\t\tnewlines are represented as newlines AND Nul bytes are\n\t\trepresented as newlines as well, see |NL-used-for-Nul|.\n\n\t\tYou can also change the type of a register by appending\n\t\tnothing: >\n\t\t\t:call setreg('a', '', 'al')",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "settabvar",
   "description": "\t\tSet tab-local variable {varname} to {val} in tab page {tabnr}.\n\t\t|t:var|\n\t\tThe {varname} argument is a string.\n\t\tNote that the variable name without \"t:\" must be used.\n\t\tTabs are numbered starting with one.\n\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{tabnr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "settabwinvar",
   "description": "\t\tSet option or local variable {varname} in window {winnr} to\n\t\t{val}.\n\t\tTabs are numbered starting with one.  For the current tabpage\n\t\tuse |setwinvar()|.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tWhen {winnr} is zero the current window is used.\n\t\tThis also works for a global or local buffer option, but it\n\t\tdoesn't work for a global or local buffer variable.\n\t\tFor a local buffer option the global value is unchanged.\n\t\tNote that the variable name without \"w:\" must be used.\n\t\tExamples: >\n\t\t\t:call settabwinvar(1, 1, \"&list\", 0)\n\t\t\t:call settabwinvar(3, 2, \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{tabnr}, {winnr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "settagstack",
   "description": "\t\tModify the tag stack of the window {nr} using {dict}.\n\t\t{nr} can be the window number or the |window-ID|.\n\n\t\tFor a list of supported items in {dict}, refer to\n\t\t|gettagstack()|. \"curidx\" takes effect before changing the tag\n\t\tstack.",
   "argsStr": "{nr}, {dict} [, {action}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E962",
   "description": "How the tag stack is modified depends on the {action}\n\t\targument:\n\t\t- If {action} is not present or is set to 'r', then the tag\n\t\t  stack is replaced.\n\t\t- If {action} is set to 'a', then new entries from {dict} are\n\t\t  pushed (added) onto the tag stack.\n\t\t- If {action} is set to 't', then all the entries from the\n\t\t  current entry in the tag stack or \"curidx\" in {dict} are\n\t\t  removed and then new entries are pushed to the stack.\n\n\t\tThe current index is set to one after the length of the tag\n\t\tstack after the modification.\n\n\t\tReturns zero for success, -1 for failure.\n\n\t\tExamples (for more examples see |tagstack-examples|):\n\t\t    Empty the tag stack of window 3: >\n\t\t\tcall settagstack(3, {'items' : []})\n\n<\t\t    Save and restore the tag stack: >\n\t\t\tlet stack = gettagstack(1003)\n\t\t\t\" do something else\n\t\t\tcall settagstack(1003, stack)\n\t\t\tunlet stack\n<",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "setwinvar",
   "description": "\t\tLike |settabwinvar()| for the current tab page.\n\t\tExamples: >\n\t\t\t:call setwinvar(1, \"&list\", 0)\n\t\t\t:call setwinvar(2, \"myvar\", \"foobar\")",
   "argsStr": "{nr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sha256",
   "description": "\t\tReturns a String with 64 hex characters, which is the SHA256\n\t\tchecksum of {string}.",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "shellescape",
   "description": "\t\tEscape {string} for use as a shell command argument.\n\n\t\tOn Windows when 'shellslash' is not set, encloses {string} in\n\t\tdouble-quotes and doubles all double-quotes within {string}.\n\t\tOtherwise encloses {string} in single-quotes and replaces all\n\t\t\"'\" with \"'\\''\".\n\n\t\tIf {special} is a ||non-zero-arg|:\n\t\t- Special items such as \"!\", \"%\", \"#\" and \"<cword>\" will be\n\t\t  preceded by a backslash. The backslash will be removed again\n\t\t  by the |:!| command.\n\t\t- The <NL> character is escaped.\n\n\t\tIf 'shell' contains \"csh\" in the tail:\n\t\t- The \"!\" character will be escaped. This is because csh and\n\t\t  tcsh use \"!\" for history replacement even in single-quotes.\n\t\t- The <NL> character is escaped (twice if {special} is\n\t\t  a ||non-zero-arg|).\n\n\t\tIf 'shell' contains \"fish\" in the tail, the \"\\\" character will\n\t\tbe escaped because in fish it is used as an escape character\n\t\tinside single quotes.\n\n\t\tExample of use with a |:!| command: >\n\t\t    :exe '!dir ' . shellescape(expand('<cfile>'), 1)\n<\t\tThis results in a directory listing for the file under the\n\t\tcursor.  Example of use with |system()|: >\n\t\t    :call system(\"chmod +w -- \" . shellescape(expand(\"%\")))\n<\t\tSee also |::S|.",
   "argsStr": "{string} [, {special}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "shiftwidth",
   "description": "\t\tReturns the effective value of 'shiftwidth'. This is the\n\t\t'shiftwidth' value unless it is zero, in which case it is the\n\t\t'tabstop' value.  To be backwards compatible in indent\n\t\tplugins, use this: >\n\t\t\tif exists('*shiftwidth')\n\t\t\t  func s:sw()\n\t\t\t    return shiftwidth()\n\t\t\t  endfunc\n\t\t\telse\n\t\t\t  func s:sw()\n\t\t\t    return &sw\n\t\t\t  endfunc\n\t\t\tendif\n<\t\tAnd then use s:sw() instead of &sw.\n\n\t\tWhen there is one argument {col} this is used as column number\n\t\tfor which to return the 'shiftwidth' value. This matters for the\n\t\t'vartabstop' feature. If no {col} argument is given, column 1\n\t\twill be assumed.\n\nsign_ functions are documented here: |sign-functions-details|",
   "argsStr": "[{col}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "simplify",
   "description": "\t\tSimplify the file name as much as possible without changing\n\t\tthe meaning.  Shortcuts (on MS-Windows) or symbolic links (on\n\t\tUnix) are not resolved.  If the first path component in\n\t\t{filename} designates the current directory, this will be\n\t\tvalid for the result as well.  A trailing path separator is\n\t\tnot removed either. On Unix \"//path\" is unchanged, but\n\t\t\"///path\" is simplified to \"/path\" (this follows the Posix\n\t\tstandard).\n\t\tExample: >\n\t\t\tsimplify(\"./dir/.././/file/\") == \"./file/\"\n<\t\tNote: The combination \"dir/..\" is only removed if \"dir\" is\n\t\ta searchable directory or does not exist.  On Unix, it is also\n\t\tremoved when \"dir\" is a symbolic link within the same\n\t\tdirectory.  In order to resolve all the involved symbolic\n\t\tlinks before simplifying the path name, use |resolve()|.",
   "argsStr": "{filename}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sin",
   "description": "\t\tReturn the sine of {expr}, measured in radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo sin(100)\n<\t\t\t-0.506366 >\n\t\t\t:echo sin(-4.01)\n<\t\t\t0.763301\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->sin()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sinh",
   "description": "\t\tReturn the hyperbolic sine of {expr} as a |Float| in the range\n\t\t[-inf, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo sinh(0.5)\n<\t\t\t0.521095 >\n\t\t\t:echo sinh(-0.9)\n<\t\t\t-1.026517\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->sinh()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sockconnect",
   "description": "\t\tConnect a socket to an address. If {mode} is \"pipe\" then\n\t\t{address} should be the path of a named pipe. If {mode} is\n\t\t\"tcp\" then {address} should be of the form \"host:port\" where\n\t\tthe host should be an ip adderess or host name, and port the\n\t\tport number.\n\n\t\tReturns a |channel| ID. Close the socket with |chanclose()|.\n\t\tUse |chansend()| to send data over a bytes socket, and\n\t\t|rpcrequest()| and |rpcnotify()| to communicate with a RPC\n\t\tsocket.\n\n\t\t{opts} is an optional dictionary with these keys:\n\t\t  |on_data| : callback invoked when data was read from socket\n\t\t  data_buffered : read socket data in |channel-buffered| mode.\n\t\t  rpc     : If set, |msgpack-rpc| will be used to communicate\n\t\t\t    over the socket.\n\t\tReturns:\n\t\t  - The channel ID on success (greater than zero)\n\t\t  - 0 on invalid arguments or connection failure.",
   "argsStr": "{mode}, {address} [, {opts}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sort",
   "description": "\t\tSort the items in {list} in-place.  Returns {list}.\n\n\t\tIf you want a list to remain unmodified make a copy first: >\n\t\t\t:let sortedlist = sort(copy(mylist))\n\n<\t\tWhen {func} is omitted, is empty or zero, then sort() uses the\n\t\tstring representation of each item to sort on.  Numbers sort\n\t\tafter Strings, |Lists| after Numbers.  For sorting text in the\n\t\tcurrent buffer use |:sort|.\n\n\t\tWhen {func} is given and it is '1' or 'i' then case is\n\t\tignored.\n\n\t\tWhen {func} is given and it is 'l' then the current collation\n\t\tlocale is used for ordering. Implementation details: strcoll()\n\t\tis used to compare strings. See |:language| check or set the\n\t\tcollation locale. |v:collate| can also be used to check the\n\t\tcurrent locale. Sorting using the locale typically ignores\n\t\tcase. Example: >\n\t\t\t\" ö is sorted similarly to o with English locale.\n\t\t\t:language collate en_US.UTF8\n\t\t\t:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')\n<\t\t\t['n', 'o', 'O', 'ö', 'p', 'z'] ~\n>\n\t\t\t\" ö is sorted after z with Swedish locale.\n\t\t\t:language collate sv_SE.UTF8\n\t\t\t:echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')\n<\t\t\t['n', 'o', 'O', 'p', 'z', 'ö'] ~\n\t\tThis does not work properly on Mac.\n\n\t\tWhen {func} is given and it is 'n' then all items will be\n\t\tsorted numerical (Implementation detail: this uses the\n\t\tstrtod() function to parse numbers, Strings, Lists, Dicts and\n\t\tFuncrefs will be considered as being 0).\n\n\t\tWhen {func} is given and it is 'N' then all items will be\n\t\tsorted numerical. This is like 'n' but a string containing\n\t\tdigits will be used as the number they represent.\n\n\t\tWhen {func} is given and it is 'f' then all items will be\n\t\tsorted numerical. All values must be a Number or a Float.\n\n\t\tWhen {func} is a |Funcref| or a function name, this function\n\t\tis called to compare items.  The function is invoked with two\n\t\titems as argument and must return zero if they are equal, 1 or\n\t\tbigger if the first one sorts after the second one, -1 or\n\t\tsmaller if the first one sorts before the second one.\n\n\t\t{dict} is for functions with the \"dict\" attribute.  It will be\n\t\tused to set the local variable \"self\". |Dictionary-function|\n\n\t\tThe sort is stable, items which compare equal (as number or as\n\t\tstring) will keep their relative position. E.g., when sorting\n\t\ton numbers, text strings will sort next to each other, in the\n\t\tsame order as they were originally.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->sort()\n\n<\t\tAlso see |uniq()|.\n\n\t\tExample: >\n\t\t\tfunc MyCompare(i1, i2)\n\t\t\t   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1\n\t\t\tendfunc\n\t\t\teval mylist->sort(\"MyCompare\")\n<\t\tA shorter compare version for this specific simple case, which\n\t\tignores overflow: >\n\t\t\tfunc MyCompare(i1, i2)\n\t\t\t   return a:i1 - a:i2\n\t\t\tendfunc\n<\t\tFor a simple expression you can use a lambda: >\n\t\t\teval mylist->sort({i1, i2 -> i1 - i2})\n<",
   "argsStr": "{list} [, {func} [, {dict}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "soundfold",
   "description": "\t\tReturn the sound-folded equivalent of {word}.  Uses the first\n\t\tlanguage in 'spelllang' for the current window that supports\n\t\tsoundfolding.  'spell' must be set.  When no sound folding is\n\t\tpossible the {word} is returned unmodified.\n\t\tThis can be used for making spelling suggestions.  Note that\n\t\tthe method can be quite slow.",
   "argsStr": "{word}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "spellbadword",
   "description": "\t\tWithout argument: The result is the badly spelled word under\n\t\tor after the cursor.  The cursor is moved to the start of the\n\t\tbad word.  When no bad word is found in the cursor line the\n\t\tresult is an empty string and the cursor doesn't move.\n\n\t\tWith argument: The result is the first word in {sentence} that\n\t\tis badly spelled.  If there are no spelling mistakes the\n\t\tresult is an empty string.\n\n\t\tThe return value is a list with two items:\n\t\t- The badly spelled word or an empty string.\n\t\t- The type of the spelling error:\n\t\t\t\"bad\"\t\tspelling mistake\n\t\t\t\"rare\"\t\trare word\n\t\t\t\"local\"\t\tword only valid in another region\n\t\t\t\"caps\"\t\tword should start with Capital\n\t\tExample: >\n\t\t\techo spellbadword(\"the quik brown fox\")\n<\t\t\t['quik', 'bad'] ~\n\n\t\tThe spelling information for the current window and the value\n\t\tof 'spelllang' are used.",
   "argsStr": "[{sentence}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "spellsuggest",
   "description": "\t\tReturn a |List| with spelling suggestions to replace {word}.\n\t\tWhen {max} is given up to this number of suggestions are\n\t\treturned.  Otherwise up to 25 suggestions are returned.\n\n\t\tWhen the {capital} argument is given and it's non-zero only\n\t\tsuggestions with a leading capital will be given.  Use this\n\t\tafter a match with 'spellcapcheck'.\n\n\t\t{word} can be a badly spelled word followed by other text.\n\t\tThis allows for joining two words that were split.  The\n\t\tsuggestions also include the following text, thus you can\n\t\treplace a line.\n\n\t\t{word} may also be a good word.  Similar words will then be\n\t\treturned.  {word} itself is not included in the suggestions,\n\t\talthough it may appear capitalized.\n\n\t\tThe spelling information for the current window is used.  The\n\t\tvalues of 'spelllang' and 'spellsuggest' are used.",
   "argsStr": "{word} [, {max} [, {capital}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "split",
   "description": "\t\tMake a |List| out of {string}.  When {pattern} is omitted or\n\t\tempty each white-separated sequence of characters becomes an\n\t\titem.\n\t\tOtherwise the string is split where {pattern} matches,\n\t\tremoving the matched characters. 'ignorecase' is not used\n\t\there, add \\c to ignore case. |/\\c|\n\t\tWhen the first or last item is empty it is omitted, unless the\n\t\t{keepempty} argument is given and it's non-zero.\n\t\tOther empty items are kept when {pattern} matches at least one\n\t\tcharacter or when {keepempty} is non-zero.\n\t\tExample: >\n\t\t\t:let words = split(getline('.'), '\\W\\+')\n<\t\tTo split a string in individual characters: >\n\t\t\t:for c in split(mystring, '\\zs')\n<\t\tIf you want to keep the separator you can also use '\\zs' at\n\t\tthe end of the pattern: >\n\t\t\t:echo split('abc:def:ghi', ':\\zs')\n<\t\t\t['abc:', 'def:', 'ghi'] ~\n\t\tSplitting a table where the first element can be empty: >\n\t\t\t:let items = split(line, ':', 1)\n<\t\tThe opposite function is |join()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetString()->split()",
   "argsStr": "{string} [, {pattern} [, {keepempty}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sqrt",
   "description": "\t\tReturn the non-negative square root of Float {expr} as a\n\t\t|Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.  When {expr}\n\t\tis negative the result is NaN (Not a Number).\n\t\tExamples: >\n\t\t\t:echo sqrt(100)\n<\t\t\t10.0 >\n\t\t\t:echo sqrt(-4.01)\n<\t\t\tnan\n\t\t\"nan\" may be different, it depends on system libraries.\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->sqrt()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stdioopen",
   "description": "\t\tWith |--headless| this opens stdin and stdout as a |channel|.\n\t\tMay be called only once. See |channel-stdio|. stderr is not\n\t\thandled by this function, see |v:stderr|.\n\n\t\tClose the stdio handles with |chanclose()|. Use |chansend()|\n\t\tto send data to stdout, and |rpcrequest()| and |rpcnotify()|\n\t\tto communicate over RPC.\n\n\t\t{opts} is a dictionary with these keys:\n\t\t  |on_stdin| : callback invoked when stdin is written to.\n\t\t  stdin_buffered : read stdin in |channel-buffered| mode.\n\t\t  rpc      : If set, |msgpack-rpc| will be used to communicate\n\t\t\t     over stdio\n\t\tReturns:\n\t\t  - |channel-id| on success (value is always 1)\n\t\t  - 0 on invalid arguments",
   "argsStr": "{opts}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stdpath",
   "description": "\t\tReturns |standard-path| locations of various default files and\n\t\tdirectories.\n\n\t\t{what}       Type    Description ~\n\t\tcache        String  Cache directory. Arbitrary temporary\n\t\t                     storage for plugins, etc.\n\t\tconfig       String  User configuration directory. The\n\t\t                     |init.vim| is stored here.\n\t\tconfig_dirs  List    Additional configuration directories.\n\t\tdata         String  User data directory. The |shada-file|\n\t\t                     is stored here.\n\t\tdata_dirs    List    Additional data directories.\n\n\t\tExample: >\n\t\t\t:echo stdpath(\"config\")",
   "argsStr": "{what}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2float",
   "description": " \t\tConvert String {string} to a Float.  This mostly works the\n \t\tsame as when using a floating point number in an expression,\n \t\tsee |floating-point-format|.  But it's a bit more permissive.\n \t\tE.g., \"1e40\" is accepted, while in an expression you need to\n \t\twrite \"1.0e40\".  The hexadecimal form \"0x123\" is also\n \t\taccepted, but not others, like binary or octal.\n \t\tWhen {quoted} is present and non-zero then embedded single\n \t\tquotes before the dot are ignored, thus \"1'000.0\" is a\n \t\tthousand.\n\t\tText after the number is silently ignored.\n\t\tThe decimal point is always '.', no matter what the locale is\n\t\tset to.  A comma ends the number: \"12,345.67\" is converted to\n\t\t12.0.  You can strip out thousands separators with\n\t\t|substitute()|: >\n\t\t\tlet f = str2float(substitute(text, ',', '', 'g'))\n<\n\t\tCan also be used as a |method|: >\n\t\t\tlet f = text->substitute(',', '', 'g')->str2float()",
   "argsStr": "{string} [, {quoted}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2list",
   "description": "\t\tReturn a list containing the number values which represent\n\t\teach character in String {string}.  Examples: >\n\t\t\tstr2list(\" \")\t\treturns [32]\n\t\t\tstr2list(\"ABC\")\t\treturns [65, 66, 67]\n<\t\t|list2str()| does the opposite.\n\n\t\tWhen {utf8} is omitted or zero, the current 'encoding' is used.\n\t\tWith {utf8} set to TRUE, always treat the String as utf-8\n\t\tcharacters.  With utf-8 composing characters are handled\n\t\tproperly: >\n\t\t\tstr2list(\"á\")\t\treturns [97, 769]\n\n<\t\tCan also be used as a |method|: >\n\t\t\tGetString()->str2list()",
   "argsStr": "{string} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2nr",
   "description": "\t\tConvert string {string} to a number.\n\t\t{base} is the conversion base, it can be 2, 8, 10 or 16.\n\t\tWhen {quoted} is present and non-zero then embedded single\n\t\tquotes are ignored, thus \"1'000'000\" is a million.\n\n\t\tWhen {base} is omitted base 10 is used.  This also means that\n\t\ta leading zero doesn't cause octal conversion to be used, as\n\t\twith the default String to Number conversion.  Example: >\n\t\t\tlet nr = str2nr('123')\n<\n\t\tWhen {base} is 16 a leading \"0x\" or \"0X\" is ignored.  With a\n\t\tdifferent base the result will be zero. Similarly, when\n\t\t{base} is 8 a leading \"0\", \"0o\" or \"0O\" is ignored, and when\n\t\t{base} is 2 a leading \"0b\" or \"0B\" is ignored.\n\t\tText after the number is silently ignored.",
   "argsStr": "{string} [, {base}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strchars",
   "description": "\t\tThe result is a Number, which is the number of characters\n\t\tin String {string}.\n\t\tWhen {skipcc} is omitted or zero, composing characters are\n\t\tcounted separately.\n\t\tWhen {skipcc} set to 1, Composing characters are ignored.\n\t\tAlso see |strlen()|, |strdisplaywidth()| and |strwidth()|.\n\n\t\t{skipcc} is only available after 7.4.755.  For backward\n\t\tcompatibility, you can define a wrapper function: >\n\t\t    if has(\"patch-7.4.755\")\n\t\t      function s:strchars(str, skipcc)\n\t\t\treturn strchars(a:str, a:skipcc)\n\t\t      endfunction\n\t\t    else\n\t\t      function s:strchars(str, skipcc)\n\t\t\tif a:skipcc\n\t\t\t  return strlen(substitute(a:str, \".\", \"x\", \"g\"))\n\t\t\telse\n\t\t\t  return strchars(a:str)\n\t\t\tendif\n\t\t      endfunction\n\t\t    endif\n<",
   "argsStr": "{string} [, {skipcc}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strcharpart",
   "description": "\t\tLike |strpart()| but using character index and length instead\n\t\tof byte index and length.  Composing characters are counted\n\t\tseparately.\n\t\tWhen a character index is used where a character does not\n\t\texist it is assumed to be one character.  For example: >\n\t\t\tstrcharpart('abc', -1, 2)\n<\t\tresults in 'a'.",
   "argsStr": "{src}, {start} [, {len}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strdisplaywidth",
   "description": "\t\tThe result is a Number, which is the number of display cells\n\t\tString {string} occupies on the screen when it starts at {col}\n\t\t(first column is zero).  When {col} is omitted zero is used.\n\t\tOtherwise it is the screen column where to start.  This\n\t\tmatters for Tab characters.\n\t\tThe option settings of the current window are used.  This\n\t\tmatters for anything that's displayed differently, such as\n\t\t'tabstop' and 'display'.\n\t\tWhen {string} contains characters with East Asian Width Class\n\t\tAmbiguous, this function's return value depends on 'ambiwidth'.\n\t\tAlso see |strlen()|, |strwidth()| and |strchars()|.",
   "argsStr": "{string} [, {col}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strftime",
   "description": "\t\tThe result is a String, which is a formatted date and time, as\n\t\tspecified by the {format} string.  The given {time} is used,\n\t\tor the current time if no time is given.  The accepted\n\t\t{format} depends on your system, thus this is not portable!\n\t\tSee the manual page of the C function strftime() for the\n\t\tformat.  The maximum length of the result is 80 characters.\n\t\tSee also |localtime()|, |getftime()| and |strptime()|.\n\t\tThe language can be changed with the |:language| command.\n\t\tExamples: >\n\t\t  :echo strftime(\"%c\")\t\t   Sun Apr 27 11:49:23 1997\n\t\t  :echo strftime(\"%Y %b %d %X\")\t   1997 Apr 27 11:53:25\n\t\t  :echo strftime(\"%y%m%d %T\")\t   970427 11:53:55\n\t\t  :echo strftime(\"%H:%M\")\t   11:55\n\t\t  :echo strftime(\"%c\", getftime(\"file.c\"))\n\t\t\t\t\t\t   Show mod time of file.c.",
   "argsStr": "{format} [, {time}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strgetchar",
   "description": "\t\tGet character {index} from {str}.  This uses a character\n\t\tindex, not a byte index.  Composing characters are considered\n\t\tseparate characters here.\n\t\tAlso see |strcharpart()| and |strchars()|.",
   "argsStr": "{str}, {index}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stridx",
   "description": "\t\tThe result is a Number, which gives the byte index in\n\t\t{haystack} of the first occurrence of the String {needle}.\n\t\tIf {start} is specified, the search starts at index {start}.\n\t\tThis can be used to find a second match: >\n\t\t\t:let colon1 = stridx(line, \":\")\n\t\t\t:let colon2 = stridx(line, \":\", colon1 + 1)\n<\t\tThe search is done case-sensitive.\n\t\tFor pattern searches use |match()|.\n\t\t-1 is returned if the {needle} does not occur in {haystack}.\n\t\tSee also |strridx()|.\n\t\tExamples: >\n\t\t  :echo stridx(\"An Example\", \"Example\")\t     3\n\t\t  :echo stridx(\"Starting point\", \"Start\")    0\n\t\t  :echo stridx(\"Starting point\", \"start\")   -1",
   "argsStr": "{haystack}, {needle} [, {start}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strstr()* *strchr",
   "description": "\t\tstridx() works similar to the C function strstr().  When used\n\t\twith a single character it works similar to strchr().",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "string",
   "description": "Return {expr} converted to a String.  If {expr} is a Number,\n\t\tFloat, String, Blob or a composition of them, then the result\n\t\tcan be parsed back with |eval()|.\n\t\t\t{expr} type\tresult ~\n\t\t\tString\t\t'string'\n\t\t\tNumber\t\t123\n\t\t\tFloat\t\t123.123456 or 1.123456e8 or\n\t\t\t\t\t`str2float('inf')`\n\t\t\tFuncref\t\t`function('name')`\n\t\t\tBlob\t\t0z00112233.44556677.8899\n\t\t\tList\t\t[item, item]\n\t\t\tDictionary\t{key: value, key: value}\n\t\tNote that in String values the ' character is doubled.\n\t\tAlso see |strtrans()|.\n\t\tNote 2: Output format is mostly compatible with YAML, except\n\t\tfor infinite and NaN floating-point values representations\n\t\twhich use |str2float()|.  Strings are also dumped literally,\n\t\tonly single quote is escaped, which does not allow using YAML\n\t\tfor parsing back binary strings.  |eval()| should always work for\n\t\tstrings and floats though and this is the only official\n\t\tmethod, use |msgpackdump()| or |json_encode()| if you need to\n\t\tshare data with other application.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->string()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strlen",
   "description": "\t\tThe result is a Number, which is the length of the String\n\t\t{string} in bytes.\n\t\tIf the argument is a Number it is first converted to a String.\n\t\tFor other types an error is given.\n\t\tIf you want to count the number of multibyte characters use\n\t\t|strchars()|.\n\t\tAlso see |len()|, |strdisplaywidth()| and |strwidth()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetString()->strlen()",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strpart",
   "description": "\t\tThe result is a String, which is part of {src}, starting from\n\t\tbyte {start}, with the byte length {len}.\n\t\tWhen {chars} is present and TRUE then {len} is the number of\n\t\tcharacters positions (composing characters are not counted\n\t\tseparately, thus \"1\" means one base character and any\n\t\tfollowing composing characters).\n\t\tTo count {start} as characters instead of bytes use\n\t\t|strcharpart()|.\n\n\t\tWhen bytes are selected which do not exist, this doesn't\n\t\tresult in an error, the bytes are simply omitted.\n\t\tIf {len} is missing, the copy continues from {start} till the\n\t\tend of the {src}. >\n\t\t\tstrpart(\"abcdefg\", 3, 2)    == \"de\"\n\t\t\tstrpart(\"abcdefg\", -2, 4)   == \"ab\"\n\t\t\tstrpart(\"abcdefg\", 5, 4)    == \"fg\"\n\t\t\tstrpart(\"abcdefg\", 3)\t    == \"defg\"\n\n<\t\tNote: To get the first character, {start} must be 0.  For\n\t\texample, to get the character under the cursor: >\n\t\t\tstrpart(getline(\".\"), col(\".\") - 1, 1, v:true)\n<",
   "argsStr": "{src}, {start} [, {len} [, {chars}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strptime",
   "description": "\t\tThe result is a Number, which is a unix timestamp representing\n\t\tthe date and time in {timestring}, which is expected to match\n\t\tthe format specified in {format}.\n\n\t\tThe accepted {format} depends on your system, thus this is not\n\t\tportable!  See the manual page of the C function strptime()\n\t\tfor the format.  Especially avoid \"%c\".  The value of $TZ also\n\t\tmatters.\n\n\t\tIf the {timestring} cannot be parsed with {format} zero is\n\t\treturned.  If you do not know the format of {timestring} you\n\t\tcan try different {format} values until you get a non-zero\n\t\tresult.\n\n\t\tSee also |strftime()|.\n\t\tExamples: >\n\t\t  :echo strptime(\"%Y %b %d %X\", \"1997 Apr 27 11:49:23\")\n<\t\t  862156163 >\n\t\t  :echo strftime(\"%c\", strptime(\"%y%m%d %T\", \"970427 11:53:55\"))\n<\t\t  Sun Apr 27 11:53:55 1997 >\n\t\t  :echo strftime(\"%c\", strptime(\"%Y%m%d%H%M%S\", \"19970427115355\") + 3600)\n<\t\t  Sun Apr 27 12:53:55 1997",
   "argsStr": "{format}, {timestring}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strridx",
   "description": "\t\tThe result is a Number, which gives the byte index in\n\t\t{haystack} of the last occurrence of the String {needle}.\n\t\tWhen {start} is specified, matches beyond this index are\n\t\tignored.  This can be used to find a match before a previous\n\t\tmatch: >\n\t\t\t:let lastcomma = strridx(line, \",\")\n\t\t\t:let comma2 = strridx(line, \",\", lastcomma - 1)\n<\t\tThe search is done case-sensitive.\n\t\tFor pattern searches use |match()|.\n\t\t-1 is returned if the {needle} does not occur in {haystack}.\n\t\tIf the {needle} is empty the length of {haystack} is returned.\n\t\tSee also |stridx()|.  Examples: >\n\t\t  :echo strridx(\"an angry armadillo\", \"an\")\t     3",
   "argsStr": "{haystack}, {needle} [, {start}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strrchr",
   "description": "\t\tWhen used with a single character it works similar to the C\n\t\tfunction strrchr().",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strtrans",
   "description": "\t\tThe result is a String, which is {string} with all unprintable\n\t\tcharacters translated into printable characters |'isprint'|.\n\t\tLike they are shown in a window.  Example: >\n\t\t\techo strtrans(@a)\n<\t\tThis displays a newline in register a as \"^@\" instead of\n\t\tstarting a new line.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetString()->strtrans()",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strwidth",
   "description": "\t\tThe result is a Number, which is the number of display cells\n\t\tString {string} occupies.  A Tab character is counted as one\n\t\tcell, alternatively use |strdisplaywidth()|.\n\t\tWhen {string} contains characters with East Asian Width Class\n\t\tAmbiguous, this function's return value depends on 'ambiwidth'.\n\t\tAlso see |strlen()|, |strdisplaywidth()| and |strchars()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tGetString()->strwidth()",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "submatch",
   "description": "\t\tOnly for an expression in a |:substitute| command or\n\t\tsubstitute() function.\n\t\tReturns the {nr}'th submatch of the matched text.  When {nr}\n\t\tis 0 the whole matched text is returned.\n\t\tNote that a NL in the string can stand for a line break of a\n\t\tmulti-line match or a NUL character in the text.\n\t\tAlso see |sub-replace-expression|.\n\n\t\tIf {list} is present and non-zero then submatch() returns\n\t\ta list of strings, similar to |getline()| with two arguments.\n\t\tNL characters in the text represent NUL characters in the\n\t\ttext.\n\t\tOnly returns more than one item for |:substitute|, inside\n\t\t|substitute()| this list will always contain one or zero\n\t\titems, since there are no real line breaks.\n\n\t\tWhen substitute() is used recursively only the submatches in\n\t\tthe current (deepest) call can be obtained.\n\n\t\tExamples: >\n\t\t\t:s/\\d\\+/\\=submatch(0) + 1/\n\t\t\t:echo substitute(text, '\\d\\+', '\\=submatch(0) + 1', '')\n<\t\tThis finds the first number in the line and adds one to it.\n\t\tA line break is included as a newline character.",
   "argsStr": "{nr} [, {list}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "substitute",
   "description": "\t\tThe result is a String, which is a copy of {string}, in which\n\t\tthe first match of {pat} is replaced with {sub}.\n\t\tWhen {flags} is \"g\", all matches of {pat} in {string} are\n\t\treplaced.  Otherwise {flags} should be \"\".\n\n\t\tThis works like the \":substitute\" command (without any flags).\n\t\tBut the matching with {pat} is always done like the 'magic'\n\t\toption is set and 'cpoptions' is empty (to make scripts\n\t\tportable).  'ignorecase' is still relevant, use |/\\c| or |/\\C|\n\t\tif you want to ignore or match case and ignore 'ignorecase'.\n\t\t'smartcase' is not used.  See |string-match| for how {pat} is\n\t\tused.\n\n\t\tA \"~\" in {sub} is not replaced with the previous {sub}.\n\t\tNote that some codes in {sub} have a special meaning\n\t\t|sub-replace-special|.  For example, to replace something with\n\t\t\"\\n\" (two characters), use \"\\\\\\\\n\" or '\\\\n'.\n\n\t\tWhen {pat} does not match in {string}, {string} is returned\n\t\tunmodified.\n\n\t\tExample: >\n\t\t\t:let &path = substitute(&path, \",\\\\=[^,]*$\", \"\", \"\")\n<\t\tThis removes the last component of the 'path' option. >\n\t\t\t:echo substitute(\"testing\", \".*\", \"\\\\U\\\\0\", \"\")\n<\t\tresults in \"TESTING\".\n\n\t\tWhen {sub} starts with \"\\=\", the remainder is interpreted as\n\t\tan expression. See |sub-replace-expression|.  Example: >\n\t\t\t:echo substitute(s, '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g')\n\n<\t\tWhen {sub} is a Funcref that function is called, with one\n\t\toptional argument.  Example: >\n\t\t   :echo substitute(s, '%\\(\\x\\x\\)', SubNr, 'g')\n<\t\tThe optional argument is a list which contains the whole\n\t\tmatched string and up to nine submatches, like what\n\t\t|submatch()| returns.  Example: >\n\t\t   :echo substitute(s, '%\\(\\x\\x\\)', {m -> '0x' . m[1]}, 'g')\n\n<\t\tCan also be used as a |method|: >\n\t\t\tGetString()->substitute(pat, sub, flags)",
   "argsStr": "{string}, {pat}, {sub}, {flags}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "swapinfo",
   "description": "\t\tThe result is a dictionary, which holds information about the\n\t\tswapfile {fname}. The available fields are:\n\t\t\tversion VIM version\n\t\t\tuser\tuser name\n\t\t\thost\thost name\n\t\t\tfname\toriginal file name\n\t\t\tpid\tPID of the VIM process that created the swap\n\t\t\t\tfile\n\t\t\tmtime\tlast modification time in seconds\n\t\t\tinode\tOptional: INODE number of the file\n\t\t\tdirty\t1 if file was modified, 0 if not\n\t\tIn case of failure an \"error\" item is added with the reason:\n\t\t\tCannot open file: file not found or in accessible\n\t\t\tCannot read file: cannot read first block\n\t\t\tNot a swap file: does not contain correct block ID\n\t\t\tMagic number mismatch: Info in first block is invalid",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "swapname",
   "description": "\t\tThe result is the swap file path of the buffer {buf}.\n\t\tFor the use of {buf}, see |bufname()| above.\n\t\tIf buffer {buf} is the current buffer, the result is equal to\n\t\t|:swapname| (unless there is no swap file).\n\t\tIf buffer {buf} has no swap file, returns an empty string.",
   "argsStr": "{buf}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synID",
   "description": "\t\tThe result is a Number, which is the syntax ID at the position\n\t\t{lnum} and {col} in the current window.\n\t\tThe syntax ID can be used with |synIDattr()| and\n\t\t|synIDtrans()| to obtain syntax information about text.\n\n\t\t{col} is 1 for the leftmost column, {lnum} is 1 for the first\n\t\tline.  'synmaxcol' applies, in a longer line zero is returned.\n\t\tNote that when the position is after the last character,\n\t\tthat's where the cursor can be in Insert mode, synID() returns\n\t\tzero.  {lnum} is used like with |getline()|.\n\n\t\tWhen {trans} is |TRUE|, transparent items are reduced to the\n\t\titem that they reveal.  This is useful when wanting to know\n\t\tthe effective color.  When {trans} is |FALSE|, the transparent\n\t\titem is returned.  This is useful when wanting to know which\n\t\tsyntax item is effective (e.g. inside parens).\n\t\tWarning: This function can be very slow.  Best speed is\n\t\tobtained by going through the file in forward direction.\n\n\t\tExample (echoes the name of the syntax item under the cursor): >\n\t\t\t:echo synIDattr(synID(line(\".\"), col(\".\"), 1), \"name\")\n<",
   "argsStr": "{lnum}, {col}, {trans}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synIDattr",
   "description": "\t\tThe result is a String, which is the {what} attribute of\n\t\tsyntax ID {synID}.  This can be used to obtain information\n\t\tabout a syntax item.\n\t\t{mode} can be \"gui\", \"cterm\" or \"term\", to get the attributes\n\t\tfor that mode.  When {mode} is omitted, or an invalid value is\n\t\tused, the attributes for the currently active highlighting are\n\t\tused (GUI, cterm or term).\n\t\tUse synIDtrans() to follow linked highlight groups.\n\t\t{what}\t\tresult\n\t\t\"name\"\t\tthe name of the syntax item\n\t\t\"fg\"\t\tforeground color (GUI: color name used to set\n\t\t\t\tthe color, cterm: color number as a string,\n\t\t\t\tterm: empty string)\n\t\t\"bg\"\t\tbackground color (as with \"fg\")\n\t\t\"font\"\t\tfont name (only available in the GUI)\n\t\t\t\t|highlight-font|\n\t\t\"sp\"\t\tspecial color (as with \"fg\") |highlight-guisp|\n\t\t\"fg#\"\t\tlike \"fg\", but for the GUI and the GUI is\n\t\t\t\trunning the name in \"#RRGGBB\" form\n\t\t\"bg#\"\t\tlike \"fg#\" for \"bg\"\n\t\t\"sp#\"\t\tlike \"fg#\" for \"sp\"\n\t\t\"bold\"\t\t\"1\" if bold\n\t\t\"italic\"\t\"1\" if italic\n\t\t\"reverse\"\t\"1\" if reverse\n\t\t\"inverse\"\t\"1\" if inverse (= reverse)\n\t\t\"standout\"\t\"1\" if standout\n\t\t\"underline\"\t\"1\" if underlined\n\t\t\"undercurl\"\t\"1\" if undercurled\n\t\t\"strikethrough\"\t\"1\" if struckthrough\n\n\t\tExample (echoes the color of the syntax item under the\n\t\tcursor): >\n\t:echo synIDattr(synIDtrans(synID(line(\".\"), col(\".\"), 1)), \"fg\")\n<\n\t\tCan also be used as a |method|: >\n\t:echo synID(line(\".\"), col(\".\"), 1)->synIDtrans()->synIDattr(\"fg\")",
   "argsStr": "{synID}, {what} [, {mode}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synIDtrans",
   "description": "\t\tThe result is a Number, which is the translated syntax ID of\n\t\t{synID}.  This is the syntax group ID of what is being used to\n\t\thighlight the character.  Highlight links given with\n\t\t\":highlight link\" are followed.\n\n\t\tCan also be used as a |method|: >\n\t:echo synID(line(\".\"), col(\".\"), 1)->synIDtrans()->synIDattr(\"fg\")",
   "argsStr": "{synID}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synconcealed",
   "description": "\t\tThe result is a |List| with currently three items:\n\t\t1. The first item in the list is 0 if the character at the\n\t\t   position {lnum} and {col} is not part of a concealable\n\t\t   region, 1 if it is.  {lnum} is used like with |getline()|.\n\t\t2. The second item in the list is a string. If the first item\n\t\t   is 1, the second item contains the text which will be\n\t\t   displayed in place of the concealed text, depending on the\n\t\t   current setting of 'conceallevel' and 'listchars'.\n\t\t3. The third and final item in the list is a number\n\t\t   representing the specific syntax region matched in the\n\t\t   line. When the character is not concealed the value is\n\t\t   zero. This allows detection of the beginning of a new\n\t\t   concealable region if there are two consecutive regions\n\t\t   with the same replacement character.  For an example, if\n\t\t   the text is \"123456\" and both \"23\" and \"45\" are concealed\n\t\t   and replaced by the character \"X\", then:\n\t\t\tcall\t\t\treturns ~\n\t\t   \tsynconcealed(lnum, 1)   [0, '', 0]\n\t\t   \tsynconcealed(lnum, 2)   [1, 'X', 1]\n\t\t   \tsynconcealed(lnum, 3)   [1, 'X', 1]\n\t\t   \tsynconcealed(lnum, 4)   [1, 'X', 2]\n\t\t   \tsynconcealed(lnum, 5)   [1, 'X', 2]\n\t\t   \tsynconcealed(lnum, 6)   [0, '', 0]",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synstack",
   "description": "\t\tReturn a |List|, which is the stack of syntax items at the\n\t\tposition {lnum} and {col} in the current window.  {lnum} is\n\t\tused like with |getline()|.  Each item in the List is an ID\n\t\tlike what |synID()| returns.\n\t\tThe first item in the List is the outer region, following are\n\t\titems contained in that one.  The last one is what |synID()|\n\t\treturns, unless not the whole item is highlighted or it is a\n\t\ttransparent item.\n\t\tThis function is useful for debugging a syntax file.\n\t\tExample that shows the syntax stack under the cursor: >\n\t\t\tfor id in synstack(line(\".\"), col(\".\"))\n\t\t\t   echo synIDattr(id, \"name\")\n\t\t\tendfor\n<\t\tWhen the position specified with {lnum} and {col} is invalid\n\t\tnothing is returned.  The position just after the last\n\t\tcharacter in a line and the first column in an empty line are\n\t\tvalid positions.",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "system",
   "description": "\t\tGets the output of {cmd} as a |string| (|systemlist()| returns\n\t\ta |List|) and sets |v:shell_error| to the error code.\n\t\t{cmd} is treated as in |jobstart()|:\n\t\tIf {cmd} is a List it runs directly (no 'shell').\n\t\tIf {cmd} is a String it runs in the 'shell', like this: >\n\t\t  :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n\n<\t\tNot to be used for interactive commands.\n\n\t\tResult is a String, filtered to avoid platform-specific quirks:\n\t\t- <CR><NL> is replaced with <NL>\n\t\t- NUL characters are replaced with SOH (0x01)\n\n\t\tExample: >\n\t\t    :echo system(['ls', expand('%:h')])\n\n<\t\tIf {input} is a string it is written to a pipe and passed as\n\t\tstdin to the command.  The string is written as-is, line\n\t\tseparators are not changed.\n\t\tIf {input} is a |List| it is written to the pipe as\n\t\t|writefile()| does with {binary} set to \"b\" (i.e. with\n\t\ta newline between each list item, and newlines inside list\n\t\titems converted to NULs).\n\t\tWhen {input} is given and is a valid buffer id, the content of\n\t\tthe buffer is written to the file line by line, each line\n\t\tterminated by NL (and NUL where the text has NL).",
   "argsStr": "{cmd} [, {input}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5677",
   "description": "Note: system() cannot write to or read from backgrounded (\"&\")\n\t\tshell commands, e.g.: >\n\t\t    :echo system(\"cat - &\", \"foo\")\n<\t\twhich is equivalent to: >\n\t\t    $ echo foo | bash -c 'cat - &'\n<\t\tThe pipes are disconnected (unless overridden by shell\n\t\tredirection syntax) before input can reach it. Use\n\t\t|jobstart()| instead.\n\n\t\tNote: Use |shellescape()| or |::S| with |expand()| or\n\t\t|fnamemodify()| to escape special characters in a command\n\t\targument. 'shellquote' and 'shellxquote' must be properly\n\t\tconfigured. Example: >\n\t\t    :echo system('ls '..shellescape(expand('%:h')))\n\t\t    :echo system('ls '..expand('%:h:S'))\n\n<\t\tUnlike \":!cmd\" there is no automatic check for changed files.\n\t\tUse |:checktime| to force a check.\n\n\t\tCan also be used as a |method|: >\n\t\t\t:echo GetCmd()->system()",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "systemlist",
   "description": "\t\tSame as |system()|, but returns a |List| with lines (parts of\n\t\toutput separated by NL) with NULs transformed into NLs. Output\n\t\tis the same as |readfile()| will output with {binary} argument\n\t\tset to \"b\", except that a final newline is not preserved,\n\t\tunless {keepempty} is non-zero.\n\t\tNote that on MS-Windows you may get trailing CR characters.\n\n\t\tTo see the difference between \"echo hello\" and \"echo -n hello\"\n\t\tuse |system()| and |split()|: >\n\t\t\techo split(system('echo hello'), '\\n', 1)\n<\n\t\tReturns an empty string on error.\n\n\t\tCan also be used as a |method|: >\n\t\t\t:echo GetCmd()->systemlist()",
   "argsStr": "{cmd} [, {input} [, {keepempty}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagebuflist",
   "description": "\t\tThe result is a |List|, where each item is the number of the\n\t\tbuffer associated with each window in the current tab page.\n\t\t{arg} specifies the number of the tab page to be used. When\n\t\tomitted the current tab page is used.\n\t\tWhen {arg} is invalid the number zero is returned.\n\t\tTo get a list of all buffers in all tabs use this: >\n\t\t\tlet buflist = []\n\t\t\tfor i in range(tabpagenr('$'))\n\t\t\t   call extend(buflist, tabpagebuflist(i + 1))\n\t\t\tendfor\n<\t\tNote that a buffer may appear in more than one window.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagenr",
   "description": "\t\tThe result is a Number, which is the number of the current\n\t\ttab page.  The first tab page has number 1.\n\t\tThe optional argument {arg} supports the following values:\n\t\t\t$\tthe number of the last tab page (the tab page\n\t\t\t\tcount).\n\t\t\t#\tthe number of the last accessed tab page (where\n\t\t\t\t|g<Tab>| goes to).  If there is no previous\n\t\t\t\ttab page, 0 is returned.\n\t\tThe number can be used with the |:tab| command.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagewinnr",
   "description": "\t\tLike |winnr()| but for tab page {tabarg}.\n\t\t{tabarg} specifies the number of tab page to be used.\n\t\t{arg} is used like with |winnr()|:\n\t\t- When omitted the current window number is returned.  This is\n\t\t  the window which will be used when going to this tab page.\n\t\t- When \"$\" the number of windows is returned.\n\t\t- When \"#\" the previous window nr is returned.\n\t\tUseful examples: >\n\t\t    tabpagewinnr(1)\t    \" current window of tab page 1\n\t\t    tabpagewinnr(4, '$')    \" number of windows in tab page 4\n<\t\tWhen {tabarg} is invalid zero is returned.",
   "argsStr": "{tabarg} [, {arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tagfiles",
   "description": "Returns a |List| with the file names used to search for tags\n\t\tfor the current buffer.  This is the 'tags' option expanded.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "taglist",
   "description": "\t\tReturns a |List| of tags matching the regular expression {expr}.\n\n\t\tIf {filename} is passed it is used to prioritize the results\n\t\tin the same way that |:tselect| does. See |tag-priority|.\n\t\t{filename} should be the full path of the file.\n\n\t\tEach list item is a dictionary with at least the following\n\t\tentries:\n\t\t\tname\t\tName of the tag.\n\t\t\tfilename\tName of the file where the tag is\n\t\t\t\t\tdefined.  It is either relative to the\n\t\t\t\t\tcurrent directory or a full path.\n\t\t\tcmd\t\tEx command used to locate the tag in\n\t\t\t\t\tthe file.\n\t\t\tkind\t\tType of the tag.  The value for this\n\t\t\t\t\tentry depends on the language specific\n\t\t\t\t\tkind values.  Only available when\n\t\t\t\t\tusing a tags file generated by\n\t\t\t\t\tExuberant ctags or hdrtag.\n\t\t\tstatic\t\tA file specific tag.  Refer to\n\t\t\t\t\t|static-tag| for more information.\n\t\tMore entries may be present, depending on the content of the\n\t\ttags file: access, implementation, inherits and signature.\n\t\tRefer to the ctags documentation for information about these\n\t\tfields.  For C code the fields \"struct\", \"class\" and \"enum\"\n\t\tmay appear, they give the name of the entity the tag is\n\t\tcontained in.\n\n\t\tThe ex-command \"cmd\" can be either an ex search pattern, a\n\t\tline number or a line number followed by a byte number.\n\n\t\tIf there are no matching tags, then an empty list is returned.\n\n\t\tTo get an exact tag match, the anchors '^' and '$' should be\n\t\tused in {expr}.  This also make the function work faster.\n\t\tRefer to |tag-regexp| for more information about the tag\n\t\tsearch regular expression pattern.\n\n\t\tRefer to |'tags'| for information about how the tags file is\n\t\tlocated by Vim. Refer to |tags-file-format| for the format of\n\t\tthe tags file generated by the different ctags tools.",
   "argsStr": "{expr} [, {filename}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tempname",
   "description": "\t\tThe result is a String, which is the name of a file that\n\t\tdoesn't exist.  It can be used for a temporary file.  Example: >\n\t\t\t:let tmpfile = tempname()\n\t\t\t:exe \"redir > \" . tmpfile\n<\t\tFor Unix, the file will be in a private directory |tempfile|.\n\t\tFor MS-Windows forward slashes are used when the 'shellslash'\n\t\toption is set or when 'shellcmdflag' starts with '-'.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "termopen",
   "description": "\t\tSpawns {cmd} in a new pseudo-terminal session connected\n\t\tto the current buffer.  {cmd} is the same as the one passed to\n\t\t|jobstart()|.  This function fails if the current buffer is\n\t\tmodified (all buffer contents are destroyed).\n\n\t\tThe {opts} dict is similar to the one passed to |jobstart()|,\n\t\tbut the `pty`, `width`, `height`, and `TERM` fields are\n\t\tignored: `height`/`width` are taken from the current window\n\t\tand `$TERM` is set to \"xterm-256color\".\n\t\tReturns the same values as |jobstart()|.\n\n\t\tSee |terminal| for more information.\n\ntest_ functions are documented here: |test-functions-details|",
   "argsStr": "{cmd}[, {opts}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tan",
   "description": "\t\tReturn the tangent of {expr}, measured in radians, as a |Float|\n\t\tin the range [-inf, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo tan(10)\n<\t\t\t0.648361 >\n\t\t\t:echo tan(-4.01)\n<\t\t\t-1.181502\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->tan()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tanh",
   "description": "\t\tReturn the hyperbolic tangent of {expr} as a |Float| in the\n\t\trange [-1, 1].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo tanh(0.5)\n<\t\t\t0.462117 >\n\t\t\t:echo tanh(-1)\n<\t\t\t-0.761594\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->tanh()\n<",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_info",
   "description": "\t\tReturn a list with information about timers.\n\t\tWhen {id} is given only information about this timer is\n\t\treturned.  When timer {id} does not exist an empty list is\n\t\treturned.\n\t\tWhen {id} is omitted information about all timers is returned.\n\n\t\tFor each timer the information is stored in a |Dictionary| with\n\t\tthese items:\n\t\t    \"id\"\t    the timer ID\n\t\t    \"time\"\t    time the timer was started with\n\t\t    \"repeat\"\t    number of times the timer will still fire;\n\t\t\t\t    -1 means forever\n\t\t    \"callback\"\t    the callback",
   "argsStr": "[{id}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_pause",
   "description": "\t\tPause or unpause a timer.  A paused timer does not invoke its\n\t\tcallback when its time expires.  Unpausing a timer may cause\n\t\tthe callback to be invoked almost immediately if enough time\n\t\thas passed.\n\n\t\tPausing a timer is useful to avoid the callback to be called\n\t\tfor a short time.\n\n\t\tIf {paused} evaluates to a non-zero Number or a non-empty\n\t\tString, then the timer is paused, otherwise it is unpaused.\n\t\tSee |non-zero-arg|.",
   "argsStr": "{timer}, {paused}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_start",
   "description": "\t\tCreate a timer and return the timer ID.\n\n\t\t{time} is the waiting time in milliseconds. This is the\n\t\tminimum time before invoking the callback.  When the system is\n\t\tbusy or Vim is not waiting for input the time will be longer.\n\n\t\t{callback} is the function to call.  It can be the name of a\n\t\tfunction or a |Funcref|.  It is called with one argument, which\n\t\tis the timer ID.  The callback is only invoked when Vim is\n\t\twaiting for input.\n\n\t\t{options} is a dictionary.  Supported entries:\n\t\t   \"repeat\"\tNumber of times to repeat the callback.\n\t\t\t\t-1 means forever.  Default is 1.\n\t\t\t\tIf the timer causes an error three times in a\n\t\t\t\trow the repeat is cancelled.\n\n\t\tExample: >\n\t\t\tfunc MyHandler(timer)\n\t\t\t  echo 'Handler called'\n\t\t\tendfunc\n\t\t\tlet timer = timer_start(500, 'MyHandler',\n\t\t\t\t\\ {'repeat': 3})\n<\t\tThis invokes MyHandler() three times at 500 msec intervals.",
   "argsStr": "{time}, {callback} [, {options}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_stop",
   "description": "\t\tStop a timer.  The timer callback will no longer be invoked.\n\t\t{timer} is an ID returned by timer_start(), thus it must be a\n\t\tNumber.  If {timer} does not exist there is no error.",
   "argsStr": "{timer}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_stopall",
   "description": "\t\tStop all timers.  The timer callbacks will no longer be\n\t\tinvoked.  Useful if some timers is misbehaving.  If there are\n\t\tno timers there is no error.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tolower",
   "description": "\t\tThe result is a copy of the String given, with all uppercase\n\t\tcharacters turned into lowercase (just like applying |gu| to\n\t\tthe string).",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "toupper",
   "description": "\t\tThe result is a copy of the String given, with all lowercase\n\t\tcharacters turned into uppercase (just like applying |gU| to\n\t\tthe string).",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tr",
   "description": "\t\tThe result is a copy of the {src} string with all characters\n\t\twhich appear in {fromstr} replaced by the character in that\n\t\tposition in the {tostr} string.  Thus the first character in\n\t\t{fromstr} is translated into the first character in {tostr}\n\t\tand so on.  Exactly like the unix \"tr\" command.\n\t\tThis code also deals with multibyte characters properly.\n\n\t\tExamples: >\n\t\t\techo tr(\"hello there\", \"ht\", \"HT\")\n<\t\treturns \"Hello THere\" >\n\t\t\techo tr(\"<blob>\", \"<>\", \"{}\")\n<\t\treturns \"{blob}\"",
   "argsStr": "{src}, {fromstr}, {tostr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "trim",
   "description": "\t\tReturn {text} as a String where any character in {mask} is\n\t\tremoved from the beginning and/or end of {text}.\n\t\tIf {mask} is not given, {mask} is all characters up to 0x20,\n\t\twhich includes Tab, space, NL and CR, plus the non-breaking\n\t\tspace character 0xa0.\n\t\tThe optional {dir} argument specifies where to remove the\n\t\tcharacters:\n\t\t\t0\tremove from the beginning and end of {text}\n\t\t\t1\tremove only at the beginning of {text}\n\t\t\t2\tremove only at the end of {text}\n\t\tWhen omitted both ends are trimmed.\n\t\tThis function deals with multibyte characters properly.\n\t\tExamples: >\n\t\t\techo trim(\"   some text \")\n<\t\treturns \"some text\" >\n\t\t\techo trim(\"  \\r\\t\\t\\r RESERVE \\t\\n\\x0B\\xA0\") . \"_TAIL\"\n<\t\treturns \"RESERVE_TAIL\" >\n\t\t\techo trim(\"rm<Xrm<>X>rrm\", \"rm<>\")\n<\t\treturns \"Xrm<>X\" (characters in the middle are not removed) >\n\t\t\techo trim(\"  vim  \", \" \", 2)\n<\t\treturns \"  vim\"",
   "argsStr": "{text} [, {mask} [, {dir}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "trunc",
   "description": "\t\tReturn the largest integral value with magnitude less than or\n\t\tequal to {expr} as a |Float| (truncate towards zero).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo trunc(1.456)\n<\t\t\t1.0  >\n\t\t\techo trunc(-5.456)\n<\t\t\t-5.0  >\n\t\t\techo trunc(4.0)\n<\t\t\t4.0\n\n\t\tCan also be used as a |method|: >\n\t\t\tCompute()->trunc()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "type",
   "description": "\t\tThe result is a Number representing the type of {expr}.\n\t\tInstead of using the number directly, it is better to use the\n\t\tv:t_ variable that has the value:\n\t\t        Number:     0 (|v:t_number|)\n\t\t\tString:     1 (|v:t_string|)\n\t\t\tFuncref:    2 (|v:t_func|)\n\t\t\tList:       3 (|v:t_list|)\n\t\t\tDictionary: 4 (|v:t_dict|)\n\t\t\tFloat:      5 (|v:t_float|)\n\t\t\tBoolean:    6 (|v:true| and |v:false|)\n\t\t\tNull:       7 (|v:null|)\n\t\t\tBlob:      10 (|v:t_blob|)\n\t\tFor backward compatibility, this method can be used: >\n\t\t\t:if type(myvar) == type(0)\n\t\t\t:if type(myvar) == type(\"\")\n\t\t\t:if type(myvar) == type(function(\"tr\"))\n\t\t\t:if type(myvar) == type([])\n\t\t\t:if type(myvar) == type({})\n\t\t\t:if type(myvar) == type(0.0)\n\t\t\t:if type(myvar) == type(v:true)\n<\t\tIn place of checking for |v:null| type it is better to check\n\t\tfor |v:null| directly as it is the only value of this type: >\n\t\t\t:if myvar is v:null\n<               To check if the v:t_ variables exist use this: >\n                        :if exists('v:t_number')\n\n<\t\tCan also be used as a |method|: >\n\t\t\tmylist->type()",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "undofile",
   "description": "\t\tReturn the name of the undo file that would be used for a file\n\t\twith name {name} when writing.  This uses the 'undodir'\n\t\toption, finding directories that exist.  It does not check if\n\t\tthe undo file exists.\n\t\t{name} is always expanded to the full path, since that is what\n\t\tis used internally.\n\t\tIf {name} is empty undofile() returns an empty string, since a\n\t\tbuffer without a file name will not write an undo file.\n\t\tUseful in combination with |:wundo| and |:rundo|.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "undotree",
   "description": "\t\tReturn the current state of the undo tree in a dictionary with\n\t\tthe following items:\n\t\t  \"seq_last\"\tThe highest undo sequence number used.\n\t\t  \"seq_cur\"\tThe sequence number of the current position in\n\t\t\t\tthe undo tree.  This differs from \"seq_last\"\n\t\t\t\twhen some changes were undone.\n\t\t  \"time_cur\"\tTime last used for |:earlier| and related\n\t\t\t\tcommands.  Use |strftime()| to convert to\n\t\t\t\tsomething readable.\n\t\t  \"save_last\"\tNumber of the last file write.  Zero when no\n\t\t\t\twrite yet.\n\t\t  \"save_cur\"\tNumber of the current position in the undo\n\t\t\t\ttree.\n\t\t  \"synced\"\tNon-zero when the last undo block was synced.\n\t\t\t\tThis happens when waiting from input from the\n\t\t\t\tuser.  See |undo-blocks|.\n\t\t  \"entries\"\tA list of dictionaries with information about\n\t\t\t\tundo blocks.\n\n\t\tThe first item in the \"entries\" list is the oldest undo item.\n\t\tEach List item is a |Dictionary| with these items:\n\t\t  \"seq\"\t\tUndo sequence number.  Same as what appears in\n\t\t\t\t|:undolist|.\n\t\t  \"time\"\tTimestamp when the change happened.  Use\n\t\t\t\t|strftime()| to convert to something readable.\n\t\t  \"newhead\"\tOnly appears in the item that is the last one\n\t\t\t\tthat was added.  This marks the last change\n\t\t\t\tand where further changes will be added.\n\t\t  \"curhead\"\tOnly appears in the item that is the last one\n\t\t\t\tthat was undone.  This marks the current\n\t\t\t\tposition in the undo tree, the block that will\n\t\t\t\tbe used by a redo command.  When nothing was\n\t\t\t\tundone after the last change this item will\n\t\t\t\tnot appear anywhere.\n\t\t  \"save\"\tOnly appears on the last block before a file\n\t\t\t\twrite.  The number is the write count.  The\n\t\t\t\tfirst write has number 1, the last one the\n\t\t\t\t\"save_last\" mentioned above.\n\t\t  \"alt\"\t\tAlternate entry.  This is again a List of undo\n\t\t\t\tblocks.  Each item may again have an \"alt\"\n\t\t\t\titem.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "uniq",
   "description": "\t\tRemove second and succeeding copies of repeated adjacent\n\t\t{list} items in-place.  Returns {list}.  If you want a list\n\t\tto remain unmodified make a copy first: >\n\t\t\t:let newlist = uniq(copy(mylist))\n<\t\tThe default compare function uses the string representation of\n\t\teach item.  For the use of {func} and {dict} see |sort()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmylist->uniq()",
   "argsStr": "{list} [, {func} [, {dict}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "values",
   "description": "\t\tReturn a |List| with all the values of {dict}.  The |List| is\n\t\tin arbitrary order.  Also see |items()| and |keys()|.\n\n\t\tCan also be used as a |method|: >\n\t\t\tmydict->values()",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "virtcol",
   "description": "\t\tThe result is a Number, which is the screen column of the file\n\t\tposition given with {expr}.  That is, the last screen position\n\t\toccupied by the character at that position, when the screen\n\t\twould be of unlimited width.  When there is a <Tab> at the\n\t\tposition, the returned Number will be the column at the end of\n\t\tthe <Tab>.  For example, for a <Tab> in column 1, with 'ts'\n\t\tset to 8, it returns 8. |conceal| is ignored.\n\t\tFor the byte position use |col()|.\n\t\tFor the use of {expr} see |col()|.\n\t\tWhen 'virtualedit' is used {expr} can be [lnum, col, off], where\n\t\t\"off\" is the offset in screen columns from the start of the\n\t\tcharacter.  E.g., a position within a <Tab> or after the last\n\t\tcharacter.  When \"off\" is omitted zero is used.\n\t\tWhen Virtual editing is active in the current mode, a position\n\t\tbeyond the end of the line can be returned. |'virtualedit'|\n\t\tThe accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the end of the cursor line (the result is the\n\t\t\t    number of displayed characters in the cursor line\n\t\t\t    plus one)\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    v       In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tNote that only marks in the current file can be used.\n\t\tExamples: >\n  virtcol(\".\")\t   with text \"foo^Lbar\", with cursor on the \"^L\", returns 5\n  virtcol(\"$\")\t   with text \"foo^Lbar\", returns 9\n  virtcol(\"'t\")    with text \"\t  there\", with 't at 'h', returns 6\n<\t\tThe first column is 1.  0 is returned for an error.\n\t\tA more advanced example that echoes the maximum length of\n\t\tall lines: >\n\t\t    echo max(map(range(1, line('$')), \"virtcol([v:val, '$'])\"))",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "visualmode",
   "description": "\t\tThe result is a String, which describes the last Visual mode\n\t\tused in the current buffer.  Initially it returns an empty\n\t\tstring, but once Visual mode has been used, it returns \"v\",\n\t\t\"V\", or \"<CTRL-V>\" (a single CTRL-V character) for\n\t\tcharacter-wise, line-wise, or block-wise Visual mode\n\t\trespectively.\n\t\tExample: >\n\t\t\t:exe \"normal \" . visualmode()\n<\t\tThis enters the same Visual mode as before.  It is also useful\n\t\tin scripts if you wish to act differently depending on the\n\t\tVisual mode that was used.\n\t\tIf Visual mode is active, use |mode()| to get the Visual mode\n\t\t(e.g., in a |:vmap|).\n\t\tIf [expr] is supplied and it evaluates to a non-zero Number or\n\t\ta non-empty String, then the Visual mode will be cleared and\n\t\tthe old value is returned.  See |non-zero-arg|.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wait",
   "description": "\t\tWaits until {condition} evaluates to |TRUE|, where {condition}\n\t\tis a |Funcref| or |string| containing an expression.\n\n\t\t{timeout} is the maximum waiting time in milliseconds, -1\n\t\tmeans forever.\n\n\t\tCondition is evaluated on user events, internal events, and\n\t\tevery {interval} milliseconds (default: 200).\n\n\t\tReturns a status integer:\n\t\t\t0 if the condition was satisfied before timeout\n\t\t\t-1 if the timeout was exceeded\n\t\t\t-2 if the function was interrupted (by |CTRL-C|)\n\t\t\t-3 if an error occurred",
   "argsStr": "{timeout}, {condition}[, {interval}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wildmenumode",
   "description": "\t\tReturns |TRUE| when the wildmenu is active and |FALSE|\n\t\totherwise.  See 'wildmenu' and 'wildmode'.\n\t\tThis can be used in mappings to handle the 'wildcharm' option\n\t\tgracefully. (Makes only sense with |mapmode-c| mappings).\n\n\t\tFor example to make <c-j> work like <down> in wildmode, use: >\n    :cnoremap <expr> <C-j> wildmenumode() ? \"\\<Down>\\<Tab>\" : \"\\<c-j>\"\n<\n\t\t(Note, this needs the 'wildcharm' option set appropriately).",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_execute",
   "description": "\t\tLike `execute()` but in the context of window {id}.\n\t\tThe window will temporarily be made the current window,\n\t\twithout triggering autocommands.\n\t\tExample: >\n\t\t\tcall win_execute(winid, 'syntax enable')",
   "argsStr": "{id}, {command} [, {silent}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_findbuf",
   "description": "\t\tReturns a |List| with |window-ID|s for windows that contain\n\t\tbuffer {bufnr}.  When there is none the list is empty.",
   "argsStr": "{bufnr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_getid",
   "description": "\t\tGet the |window-ID| for the specified window.\n\t\tWhen {win} is missing use the current window.\n\t\tWith {win} this is the window number.  The top window has\n\t\tnumber 1.\n\t\tWithout {tab} use the current tab, otherwise the tab with\n\t\tnumber {tab}.  The first tab has number one.\n\t\tReturn zero if the window cannot be found.",
   "argsStr": "[{win} [, {tab}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_gettype",
   "description": "\t\tReturn the type of the window:\n\t\t\t\"autocmd\"\tautocommand window. Temporary window\n\t\t\t\t\tused to execute autocommands.\n\t\t\t\"command\"\tcommand-line window |cmdwin|\n\t\t\t(empty)\t\tnormal window\n\t\t\t\"loclist\"\t|location-list-window|\n\t\t\t\"popup\"\t\tpopup window |popup|\n\t\t\t\"preview\"\tpreview window |preview-window|\n\t\t\t\"quickfix\"\t|quickfix-window|\n\t\t\t\"unknown\"\twindow {nr} not found\n\n\t\tWhen {nr} is omitted return the type of the current window.\n\t\tWhen {nr} is given return the type of this window by number or\n\t\t|window-ID|.\n\n\t\tAlso see the 'buftype' option.  When running a terminal in a\n\t\tpopup window then 'buftype' is \"terminal\" and win_gettype()\n\t\treturns \"popup\".",
   "argsStr": "[{nr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_gotoid",
   "description": "\t\tGo to window with ID {expr}.  This may also change the current\n\t\ttabpage.\n\t\tReturn TRUE if successful, FALSE if the window cannot be found.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_id2tabwin",
   "description": "\t\tReturn a list with the tab number and window number of window\n\t\twith ID {expr}: [tabnr, winnr].\n\t\tReturn [0, 0] if the window cannot be found.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_id2win",
   "description": "\t\tReturn the window number of window with ID {expr}.\n\t\tReturn 0 if the window cannot be found in the current tabpage.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_screenpos",
   "description": "\t\tReturn the screen position of window {nr} as a list with two\n\t\tnumbers: [row, col].  The first window always has position\n\t\t[1, 1], unless there is a tabline, then it is [2, 1].\n\t\t{nr} can be the window number or the |window-ID|.  Use zero\n\t\tfor the current window.\n\t\tReturns [0, 0] if the window cannot be found in the current\n\t\ttabpage.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_splitmove",
   "description": "\t\tMove the window {nr} to a new split of the window {target}.\n\t\tThis is similar to moving to {target}, creating a new window\n\t\tusing |:split| but having the same contents as window {nr}, and\n\t\tthen closing {nr}.\n\n\t\tBoth {nr} and {target} can be window numbers or |window-ID|s.\n\t\tBoth must be in the current tab page.\n\n\t\tReturns zero for success, non-zero for failure.\n\n\t\t{options} is a |Dictionary| with the following optional entries:\n\t\t  \"vertical\"\tWhen TRUE, the split is created vertically,\n\t\t\t\tlike with |:vsplit|.\n\t\t  \"rightbelow\"\tWhen TRUE, the split is made below or to the\n\t\t\t\tright (if vertical).  When FALSE, it is done\n\t\t\t\tabove or to the left (if vertical).  When not\n\t\t\t\tpresent, the values of 'splitbelow' and\n\t\t\t\t'splitright' are used.",
   "argsStr": "{nr}, {target} [, {options}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winbufnr",
   "description": "The result is a Number, which is the number of the buffer\n\t\tassociated with window {nr}.  {nr} can be the window number or\n\t\tthe |window-ID|.\n\t\tWhen {nr} is zero, the number of the buffer in the current\n\t\twindow is returned.\n\t\tWhen window {nr} doesn't exist, -1 is returned.\n\t\tExample: >\n  :echo \"The file in the current window is \" . bufname(winbufnr(0))\n<\n\t\tCan also be used as a |method|: >\n\t\t\tFindWindow()->winbufnr()->bufname()\n<",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wincol",
   "description": "The result is a Number, which is the virtual column of the\n\t\tcursor in the window.  This is counting screen cells from the\n\t\tleft side of the window.  The leftmost column is one.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "windowsversion",
   "description": "\t\tThe result is a String.  For MS-Windows it indicates the OS\n\t\tversion.  E.g, Windows 10 is \"10.0\", Windows 8 is \"6.2\",\n\t\tWindows XP is \"5.1\".  For non-MS-Windows systems the result is\n\t\tan empty string.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winheight",
   "description": "\t\tThe result is a Number, which is the height of window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero, the height of the current window is\n\t\treturned.  When window {nr} doesn't exist, -1 is returned.\n\t\tAn existing window always has a height of zero or more.\n\t\tThis excludes any window toolbar line.\n\t\tExamples: >\n  :echo \"The current window has \" . winheight(0) . \" lines.\"\n<",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winlayout",
   "description": "\t\tThe result is a nested List containing the layout of windows\n\t\tin a tabpage.\n\n\t\tWithout {tabnr} use the current tabpage, otherwise the tabpage\n\t\twith number {tabnr}. If the tabpage {tabnr} is not found,\n\t\treturns an empty list.\n\n\t\tFor a leaf window, it returns:\n\t\t\t['leaf', {winid}]\n\t\tFor horizontally split windows, which form a column, it\n\t\treturns:\n\t\t\t['col', [{nested list of windows}]]\n\t\tFor vertically split windows, which form a row, it returns:\n\t\t\t['row', [{nested list of windows}]]\n\n\t\tExample: >\n\t\t\t\" Only one window in the tab page\n\t\t\t:echo winlayout()\n\t\t\t['leaf', 1000]\n\t\t\t\" Two horizontally split windows\n\t\t\t:echo winlayout()\n\t\t\t['col', [['leaf', 1000], ['leaf', 1001]]]\n\t\t\t\" The second tab page, with three horizontally split\n\t\t\t\" windows, with two vertically split windows in the\n\t\t\t\" middle window\n\t\t\t:echo winlayout(2)\n\t\t\t['col', [['leaf', 1002], ['row', [['leaf', 1003],\n\t\t\t\t\t    ['leaf', 1001]]], ['leaf', 1000]]]\n<",
   "argsStr": "[{tabnr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winline",
   "description": "The result is a Number, which is the screen line of the cursor\n\t\tin the window.  This is counting screen lines from the top of\n\t\tthe window.  The first line is one.\n\t\tIf the cursor was moved the view on the file will be updated\n\t\tfirst, this may cause a scroll.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winnr",
   "description": "The result is a Number, which is the number of the current\n\t\twindow.  The top window has number 1.\n\t\tReturns zero for a popup window.\n\n\t\tThe optional argument {arg} supports the following values:\n\t\t\t$\tthe number of the last window (the window\n\t\t\t\tcount).\n\t\t\t#\tthe number of the last accessed window (where\n\t\t\t\t|CTRL-W_p| goes to).  If there is no previous\n\t\t\t\twindow or it is in another tab page 0 is\n\t\t\t\treturned.\n\t\t\t{N}j\tthe number of the Nth window below the\n\t\t\t\tcurrent window (where |CTRL-W_j| goes to).\n\t\t\t{N}k\tthe number of the Nth window above the current\n\t\t\t\twindow (where |CTRL-W_k| goes to).\n\t\t\t{N}h\tthe number of the Nth window left of the\n\t\t\t\tcurrent window (where |CTRL-W_h| goes to).\n\t\t\t{N}l\tthe number of the Nth window right of the\n\t\t\t\tcurrent window (where |CTRL-W_l| goes to).\n\t\tThe number can be used with |CTRL-W_w| and \":wincmd w\"\n\t\t|:wincmd|.\n\t\tAlso see |tabpagewinnr()| and |win_getid()|.\n\t\tExamples: >\n\t\t\tlet window_count = winnr('$')\n\t\t\tlet prev_window = winnr('#')\n\t\t\tlet wnum = winnr('3k')\n<",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winrestcmd",
   "description": "Returns a sequence of |:resize| commands that should restore\n\t\tthe current window sizes.  Only works properly when no windows\n\t\tare opened or closed and the current window and tab page is\n\t\tunchanged.\n\t\tExample: >\n\t\t\t:let cmd = winrestcmd()\n\t\t\t:call MessWithWindowSizes()\n\t\t\t:exe cmd\n<",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winrestview",
   "description": "\t\tUses the |Dictionary| returned by |winsaveview()| to restore\n\t\tthe view of the current window.\n\t\tNote: The {dict} does not have to contain all values, that are\n\t\treturned by |winsaveview()|. If values are missing, those\n\t\tsettings won't be restored. So you can use: >\n\t\t    :call winrestview({'curswant': 4})\n<\n\t\tThis will only set the curswant value (the column the cursor\n\t\twants to move on vertical movements) of the cursor to column 5\n\t\t(yes, that is 5), while all other settings will remain the\n\t\tsame. This is useful, if you set the cursor position manually.\n\n\t\tIf you have changed the values the result is unpredictable.\n\t\tIf the window size changed the result won't be the same.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winsaveview",
   "description": "Returns a |Dictionary| that contains information to restore\n\t\tthe view of the current window.  Use |winrestview()| to\n\t\trestore the view.\n\t\tThis is useful if you have a mapping that jumps around in the\n\t\tbuffer and you want to go back to the original view.\n\t\tThis does not save fold information.  Use the 'foldenable'\n\t\toption to temporarily switch off folding, so that folds are\n\t\tnot opened when moving around. This may have side effects.\n\t\tThe return value includes:\n\t\t\tlnum\t\tcursor line number\n\t\t\tcol\t\tcursor column (Note: the first column\n\t\t\t\t\tzero, as opposed to what getpos()\n\t\t\t\t\treturns)\n\t\t\tcoladd\t\tcursor column offset for 'virtualedit'\n\t\t\tcurswant\tcolumn for vertical movement\n\t\t\ttopline\t\tfirst line in the window\n\t\t\ttopfill\t\tfiller lines, only in diff mode\n\t\t\tleftcol\t\tfirst column displayed; only used when\n\t\t\t\t\t'wrap' is off\n\t\t\tskipcol\t\tcolumns skipped\n\t\tNote that no option values are saved.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winwidth",
   "description": "\t\tThe result is a Number, which is the width of window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero, the width of the current window is\n\t\treturned.  When window {nr} doesn't exist, -1 is returned.\n\t\tAn existing window always has a width of zero or more.\n\t\tExamples: >\n  :echo \"The current window has \" . winwidth(0) . \" columns.\"\n  :if winwidth(0) <= 50\n  :  50 wincmd |\n  :endif\n<\t\tFor getting the terminal or screen size, see the 'columns'\n\t\toption.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wordcount",
   "description": "\t\tThe result is a dictionary of byte/chars/word statistics for\n\t\tthe current buffer.  This is the same info as provided by\n\t\t|g_CTRL-G|\n\t\tThe return value includes:\n\t\t\tbytes\t\tNumber of bytes in the buffer\n\t\t\tchars\t\tNumber of chars in the buffer\n\t\t\twords\t\tNumber of words in the buffer\n\t\t\tcursor_bytes    Number of bytes before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tcursor_chars    Number of chars before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tcursor_words    Number of words before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tvisual_bytes    Number of bytes visually selected\n\t\t\t\t\t(only in Visual mode)\n\t\t\tvisual_chars    Number of chars visually selected\n\t\t\t\t\t(only in Visual mode)\n\t\t\tvisual_words    Number of words visually selected\n\t\t\t\t\t(only in Visual mode)",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "writefile",
   "description": "\t\tWhen {object} is a |List| write it to file {fname}.  Each list\n\t\titem is separated with a NL.  Each list item must be a String\n\t\tor Number.\n\t\tWhen {flags} contains \"b\" then binary mode is used: There will\n\t\tnot be a NL after the last list item.  An empty item at the\n\t\tend does cause the last line in the file to end in a NL.\n\n\t\tWhen {object} is a |Blob| write the bytes to file {fname}\n\t\tunmodified.\n\n\t\tWhen {flags} contains \"a\" then append mode is used, lines are\n\t\tappended to the file: >\n\t\t\t:call writefile([\"foo\"], \"event.log\", \"a\")\n\t\t\t:call writefile([\"bar\"], \"event.log\", \"a\")\n<\n\t\tWhen {flags} contains \"S\" fsync() call is not used, with \"s\"\n\t\tit is used, 'fsync' option applies by default. No fsync()\n\t\tmeans that writefile() will finish faster, but writes may be\n\t\tleft in OS buffers and not yet written to disk. Such changes\n\t\twill disappear if system crashes before OS does writing.\n\n\t\tAll NL characters are replaced with a NUL character.\n\t\tInserting CR characters needs to be done before passing {list}\n\t\tto writefile().\n\t\tAn existing file is overwritten, if possible.\n\t\tWhen the write fails -1 is returned, otherwise 0.  There is an\n\t\terror message if the file can't be created or when writing\n\t\tfails.\n\t\tAlso see |readfile()|.\n\t\tTo copy a file byte for byte: >\n\t\t\t:let fl = readfile(\"foo\", \"b\")\n\t\t\t:call writefile(fl, \"foocopy\", \"b\")",
   "argsStr": "{object}, {fname} [, {flags}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "xor",
   "description": "\t\tBitwise XOR on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let bits = xor(bits, 0x80)\n<\t\tCan also be used as a |method|: >\n\t\t\t:let bits = bits->xor(0x80)\n<",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "string-match",
   "description": "A regexp pattern as explained at |pattern| is normally used to find a match in\nthe buffer lines.  When a pattern is used to find a match in a String, almost\neverything works in the same way.  The difference is that a String is handled\nlike it is one line.  When it contains a \"\\n\" character, this is not seen as a\nline break for the pattern.  It can be matched with a \"\\n\" in the pattern, or\nwith \".\".  Example: >\n\t:let a = \"aaaa\\nxxxx\"\n\t:echo matchstr(a, \"..\\n..\")\n\taa\n\txx\n\t:echo matchstr(a, \"a.x\")\n\ta\n\tx\n\nDon't forget that \"^\" will only match at the first character of the String and\n\"$\" at the last character of the string.  They don't match after or before a\n\"\\n\".",
   "valuetype": "any"
  }
 ]
}