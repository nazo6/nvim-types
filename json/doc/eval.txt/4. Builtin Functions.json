{
 "leftTitle": "4. Builtin Functions",
 "rightTitle": "vim-function* *functions",
 "description": "",
 "data": [
  {
   "type": "func",
   "name": "abs",
   "description": "Return the absolute value of {expr}.  When {expr} evaluates to\n\t\ta |Float| abs() returns a |Float|.  When {expr} can be\n\t\tconverted to a |Number| abs() returns a |Number|.  Otherwise\n\t\tabs() gives an error message and returns -1.\n\t\tExamples: >\n\t\t\techo abs(1.456)\n<\t\t\t1.456  >\n\t\t\techo abs(-5.456)\n<\t\t\t5.456  >\n\t\t\techo abs(-4)\n<\t\t\t4",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "acos",
   "description": "Return the arc cosine of {expr} measured in radians, as a\n\t\t|Float| in the range of [0, pi].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo acos(0)\n<\t\t\t1.570796 >\n\t\t\t:echo acos(-0.5)\n<\t\t\t2.094395",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "add",
   "description": "Append the item {expr} to |List| {list}.  Returns the\n\t\tresulting |List|.  Examples: >\n\t\t\t:let alist = add([1, 2, 3], item)\n\t\t\t:call add(mylist, \"woodstock\")\n<\t\tNote that when {expr} is a |List| it is appended as a single\n\t\titem.  Use |extend()| to concatenate |Lists|.\n\t\tUse |insert()| to add an item at another position.",
   "argsStr": "{list}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "and",
   "description": "Bitwise AND on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let flag = and(bits, 0x80)",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "api_info",
   "description": "Returns Dictionary of |api-metadata|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "append",
   "description": "When {text} is a |List|: Append each item of the |List| as a\n\t\ttext line below line {lnum} in the current buffer.\n\t\tOtherwise append {text} as one text line below line {lnum} in\n\t\tthe current buffer.\n\t\t{lnum} can be zero to insert a line before the first one.\n\t\tReturns 1 for failure ({lnum} out of range or out of memory),\n\t\t0 for success.  Example: >\n\t\t\t:let failed = append(line('$'), \"# THE END\")\n\t\t\t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])",
   "argsStr": "{lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "appendbufline",
   "description": "Like |append()| but append the text in buffer {expr}.",
   "argsStr": "{expr}, {lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argc",
   "description": "The result is the number of files in the argument list.  See\n\t\t|arglist|.\n\t\tIf {winid} is not supplied, the argument list of the current\n\t\twindow is used.\n\t\tIf {winid} is -1, the global argument list is used.\n\t\tOtherwise {winid} specifies the window of which the argument\n\t\tlist is used: either the window number or the window ID.\n\t\tReturns -1 if the {winid} argument is invalid.",
   "argsStr": "[{winid}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argidx",
   "description": "The result is the current index in the argument list.  0 is\n\t\tthe first file.  argc() - 1 is the last one.  See |arglist|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "arglistid",
   "description": "Return the argument list ID.  This is a number which\n\t\tidentifies the argument list being used.  Zero is used for the\n\t\tglobal argument list.  See |arglist|.\n\t\tReturns -1 if the arguments are invalid.",
   "argsStr": "[{winnr} [, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "argv",
   "description": "The result is the {nr}th file in the argument list.  See\n\t\t|arglist|.  \"argv(0)\" is the first one.  Example: >\n\t:let i = 0\n\t:while i < argc()\n\t:  let f = escape(fnameescape(argv(i)), '.')\n\t:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'\n\t:  let i = i + 1\n\t:endwhile\n<\t\tWithout the {nr} argument, or when {nr} is -1, a |List| with\n\t\tthe whole |arglist| is returned.",
   "argsStr": "[{nr} [, {winid}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_beeps",
   "description": "Run {cmd} and add an error message to |v:errors| if it does\n\t\tNOT produce a beep or visual bell.\n\t\tAlso see |assert_fails()| and |assert-return|.",
   "argsStr": "{cmd}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_equal",
   "description": "When {expected} and {actual} are not equal an error message is\n\t\tadded to |v:errors| and 1 is returned.  Otherwise zero is\n\t\treturned |assert-return|.\n\t\tThere is no automatic conversion, the String \"4\" is different\n\t\tfrom the Number 4.  And the number 4 is different from the\n\t\tFloat 4.0.  The value of 'ignorecase' is not used here, case\n\t\talways matters.\n\t\tWhen {msg} is omitted an error in the form \"Expected\n\t\t{expected} but got {actual}\" is produced.\n\t\tExample: >\n\tassert_equal('foo', 'bar')\n<\t\tWill result in a string to be added to |v:errors|:\n\ttest.vim line 12: Expected 'foo' but got 'bar' ~",
   "argsStr": "{expected}, {actual}, [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_equalfile",
   "description": "When the files {fname-one} and {fname-two} do not contain\n\t\texactly the same text an error message is added to |v:errors|.\n\t\tAlso see |assert-return|.\n\t\tWhen {fname-one} or {fname-two} does not exist the error will\n\t\tmention that.",
   "argsStr": "{fname-one}, {fname-two} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_exception",
   "description": "When v:exception does not contain the string {error} an error\n\t\tmessage is added to |v:errors|.  Also see |assert-return|.\n\t\tThis can be used to assert that a command throws an exception.\n\t\tUsing the error number, followed by a colon, avoids problems\n\t\twith translations: >\n\t\t\ttry\n\t\t\t  commandthatfails\n\t\t\t  call assert_false(1, 'command should have failed')\n\t\t\tcatch\n\t\t\t  call assert_exception('E492:')\n\t\t\tendtry",
   "argsStr": "{error} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_fails",
   "description": "Run {cmd} and add an error message to |v:errors| if it does\n\t\tNOT produce an error.  Also see |assert-return|.\n\t\tWhen {error} is given it must match in |v:errmsg|.\n\t\tNote that beeping is not considered an error, and some failing\n\t\tcommands only beep.  Use |assert_beeps()| for those.",
   "argsStr": "{cmd} [, {error} [, {msg}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_false",
   "description": "When {actual} is not false an error message is added to\n\t\t|v:errors|, like with |assert_equal()|.\n\t\tAlso see |assert-return|.\n\t\tA value is false when it is zero or |v:false|. When \"{actual}\"\n\t\tis not a number or |v:false| the assert fails.\n\t\tWhen {msg} is omitted an error in the form\n\t\t\"Expected False but got {actual}\" is produced.",
   "argsStr": "{actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_inrange",
   "description": "This asserts number and |Float| values.  When {actual}  is lower\n\t\tthan {lower} or higher than {upper} an error message is added\n\t\tto |v:errors|.  Also see |assert-return|.\n\t\tWhen {msg} is omitted an error in the form\n\t\t\"Expected range {lower} - {upper}, but got {actual}\" is\n\t\tproduced.",
   "argsStr": "{lower}, {upper}, {actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_match",
   "description": "When {pattern} does not match {actual} an error message is\n\t\tadded to |v:errors|.  Also see |assert-return|.",
   "argsStr": "{pattern}, {actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_notequal",
   "description": "The opposite of `assert_equal()`: add an error message to\n\t\t|v:errors| when {expected} and {actual} are equal.\n\t\tAlso see |assert-return|.",
   "argsStr": "{expected}, {actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_notmatch",
   "description": "The opposite of `assert_match()`: add an error message to\n\t\t|v:errors| when {pattern} matches {actual}.\n\t\tAlso see |assert-return|.",
   "argsStr": "{pattern}, {actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_report",
   "description": "Report a test failure directly, using {msg}.\n\t\tAlways returns one.",
   "argsStr": "{msg}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "assert_true",
   "description": "When {actual} is not true an error message is added to\n\t\t|v:errors|, like with |assert_equal()|.\n\t\tAlso see |assert-return|.\n\t\tA value is |TRUE| when it is a non-zero number or |v:true|.\n\t\tWhen {actual} is not a number or |v:true| the assert fails.\n\t\tWhen {msg} is omitted an error in the form \"Expected True but\n\t\tgot {actual}\" is produced.",
   "argsStr": "{actual} [, {msg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "asin",
   "description": "Return the arc sine of {expr} measured in radians, as a |Float|\n\t\tin the range of [-pi/2, pi/2].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo asin(0.8)\n<\t\t\t0.927295 >\n\t\t\t:echo asin(-0.5)\n<\t\t\t-0.523599",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "atan",
   "description": "Return the principal value of the arc tangent of {expr}, in\n\t\tthe range [-pi/2, +pi/2] radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan(100)\n<\t\t\t1.560797 >\n\t\t\t:echo atan(-4.01)\n<\t\t\t-1.326405",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "atan2",
   "description": "Return the arc tangent of {expr1} / {expr2}, measured in\n\t\tradians, as a |Float| in the range [-pi, pi].\n\t\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan2(-1, 1)\n<\t\t\t-0.785398 >\n\t\t\t:echo atan2(1, -1)\n<\t\t\t2.356194",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "browse",
   "description": "Put up a file requester.  This only works when \"has(\"browse\")\"\n\t\treturns |TRUE| (only in some GUI versions).\n\t\tThe input fields are:\n\t\t    {save}\twhen |TRUE|, select file to write\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\t    {default}\tdefault file name\n\t\tWhen the \"Cancel\" button is hit, something went wrong, or\n\t\tbrowsing is not possible, an empty string is returned.",
   "argsStr": "{save}, {title}, {initdir}, {default}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "browsedir",
   "description": "Put up a directory requester.  This only works when\n\t\t\"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n\t\tOn systems where a directory browser is not supported a file\n\t\tbrowser is used.  In that case: select a file in the directory\n\t\tto be used.\n\t\tThe input fields are:\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\tWhen the \"Cancel\" button is hit, something went wrong, or\n\t\tbrowsing is not possible, an empty string is returned.",
   "argsStr": "{title}, {initdir}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufadd",
   "description": "Add a buffer to the buffer list with {name}.\n\t\tIf a buffer for file {name} already exists, return that buffer\n\t\tnumber.  Otherwise return the buffer number of the newly\n\t\tcreated buffer.  When {name} is an empty string then a new\n\t\tbuffer is always created.\n\t\tThe buffer will not have' 'buflisted' set.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufexists",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists.\n\t\tIf the {expr} argument is a number, buffer numbers are used.\n\t\tNumber zero is the alternate buffer for the current window.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "buflisted",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists and is listed (has the 'buflisted' option set).\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufload",
   "description": "Ensure the buffer {expr} is loaded.  When the buffer name\n\t\trefers to an existing file then the file is read.  Otherwise\n\t\tthe buffer will be empty.  If the buffer was already loaded\n\t\tthen there is no change.\n\t\tIf there is an existing swap file for the file of the buffer,\n\t\tthere will be no dialog, the buffer will be loaded anyway.\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufloaded",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists and is loaded (shown in a window or hidden).\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufname",
   "description": "The result is the name of a buffer, as it is displayed by the\n\t\t\":ls\" command.\n+\t\tIf {expr} is omitted the current buffer is used.\n\t\tIf {expr} is a Number, that buffer number's name is given.\n\t\tNumber zero is the alternate buffer for the current window.\n\t\tIf {expr} is a String, it is used as a |file-pattern| to match\n\t\twith the buffer names.  This is always done like 'magic' is\n\t\tset and 'cpoptions' is empty.  When there is more than one\n\t\tmatch an empty string is returned.\n\t\t\"\" or \"%\" can be used for the current buffer, \"#\" for the\n\t\talternate buffer.\n\t\tA full match is preferred, otherwise a match at the start, end\n\t\tor middle of the buffer name is accepted.  If you only want a\n\t\tfull match then put \"^\" at the start and \"$\" at the end of the\n\t\tpattern.\n\t\tListed buffers are found first.  If there is a single match\n\t\twith a listed buffer, that one is returned.  Next unlisted\n\t\tbuffers are searched for.\n\t\tIf the {expr} is a String, but you want to use it as a buffer\n\t\tnumber, force it to be a Number by adding zero to it: >\n\t\t\t:echo bufname(\"3\" + 0)\n<\t\tIf the buffer doesn't exist, or doesn't have a name, an empty\n\t\tstring is returned. >\n\tbufname(\"#\")\t\talternate buffer name\n\tbufname(3)\t\tname of buffer 3\n\tbufname(\"%\")\t\tname of current buffer\n\tbufname(\"file2\")\tname of buffer where \"file2\" matches.",
   "argsStr": "[{expr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufnr",
   "description": "The result is the number of a buffer, as it is displayed by\n\t\tthe \":ls\" command.  For the use of {expr}, see |bufname()|\n\t\tabove.\n\t\tIf the buffer doesn't exist, -1 is returned.  Or, if the\n\t\t{create} argument is present and not zero, a new, unlisted,\n\t\tbuffer is created and its number is returned.\n\t\tbufnr(\"$\") is the last buffer: >\n\t\t\t:let last_buffer = bufnr(\"$\")\n<\t\tThe result is a Number, which is the highest buffer number\n\t\tof existing buffers.  Note that not all buffers with a smaller\n\t\tnumber necessarily exist, because \":bwipeout\" may have removed\n\t\tthem.  Use bufexists() to test for the existence of a buffer.",
   "argsStr": "[{expr} [, {create}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufwinid",
   "description": "The result is a Number, which is the |window-ID| of the first\n\t\twindow associated with buffer {expr}.  For the use of {expr},\n\t\tsee |bufname()| above.  If buffer {expr} doesn't exist or\n\t\tthere is no such window, -1 is returned.  Example: >",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "bufwinnr",
   "description": "The result is a Number, which is the number of the first\n\t\twindow associated with buffer {expr}.  For the use of {expr},\n\t\tsee |bufname()| above.  If buffer {expr} doesn't exist or\n\t\tthere is no such window, -1 is returned.  Example: >",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byte2line",
   "description": "Return the line number that contains the character at byte\n\t\tcount {byte} in the current buffer.  This includes the\n\t\tend-of-line character, depending on the 'fileformat' option\n\t\tfor the current buffer.  The first character has byte count\n\t\tone.\n\t\tAlso see |line2byte()|, |go| and |:goto|.",
   "argsStr": "{byte}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byteidx",
   "description": "Return byte index of the {nr}'th character in the string\n\t\t{expr}.  Use zero for the first character, it then returns\n\t\tzero.\n\t\tThis function is only useful when there are multibyte\n\t\tcharacters, otherwise the returned value is equal to {nr}.\n\t\tComposing characters are not counted separately, their byte\n\t\tlength is added to the preceding base character.  See\n\t\t|byteidxcomp()| below for counting composing characters\n\t\tseparately.\n\t\tExample : >\n\t\t\techo matchstr(str, \".\", byteidx(str, 3))\n<\t\twill display the fourth character.  Another way to do the\n\t\tsame: >\n\t\t\tlet s = strpart(str, byteidx(str, 3))\n\t\t\techo strpart(s, 0, byteidx(s, 1))\n<\t\tAlso see |strgetchar()| and |strcharpart()|.",
   "argsStr": "{expr}, {nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "byteidxcomp",
   "description": "Like byteidx(), except that a composing character is counted\n\t\tas a separate character.  Example: >\n\t\t\tlet s = 'e' . nr2char(0x301)\n\t\t\techo byteidx(s, 1)\n\t\t\techo byteidxcomp(s, 1)\n\t\t\techo byteidxcomp(s, 2)\n<\t\tThe first and third echo result in 3 ('e' plus composing\n\t\tcharacter is 3 bytes), the second echo results in 1 ('e' is\n\t\tone byte).",
   "argsStr": "{expr}, {nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "call",
   "description": "Call function {func} with the items in |List| {arglist} as\n\t\targuments.\n\t\t{func} can either be a |Funcref| or the name of a function.\n\t\ta:firstline and a:lastline are set to the cursor line.\n\t\tReturns the return value of the called function.\n\t\t{dict} is for functions with the \"dict\" attribute.  It will be\n\t\tused to set the local variable \"self\". |Dictionary-function|",
   "argsStr": "{func}, {arglist} [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ceil",
   "description": "Return the smallest integral value greater than or equal to\n\t\t{expr} as a |Float| (round up).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo ceil(1.456)\n<\t\t\t2.0  >\n\t\t\techo ceil(-5.456)\n<\t\t\t-5.0  >\n\t\t\techo ceil(4.0)\n<\t\t\t4.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "changenr",
   "description": "Return the number of the most recent change.  This is the same\n\t\tnumber as what is displayed with |:undolist| and can be used\n\t\twith the |:undo| command.\n\t\tWhen a change was made it is the number of that change.  After\n\t\tredo it is the number of the redone change.  After undo it is\n\t\tone less than the number of the undone change.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "chanclose",
   "description": "Close a channel or a specific stream associated with it.\n\t\tFor a job, {stream} can be one of \"stdin\", \"stdout\",\n\t\t\"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n\t\twith `\"rpc\":v:true`) If {stream} is omitted, all streams\n\t\tare closed. If the channel is a pty, this will then close the\n\t\tpty master, sending SIGHUP to the job process.\n\t\tFor a socket, there is only one stream, and {stream} should be\n\t\tommited.",
   "argsStr": "{id}[, {stream}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "chansend",
   "description": "Send data to channel {id}. For a job, it writes it to the\n\t\tstdin of the process. For the stdio channel |channel-stdio|,\n\t\tit writes to Nvim's stdout.  Returns the number of bytes\n\t\twritten if the write succeeded, 0 otherwise.\n\t\tSee |channel-bytes| for more information.",
   "argsStr": "{id}, {data}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "char2nr",
   "description": "Return number value of the first char in {expr}.  Examples: >\n\t\t\tchar2nr(\" \")\t\treturns 32\n\t\t\tchar2nr(\"ABC\")\t\treturns 65\n\t\t\tchar2nr(\"á\")\t\treturns 225\n\t\t\tchar2nr(\"á\"[0])\t\treturns 195\n\t\t\tchar2nr(\"\\<M-x>\")\treturns 128\n<\t\tNon-ASCII characters are always treated as UTF-8 characters.\n\t\t{utf8} is ignored, it exists only for backwards-compatibility.\n\t\tA combining character is a separate character.\n\t\t|nr2char()| does the opposite.",
   "argsStr": "{expr} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "charidx",
   "description": "Return the character index of the byte at {idx} in {string}.\n\t\tThe index of the first character is zero.\n\t\tIf there are no multibyte characters the returned value is\n\t\tequal to {idx}.\n\t\tWhen {countcc} is omitted or zero, then composing characters\n\t\tare not counted separately, their byte length is added to the\n\t\tpreceding base character.\n\t\tWhen {countcc} is set to 1, then composing characters are\n\t\tcounted as separate characters.\n\t\tReturns -1 if the arguments are invalid or if {idx} is greater\n\t\tthan the index of the last byte in {string}.  An error is\n\t\tgiven if the first argument is not a string, the second\n\t\targument is not a number or when the third argument is present\n\t\tand is not zero or one.\n\t\tSee |byteidx()| and |byteidxcomp()| for getting the byte index\n\t\tfrom the character index.\n\t\tExamples: >\n\t\t\techo charidx('áb́ć', 3)\t\treturns 1\n\t\t\techo charidx('áb́ć', 6, 1)\treturns 4\n\t\t\techo charidx('áb́ć', 16)\t\treturns -1",
   "argsStr": "{string}, {idx} [, {countcc}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cindent",
   "description": "Get the amount of indent for line {lnum} according the C\n\t\tindenting rules, as with 'cindent'.\n\t\tThe indent is counted in spaces, the value of 'tabstop' is\n\t\trelevant.  {lnum} is used just like in |getline()|.\n\t\tWhen {lnum} is invalid -1 is returned.\n\t\tSee |C-indenting|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "clearmatches",
   "description": "Clears all matches previously defined for the current window\n \t\tby |matchadd()| and the |:match| commands.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsStr": "[{win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "col",
   "description": "The result is a Number, which is the byte index of the column\n\t\tposition given with {expr}.  The accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the end of the cursor line (the result is the\n\t\t\t    number of bytes in the cursor line plus one)\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    v       In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tAdditionally {expr} can be [lnum, col]: a |List| with the line\n\t\tand column number. Most useful when the column is \"$\", to get\n\t\tthe last column of a specific line.  When \"lnum\" or \"col\" is\n\t\tout of range then col() returns zero.\n\t\tTo get the line number use |line()|.  To get both use\n\t\t|getpos()|.\n\t\tFor the screen column position use |virtcol()|.\n\t\tNote that only marks in the current file can be used.\n\t\tExamples: >\n\t\t\tcol(\".\")\t\tcolumn of cursor\n\t\t\tcol(\"$\")\t\tlength of cursor line plus one\n\t\t\tcol(\"'t\")\t\tcolumn of mark t\n\t\t\tcol(\"'\" . markname)\tcolumn of mark markname\n<\t\tThe first column is 1.  0 is returned for an error.\n\t\tFor an uppercase mark the column may actually be in another\n\t\tbuffer.\n\t\tFor the cursor position, when 'virtualedit' is active, the\n\t\tcolumn is one higher if the cursor is after the end of the\n\t\tline.  This can be used to obtain the column in Insert mode: >\n\t\t\t:imap <F2> <C-O>:let save_ve = &ve<CR>\n\t\t\t\t\\<C-O>:set ve=all<CR>\n\t\t\t\t\\<C-O>:echo col(\".\") . \"\\n\" <Bar>\n\t\t\t\t\\let &ve = save_ve<CR>\n<",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete",
   "description": "Set the matches for Insert mode completion.\n\t\tCan only be used in Insert mode.  You need to use a mapping\n\t\twith CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n\t\tor with an expression mapping.\n\t\t{startcol} is the byte offset in the line where the completed\n\t\ttext start.  The text up to the cursor is the original text\n\t\tthat will be replaced by the matches.  Use col('.') for an\n\t\tempty string.  \"col('.') - 1\" will replace one character by a\n\t\tmatch.\n\t\t{matches} must be a |List|.  Each |List| item is one match.\n\t\tSee |complete-items| for the kind of items that are possible.\n\t\tNote that the after calling this function you need to avoid\n\t\tinserting anything that would cause completion to stop.\n\t\tThe match can be selected with CTRL-N and CTRL-P as usual with\n\t\tInsert mode completion.  The popup menu will appear if\n\t\tspecified, see |ins-completion-menu|.\n\t\tExample: >\n\tinoremap <F5> <C-R>=ListMonths()<CR>",
   "argsStr": "{startcol}, {matches}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_add",
   "description": "Add {expr} to the list of matches.  Only to be used by the\n\t\tfunction specified with the 'completefunc' option.\n\t\tReturns 0 for failure (empty string or out of memory),\n\t\t1 when the match was added, 2 when the match was already in\n\t\tthe list.\n\t\tSee |complete-functions| for an explanation of {expr}.  It is\n\t\tthe same as one item in the list that 'omnifunc' would return.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_check",
   "description": "Check for a key typed while looking for completion matches.\n\t\tThis is to be used when looking for matches takes some time.\n\t\tReturns |TRUE| when searching for matches is to be aborted,\n\t\tzero otherwise.\n\t\tOnly to be used by the function specified with the\n\t\t'completefunc' option.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "complete_info",
   "description": "Returns a Dictionary with information about Insert mode\n\t\tcompletion.  See |ins-completion|.\n\t\tThe items are:\n\t\t   mode\t\tCurrent completion mode name string.\n\t\t\t\tSee |complete_info_mode| for the values.\n\t\t   pum_visible\t|TRUE| if popup menu is visible.\n\t\t\t\tSee |pumvisible()|.\n\t\t   items\tList of completion matches.  Each item is a\n\t\t\t\tdictionary containing the entries \"word\",\n\t\t\t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n\t\t\t\tSee |complete-items|.\n\t\t   selected\tSelected item index.  First index is zero.\n\t\t\t\tIndex is -1 if no item is selected (showing\n\t\t\t\ttyped text only)\n\t\t   inserted\tInserted string. [NOT IMPLEMENT YET]",
   "argsStr": "[{what}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "complete_info_mode",
   "description": "mode values are:\n\t\t   \"\"\t\t     Not in completion mode\n\t\t   \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n\t\t   \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n\t\t   \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n\t\t   \"files\"\t     File names |i_CTRL-X_CTRL-F|\n\t\t   \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n\t\t   \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n\t\t   \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n\t\t   \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n\t\t   \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n\t\t   \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n\t\t   \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n\t\t   \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n\t\t   \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n\t\t   \"eval\"            |complete()| completion\n\t\t   \"unknown\"\t     Other internal modes",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "confirm",
   "description": "Confirm() offers the user a dialog, from which a choice can be\n\t\tmade.  It returns the number of the choice.  For the first\n\t\tchoice this is 1.",
   "argsStr": "{msg} [, {choices} [, {default} [, {type}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "copy",
   "description": "Make a copy of {expr}.  For Numbers and Strings this isn't\n\t\tdifferent from using {expr} directly.\n\t\tWhen {expr} is a |List| a shallow copy is created.  This means\n\t\tthat the original |List| can be changed without changing the\n\t\tcopy, and vice versa.  But the items are identical, thus\n\t\tchanging an item changes the contents of both |Lists|.\n\t\tA |Dictionary| is copied in a similar way as a |List|.\n\t\tAlso see |deepcopy()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cos",
   "description": "Return the cosine of {expr}, measured in radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cos(100)\n<\t\t\t0.862319 >\n\t\t\t:echo cos(-4.01)\n<\t\t\t-0.646043",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cosh",
   "description": "Return the hyperbolic cosine of {expr} as a |Float| in the range\n\t\t[1, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cosh(0.5)\n<\t\t\t1.127626 >\n\t\t\t:echo cosh(-0.5)\n<\t\t\t-1.127626",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "count",
   "description": "Return the number of times an item with value {expr} appears\n\t\tin |String|, |List| or |Dictionary| {comp}.",
   "argsStr": "{comp}, {expr} [, {ic} [, {start}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cscope_connection",
   "description": "Checks for the existence of a |cscope| connection.  If no\n\t\tparameters are specified, then the function returns:\n\t\t\t0, if cscope was not available (not compiled in), or\n\t\t\t   if there are no cscope connections;\n\t\t\t1, if there is at least one cscope connection.",
   "argsStr": "[{num} , {dbpath} [, {prepend}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxget",
   "description": "Returns a |Dictionary| representing the |context| at {index}\n\t\tfrom the top of the |context-stack| (see |context-dict|).\n\t\tIf {index} is not given, it is assumed to be 0 (i.e.: top).",
   "argsStr": "[{index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxpop",
   "description": "Pops and restores the |context| at the top of the\n\t\t|context-stack|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxpush",
   "description": "Pushes the current editor state (|context|) on the\n\t\t|context-stack|.\n\t\tIf {types} is given and is a |List| of |String|s, it specifies\n\t\twhich |context-types| to include in the pushed context.\n\t\tOtherwise, all context types are included.",
   "argsStr": "[{types}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxset",
   "description": "Sets the |context| at {index} from the top of the\n\t\t|context-stack| to that represented by {context}.\n\t\t{context} is a Dictionary with context data (|context-dict|).\n\t\tIf {index} is not given, it is assumed to be 0 (i.e.: top).",
   "argsStr": "{context}[, {index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "ctxsize",
   "description": "Returns the size of the |context-stack|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "cursor",
   "description": "cursor({list})\n\t\tPositions the cursor at the column (byte count) {col} in the\n\t\tline {lnum}.  The first column is one.",
   "argsStr": "{lnum}, {col} [, {off}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "deepcopy",
   "description": "Make a copy of {expr}.  For Numbers and Strings this isn't\n\t\tdifferent from using {expr} directly.\n\t\tWhen {expr} is a |List| a full copy is created.  This means\n\t\tthat the original |List| can be changed without changing the\n\t\tcopy, and vice versa.  When an item is a |List|, a copy for it\n\t\tis made, recursively.  Thus changing an item in the copy does\n\t\tnot change the contents of the original |List|.\n\t\tWhen {noref} is omitted or zero a contained |List| or\n\t\t|Dictionary| is only copied once.  All references point to\n\t\tthis single copy.  With {noref} set to 1 every occurrence of a\n\t\t|List| or |Dictionary| results in a new copy.  This also means\n\t\tthat a cyclic reference causes deepcopy() to fail.",
   "argsStr": "{expr}[, {noref}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E724",
   "description": "Nesting is possible up to 100 levels.  When there is an item\n\t\tthat refers back to a higher level making a deep copy with\n\t\t{noref} set to 1 will fail.\n\t\tAlso see |copy()|.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "delete",
   "description": "Without {flags} or with {flags} empty: Deletes the file by the\n\t\tname {fname}.  This also works when {fname} is a symbolic link.\n\t\tA symbolic link itself is deleted, not what it points to.",
   "argsStr": "{fname} [, {flags}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "deletebufline",
   "description": "Delete lines {first} to {last} (inclusive) from buffer {expr}.\n\t\tIf {last} is omitted then delete line {first} only.\n\t\tOn success 0 is returned, on failure 1 is returned.",
   "argsStr": "{expr}, {first}[, {last}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "dictwatcheradd",
   "description": "Adds a watcher to a dictionary. A dictionary watcher is\n\t\tidentified by three components:",
   "argsStr": "{dict}, {pattern}, {callback}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "dictwatcherdel",
   "description": "Removes a watcher added  with |dictwatcheradd()|. All three\n\t\targuments must match the ones passed to |dictwatcheradd()| in\n\t\torder for the watcher to be successfully deleted.",
   "argsStr": "{dict}, {pattern}, {callback}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "did_filetype",
   "description": "Returns |TRUE| when autocommands are being executed and the\n\t\tFileType event has been triggered at least once.  Can be used\n\t\tto avoid triggering the FileType event again in the scripts\n\t\tthat detect the file type. |FileType|\n\t\tReturns |FALSE| when `:setf FALLBACK` was used.\n\t\tWhen editing another file, the counter is reset, thus this\n\t\treally checks if the FileType event has been triggered for the\n\t\tcurrent buffer.  This allows an autocommand that starts\n\t\tediting another buffer to set 'filetype' and load a syntax\n\t\tfile.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "diff_filler",
   "description": "Returns the number of filler lines above line {lnum}.\n\t\tThese are the lines that were inserted at this point in\n\t\tanother diff'ed window.  These filler lines are shown in the\n\t\tdisplay but don't exist in the buffer.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\tReturns 0 if the current window is not in diff mode.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "diff_hlID",
   "description": "Returns the highlight ID for diff mode at line {lnum} column\n\t\t{col} (byte index).  When the current line does not have a\n\t\tdiff change zero is returned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\t{col} is 1 for the leftmost column, {lnum} is 1 for the first\n\t\tline.\n\t\tThe highlight ID can be used with |synIDattr()| to obtain\n\t\tsyntax information about the highlighting.",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "environ",
   "description": "Return all of environment variables as dictionary. You can\n\t\tcheck if an environment variable exists like this: >\n\t\t\t:echo has_key(environ(), 'HOME')\n<\t\tNote that the variable name may be CamelCase; to ignore case\n\t\tuse this: >\n\t\t\t:echo index(keys(environ()), 'HOME', 0, 1) != -1",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "empty",
   "description": "Return the Number 1 if {expr} is empty, zero otherwise.\n\t\tA |List| or |Dictionary| is empty when it does not have any\n\t\titems.  A Number is empty when its value is zero.  Special\n\t\tvariable is empty when it is |v:false| or |v:null|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "escape",
   "description": "Escape the characters in {chars} that occur in {string} with a\n\t\tbackslash.  Example: >\n\t\t\t:echo escape('c:\\program files\\vim', ' \\')\n<\t\tresults in: >\n\t\t\tc:\\\\program\\ files\\\\vim\n<\t\tAlso see |shellescape()| and |fnameescape()|.",
   "argsStr": "{string}, {chars}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "eval",
   "description": "Evaluate {string} and return the result.  Especially useful to\n\t\tturn the result of |string()| back into the original value.\n\t\tThis works for Numbers, Floats, Strings and composites of\n\t\tthem.  Also works for |Funcref|s that refer to existing\n\t\tfunctions.",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "eventhandler",
   "description": "Returns 1 when inside an event handler.  That is that Vim got\n\t\tinterrupted while waiting for the user to type a character,\n\t\te.g., when dropping a file on Vim.  This means interactive\n\t\tcommands cannot be used.  Otherwise zero is returned.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "executable",
   "description": "This function checks if an executable with the name {expr}\n\t\texists.  {expr} must be the name of the program without any\n\t\targuments.\n\t\texecutable() uses the value of $PATH and/or the normal",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "PATHEXT",
   "description": "On Windows the \".exe\", \".bat\", etc. can\n\t\toptionally be included.  Then the extensions in $PATHEXT are\n\t\ttried.  Thus if \"foo.exe\" does not exist, \"foo.exe.bat\" can be\n\t\tfound.  If $PATHEXT is not set then \".exe;.com;.bat;.cmd\" is\n\t\tused.  A dot by itself can be used in $PATHEXT to try using\n\t\tthe name without an extension.  When 'shell' looks like a\n\t\tUnix shell, then the name is also tried without adding an\n\t\textension.\n\t\tOn Windows it only checks if the file exists and\n\t\tis not a directory, not if it's really executable.\n\t\tOn Windows an executable in the same directory as Vim is\n\t\talways found (it is added to $PATH at |startup|).\n\t\tThe result is a Number:\n\t\t\t1\texists\n\t\t\t0\tdoes not exist\n\t\t\t-1\tnot implemented on this system\n\t\t|exepath()| can be used to get the full path of an executable.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "execute",
   "description": "Execute {command} and capture its output.\n\t\tIf {command} is a |String|, returns {command} output.\n\t\tIf {command} is a |List|, returns concatenated outputs.\n\t\tExamples: >\n\t\t\techo execute('echon \"foo\"')\n<\t\t\tfoo >\n\t\t\techo execute(['echon \"foo\"', 'echon \"bar\"'])\n<\t\t\tfoobar",
   "argsStr": "{command} [, {silent}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exepath",
   "description": "Returns the full path of {expr} if it is an executable and\n\t\tgiven as a (partial or full) path or is found in $PATH.\n\t\tReturns empty string otherwise.\n\t\tIf {expr} starts with \"./\" the |current-directory| is used.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exists",
   "description": "The result is a Number, which is |TRUE| if {expr} is\n\t\tdefined, zero otherwise.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "exp",
   "description": "Return the exponential of {expr} as a |Float| in the range\n\t\t[0, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo exp(2)\n<\t\t\t7.389056 >\n\t\t\t:echo exp(-1)\n<\t\t\t0.367879",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "debugbreak",
   "description": "Specifically used to interrupt a program being debugged.  It\n\t\twill cause process {pid} to get a SIGTRAP.  Behavior for other\n\t\tprocesses is undefined. See |terminal-debugger|.\n\t\t{Sends a SIGINT to a process {pid} other than MS-Windows}",
   "argsStr": "{pid}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "expand",
   "description": "Expand wildcards and the following special keywords in {expr}.\n\t\t'wildignorecase' applies.",
   "argsStr": "{expr} [, {nosuf} [, {list}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "expandcmd",
   "description": "Expand special items in {expr} like what is done for an Ex\n\t\tcommand such as `:edit`.  This expands special keywords, like\n\t\twith |expand()|, and environment variables, anywhere in\n\t\t{expr}.  Returns the expanded string.\n\t\tExample: >\n\t\t\t:echo expandcmd('make %<.o')\n<",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "extend",
   "description": "{expr1} and {expr2} must be both |Lists| or both\n\t\t|Dictionaries|.",
   "argsStr": "{expr1}, {expr2} [, {expr3}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E737",
   "description": "When {expr3} is omitted then \"force\" is assumed.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "feedkeys",
   "description": "Characters in {string} are queued for processing as if they\n\t\tcome from a mapping or were typed by the user.",
   "argsStr": "{string} [, {mode}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filereadable",
   "description": "The result is a Number, which is |TRUE| when a file with the\n\t\tname {file} exists, and can be read.  If {file} doesn't exist,\n\t\tor is a directory, the result is |FALSE|.  {file} is any\n\t\texpression, which is used as a String.\n\t\tIf you don't care about the file being readable you can use\n\t\t|glob()|.",
   "argsStr": "{file}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filewritable",
   "description": "The result is a Number, which is 1 when a file with the\n\t\tname {file} exists, and can be written.  If {file} doesn't\n\t\texist, or is not writable, the result is 0.  If {file} is a\n\t\tdirectory, and we can write to it, the result is 2.",
   "argsStr": "{file}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "filter",
   "description": "{expr1} must be a |List| or a |Dictionary|.\n\t\tFor each item in {expr1} evaluate {expr2} and when the result\n\t\tis zero remove the item from the |List| or |Dictionary|.\n\t\t{expr2} must be a |string| or |Funcref|.",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "finddir",
   "description": "Find directory {name} in {path}.  Supports both downwards and\n\t\tupwards recursive directory searches.  See |file-searching|\n\t\tfor the syntax of {path}.\n\t\tReturns the path of the first found match.  When the found\n\t\tdirectory is below the current directory a relative path is\n\t\treturned.  Otherwise a full path is returned.\n\t\tIf {path} is omitted or empty then 'path' is used.\n\t\tIf the optional {count} is given, find {count}'s occurrence of\n\t\t{name} in {path} instead of the first one.\n\t\tWhen {count} is negative return all the matches in a |List|.\n\t\tThis is quite similar to the ex-command |:find|.",
   "argsStr": "{name} [, {path} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "findfile",
   "description": "Just like |finddir()|, but find a file instead of a directory.\n\t\tUses 'suffixesadd'.\n\t\tExample: >\n\t\t\t:echo findfile(\"tags.vim\", \".;\")\n<\t\tSearches from the directory of the current file upwards until\n\t\tit finds the file \"tags.vim\".",
   "argsStr": "{name} [, {path} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "flatten",
   "description": "Flatten {list} up to {maxdepth} levels.  Without {maxdepth}\n\t\tthe result is a |List| without nesting, as if {maxdepth} is\n\t\ta very large number.\n\t\tThe {list} is changed in place, make a copy first if you do\n\t\tnot want that.",
   "argsStr": "{list} [, {maxdepth}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E964",
   "description": "{maxdepth} means how deep in nested lists changes are made.\n\t\t{list} is not modified when {maxdepth} is 0.\n\t\t{maxdepth} must be positive number.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "float2nr",
   "description": "Convert {expr} to a Number by omitting the part after the\n\t\tdecimal point.\n\t\t{expr} must evaluate to a |Float| or a Number.\n\t\tWhen the value of {expr} is out of range for a |Number| the\n\t\tresult is truncated to 0x7fffffff or -0x7fffffff (or when\n\t\t64-bit Number support is enabled, 0x7fffffffffffffff or\n\t\t-0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n\t\t64-bit Number support is enabled, -0x8000000000000000).\n\t\tExamples: >\n\t\t\techo float2nr(3.95)\n<\t\t\t3  >\n\t\t\techo float2nr(-23.45)\n<\t\t\t-23  >\n\t\t\techo float2nr(1.0e100)\n<\t\t\t2147483647  (or 9223372036854775807) >\n\t\t\techo float2nr(-1.0e150)\n<\t\t\t-2147483647 (or -9223372036854775807) >\n\t\t\techo float2nr(1.0e-100)\n<\t\t\t0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "floor",
   "description": "Return the largest integral value less than or equal to\n\t\t{expr} as a |Float| (round down).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo floor(1.856)\n<\t\t\t1.0  >\n\t\t\techo floor(-5.456)\n<\t\t\t-6.0  >\n\t\t\techo floor(4.0)\n<\t\t\t4.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fmod",
   "description": "Return the remainder of {expr1} / {expr2}, even if the\n\t\tdivision is not representable.  Returns {expr1} - i * {expr2}\n\t\tfor some integer i such that if {expr2} is non-zero, the\n\t\tresult has the same sign as {expr1} and magnitude less than\n\t\tthe magnitude of {expr2}.  If {expr2} is zero, the value\n\t\treturned is zero.  The value returned is a |Float|.\n\t\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo fmod(12.33, 1.22)\n<\t\t\t0.13 >\n\t\t\t:echo fmod(-12.33, 1.22)\n<\t\t\t-0.13",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fnameescape",
   "description": "Escape {string} for use as file name command argument.  All\n\t\tcharacters that have a special meaning, such as '%' and '|'\n\t\tare escaped with a backslash.\n\t\tFor most systems the characters escaped are\n\t\t\" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\n\t\tappears in a filename, it depends on the value of 'isfname'.\n\t\tA leading '+' and '>' is also escaped (special after |:edit|\n\t\tand |:write|).  And a \"-\" by itself (special after |:cd|).\n\t\tExample: >\n\t\t\t:let fname = '+some str%nge|name'\n\t\t\t:exe \"edit \" . fnameescape(fname)\n<\t\tresults in executing: >\n\t\t\tedit \\+some\\ str\\%nge\\|name",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "fnamemodify",
   "description": "Modify file name {fname} according to {mods}.  {mods} is a\n\t\tstring of characters like it is used for file names on the\n\t\tcommand line.  See |filename-modifiers|.\n\t\tExample: >\n\t\t\t:echo fnamemodify(\"main.c\", \":p:h\")\n<\t\tresults in: >\n\t\t\t/home/mool/vim/vim/src\n<\t\tNote: Environment variables don't work in {fname}, use\n\t\t|expand()| first then.",
   "argsStr": "{fname}, {mods}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldclosed",
   "description": "The result is a Number.  If the line {lnum} is in a closed\n\t\tfold, the result is the number of the first line in that fold.\n\t\tIf the line {lnum} is not in a closed fold, -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldclosedend",
   "description": "The result is a Number.  If the line {lnum} is in a closed\n\t\tfold, the result is the number of the last line in that fold.\n\t\tIf the line {lnum} is not in a closed fold, -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldlevel",
   "description": "The result is a Number, which is the foldlevel of line {lnum}\n\t\tin the current buffer.  For nested folds the deepest level is\n\t\treturned.  If there is no fold at line {lnum}, zero is\n\t\treturned.  It doesn't matter if the folds are open or closed.\n\t\tWhen used while updating folds (from 'foldexpr') -1 is\n\t\treturned for lines where folds are still to be updated and the\n\t\tfoldlevel is unknown.  As a special case the level of the\n\t\tprevious line is usually available.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldtext",
   "description": "Returns a String, to be displayed for a closed fold.  This is\n\t\tthe default function used for the 'foldtext' option and should\n\t\tonly be called from evaluating 'foldtext'.  It uses the\n\t\t|v:foldstart|, |v:foldend| and |v:folddashes| variables.\n\t\tThe returned string looks like this: >\n\t\t\t+-- 45 lines: abcdef\n<\t\tThe number of leading dashes depends on the foldlevel.  The\n\t\t\"45\" is the number of lines in the fold.  \"abcdef\" is the text\n\t\tin the first non-blank line of the fold.  Leading white space,\n\t\t\"//\" or \"/*\" and the text from the 'foldmarker' and\n\t\t'commentstring' options is removed.\n\t\tWhen used to draw the actual foldtext, the rest of the line\n\t\twill be filled with the fold char from the 'fillchars'\n\t\tsetting.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foldtextresult",
   "description": "Returns the text that is displayed for the closed fold at line\n\t\t{lnum}.  Evaluates 'foldtext' in the appropriate context.\n\t\tWhen there is no closed fold at {lnum} an empty string is\n\t\treturned.\n\t\t{lnum} is used like with |getline()|.  Thus \".\" is the current\n\t\tline, \"'m\" mark m, etc.\n\t\tUseful when exporting folded text, e.g., to HTML.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "foreground",
   "description": "Move the Vim window to the foreground.  Useful when sent from\n\t\ta client to a Vim server. |remote_send()|\n\t\tOn Win32 systems this might not work, the OS does not always\n\t\tallow a window to bring itself to the foreground.  Use\n\t\t|remote_foreground()| instead.\n\t\t{only in the Win32 GUI and console version}",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "funcref",
   "description": "Just like |function()|, but the returned Funcref will lookup\n\t\tthe function by reference, not by name.  This matters when the\n\t\tfunction {name} is redefined later.",
   "argsStr": "{name} [, {arglist}] [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "function",
   "description": "Return a |Funcref| variable that refers to function {name}.\n\t\t{name} can be a user defined function or an internal function.",
   "argsStr": "{name} [, {arglist}] [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "garbagecollect",
   "description": "Cleanup unused |Lists| and |Dictionaries| that have circular\n\t\treferences.",
   "argsStr": "[{atexit}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "get",
   "description": "Get item {idx} from |List| {list}.  When this item is not\n\t\tavailable return {default}.  Return zero when {default} is\n\t\tomitted.\nget({dict}, {key} [, {default}])\n\t\tGet item with key {key} from |Dictionary| {dict}.  When this\n\t\titem is not available return {default}.  Return zero when\n\t\t{default} is omitted.  Useful example: >\n\t\t\tlet val = get(g:, 'var_name', 'default')\n<\t\tThis gets the value of g:var_name if it exists, and uses\n\t\t'default' when it does not exist.\nget({func}, {what})\n\t\tGet item {what} from Funcref {func}.  Possible values for\n\t\t{what} are:\n\t\t\t\"name\"\tThe function name\n\t\t\t\"func\"\tThe function\n\t\t\t\"dict\"\tThe dictionary\n\t\t\t\"args\"\tThe list with arguments",
   "argsStr": "{list}, {idx} [, {default}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufinfo",
   "description": "getbufinfo([{dict}])\n\t\tGet information about buffers as a List of Dictionaries.",
   "argsStr": "[{expr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufline",
   "description": "Return a |List| with the lines starting from {lnum} to {end}\n\t\t(inclusive) in the buffer {expr}.  If {end} is omitted, a\n\t\t|List| with only the line {lnum} is returned.",
   "argsStr": "{expr}, {lnum} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getbufvar",
   "description": "The result is the value of option or local buffer variable\n\t\t{varname} in buffer {expr}.  Note that the name without \"b:\"\n\t\tmust be used.\n\t\tWhen {varname} is empty returns a dictionary with all the\n\t\tbuffer-local variables.\n\t\tWhen {varname} is equal to \"&\" returns a dictionary with all\n\t\tthe buffer-local options.\n\t\tOtherwise, when {varname} starts with \"&\" returns the value of\n\t\ta buffer-local option.\n\t\tThis also works for a global or buffer-local option, but it\n\t\tdoesn't work for a global variable, window-local variable or\n\t\twindow-local option.\n\t\tFor the use of {expr}, see |bufname()| above.\n\t\tWhen the buffer or variable doesn't exist {def} or an empty\n\t\tstring is returned, there is no error message.\n\t\tExamples: >\n\t\t\t:let bufmodified = getbufvar(1, \"&mod\")\n\t\t\t:echo \"todo myvar = \" . getbufvar(\"todo\", \"myvar\")\n<",
   "argsStr": "{expr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getchangelist",
   "description": "Returns the |changelist| for the buffer {expr}. For the use\n\t\tof {expr}, see |bufname()| above. If buffer {expr} doesn't\n\t\texist, an empty list is returned.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getchar",
   "description": "Get a single character from the user or input stream.\n\t\tIf [expr] is omitted, wait until a character is available.\n\t\tIf [expr] is 0, only get a character when one is available.\n\t\t\tReturn zero otherwise.\n\t\tIf [expr] is 1, only check if a character is available, it is\n\t\t\tnot consumed.  Return zero if no character available.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcharmod",
   "description": "The result is a Number which is the state of the modifiers for\n\t\tthe last obtained character with getchar() or in another way.\n\t\tThese values are added together:\n\t\t\t2\tshift\n\t\t\t4\tcontrol\n\t\t\t8\talt (meta)\n\t\t\t16\tmeta (when it's different from ALT)\n\t\t\t32\tmouse double click\n\t\t\t64\tmouse triple click\n\t\t\t96\tmouse quadruple click (== 32 + 64)\n\t\t\t128\tcommand (Macintosh only)\n\t\tOnly the modifiers that have not been included in the\n\t\tcharacter itself are obtained.  Thus Shift-a results in \"A\"\n\t\twithout a modifier.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcharsearch",
   "description": "Return the current character search information as a {dict}\n\t\twith the following entries:",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdline",
   "description": "Return the current command-line.  Only works when the command\n\t\tline is being edited, thus requires use of |c_CTRL-\\_e| or\n\t\t|c_CTRL-R_=|.\n\t\tExample: >\n\t\t\t:cmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n<\t\tAlso see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.\n\t\tReturns an empty string when entering a password or using\n\t\t|inputsecret()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdpos",
   "description": "Return the position of the cursor in the command line as a\n\t\tbyte count.  The first column is 1.\n\t\tOnly works when editing the command line, thus requires use of\n\t\t|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n\t\tReturns 0 otherwise.\n\t\tAlso see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdtype",
   "description": "Return the current command-line type. Possible return values\n\t\tare:\n\t\t    :\tnormal Ex command\n\t\t    >\tdebug mode command |debug-mode|\n\t\t    /\tforward search command\n\t\t    ?\tbackward search command\n\t\t    @\t|input()| command\n\t\t    -\t|:insert| or |:append| command\n\t\t    =\t|i_CTRL-R_=|\n\t\tOnly works when editing the command line, thus requires use of\n\t\t|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n\t\tReturns an empty string otherwise.\n\t\tAlso see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcmdwintype",
   "description": "Return the current |command-line-window| type. Possible return\n\t\tvalues are the same as |getcmdtype()|. Returns an empty string\n\t\twhen not in the command-line window.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcompletion",
   "description": "Return a list of command-line completion matches. {type}\n\t\tspecifies what for.  The following completion types are\n\t\tsupported:",
   "argsStr": "{pat}, {type} [, {filtered}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcurpos",
   "description": "Get the position of the cursor.  This is like getpos('.'), but\n\t\tincludes an extra item in the list:\n\t\t    [bufnum, lnum, col, off, curswant] ~\n \t\tThe \"curswant\" number is the preferred column when moving the\n\t\tcursor vertically.  Also see |getpos()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getcwd",
   "description": "With no arguments the result is a String, which is the name of\n\t\tthe current effective working directory. With {winnr} or\n\t\t{tabnr} the working directory of that scope is returned.\n\t\tTabs and windows are identified by their respective numbers,\n\t\t0 means current tab or window. Missing argument implies 0.\n\t\tThus the following are equivalent: >\n\t\t\tgetcwd()\n\t\t\tgetcwd(0)\n\t\t\tgetcwd(0, 0)\n<\t\tIf {winnr} is -1 it is ignored, only the tab is resolved.\n\t\t{winnr} can be the window number or the |window-ID|.",
   "argsStr": "[{winnr}[, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getenv",
   "description": "Return the value of environment variable {name}.\n\t\tWhen the variable does not exist |v:null| is returned.  That\n\t\tis different from a variable set to an empty string.\n\t\tSee also |expr-env|.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfontname",
   "description": "Without an argument returns the name of the normal font being\n\t\tused.  Like what is used for the Normal highlight group\n\t\t|hl-Normal|.\n\t\tWith an argument a check is done whether {name} is a valid\n\t\tfont name.  If not then an empty string is returned.\n\t\tOtherwise the actual font name is returned, or {name} if the\n\t\tGUI does not support obtaining the real name.\n\t\tOnly works when the GUI is running, thus not in your vimrc or\n\t\tgvimrc file.  Use the |GUIEnter| autocommand to use this\n\t\tfunction just after the GUI has started.",
   "argsStr": "[{name}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfperm",
   "description": "The result is a String, which is the read, write, and execute\n\t\tpermissions of the given file {fname}.\n\t\tIf {fname} does not exist or its directory cannot be read, an\n\t\tempty string is returned.\n\t\tThe result is of the form \"rwxrwxrwx\", where each group of\n\t\t\"rwx\" flags represent, in turn, the permissions of the owner\n\t\tof the file, the group the file belongs to, and other users.\n\t\tIf a user does not have a given permission the flag for this\n\t\tis replaced with the string \"-\".  Examples: >\n\t\t\t:echo getfperm(\"/etc/passwd\")\n\t\t\t:echo getfperm(expand(\"~/.config/nvim/init.vim\"))\n<\t\tThis will hopefully (from a security point of view) display\n\t\tthe string \"rw-r--r--\" or even \"rw-------\".",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getfsize",
   "description": "The result is a Number, which is the size in bytes of the\n\t\tgiven file {fname}.\n\t\tIf {fname} is a directory, 0 is returned.\n\t\tIf the file {fname} can't be found, -1 is returned.\n\t\tIf the size of {fname} is too big to fit in a Number then -2\n\t\tis returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getftime",
   "description": "The result is a Number, which is the last modification time of\n\t\tthe given file {fname}.  The value is measured as seconds\n\t\tsince 1st Jan 1970, and may be passed to strftime().  See also\n\t\t|localtime()| and |strftime()|.\n\t\tIf the file {fname} can't be found -1 is returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getftype",
   "description": "The result is a String, which is a description of the kind of\n\t\tfile of the given file {fname}.\n\t\tIf {fname} does not exist an empty string is returned.\n\t\tHere is a table over different kinds of files and their\n\t\tresults:\n\t\t\tNormal file\t\t\"file\"\n\t\t\tDirectory\t\t\"dir\"\n\t\t\tSymbolic link\t\t\"link\"\n\t\t\tBlock device\t\t\"bdev\"\n\t\t\tCharacter device\t\"cdev\"\n\t\t\tSocket\t\t\t\"socket\"\n\t\t\tFIFO\t\t\t\"fifo\"\n\t\t\tAll other\t\t\"other\"\n\t\tExample: >\n\t\t\tgetftype(\"/home\")\n<\t\tNote that a type such as \"link\" will only be returned on\n\t\tsystems that support it.  On some systems only \"dir\" and\n\t\t\"file\" are returned.",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getjumplist",
   "description": "Returns the |jumplist| for the specified window.",
   "argsStr": "[{winnr} [, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getline",
   "description": "Without {end} the result is a String, which is line {lnum}\n\t\tfrom the current buffer.  Example: >\n\t\t\tgetline(1)\n<\t\tWhen {lnum} is a String that doesn't start with a\n\t\tdigit, |line()| is called to translate the String into a Number.\n\t\tTo get the line under the cursor: >\n\t\t\tgetline(\".\")\n<\t\tWhen {lnum} is smaller than 1 or bigger than the number of\n\t\tlines in the buffer, an empty string is returned.",
   "argsStr": "{lnum} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getloclist",
   "description": "Returns a list with all the entries in the location list for\n\t\twindow {nr}.  {nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero the current window is used.",
   "argsStr": "{nr},[, {what}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getmarklist",
   "description": "Without the {expr} argument returns a |List| with information\n\t\tabout all the global marks. |mark|",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getmatches",
   "description": "Returns a |List| with all matches previously defined for the\n\t\tcurrent window by |matchadd()| and the |:match| commands.\n\t\t|getmatches()| is useful in combination with |setmatches()|,\n\t\tas |setmatches()| can restore a list of matches saved by\n\t\t|getmatches()|.\n\t\tExample: >\n\t\t\t:echo getmatches()\n<\t\t\t[{'group': 'MyGroup1', 'pattern': 'TODO',\n\t\t\t'priority': 10, 'id': 1}, {'group': 'MyGroup2',\n\t\t\t'pattern': 'FIXME', 'priority': 10, 'id': 2}] >\n\t\t\t:let m = getmatches()\n\t\t\t:call clearmatches()\n\t\t\t:echo getmatches()\n<\t\t\t[] >\n\t\t\t:call setmatches(m)\n\t\t\t:echo getmatches()\n<\t\t\t[{'group': 'MyGroup1', 'pattern': 'TODO',\n\t\t\t'priority': 10, 'id': 1}, {'group': 'MyGroup2',\n\t\t\t'pattern': 'FIXME', 'priority': 10, 'id': 2}] >\n\t\t\t:unlet m\n<",
   "argsStr": "[{win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getpid",
   "description": "Return a Number which is the process ID of the Vim process.\n\t\tThis is a unique number, until Vim exits.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getpos",
   "description": "Get the position for {expr}.  For possible values of {expr}\n\t\tsee |line()|.  For getting the cursor position see\n\t\t|getcurpos()|.\n\t\tThe result is a |List| with four numbers:\n\t\t    [bufnum, lnum, col, off]\n\t\t\"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\n\t\tis the buffer number of the mark.\n\t\t\"lnum\" and \"col\" are the position in the buffer.  The first\n\t\tcolumn is 1.\n\t\tThe \"off\" number is zero, unless 'virtualedit' is used.  Then\n\t\tit is the offset in screen columns from the start of the\n\t\tcharacter.  E.g., a position within a <Tab> or after the last\n\t\tcharacter.\n\t\tNote that for '< and '> Visual mode matters: when it is \"V\"\n\t\t(visual line mode) the column of '< is zero and the column of\n\t\t'> is a large number.\n\t\tThis can be used to save and restore the position of a mark: >\n\t\t\tlet save_a_mark = getpos(\"'a\")\n\t\t\t...\n\t\t\tcall setpos(\"'a\", save_a_mark)\n<\t\tAlso see |getcurpos()| and |setpos()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getqflist",
   "description": "Returns a list with all the current quickfix errors.  Each\n\t\tlist item is a dictionary with these entries:\n\t\t\tbufnr\tnumber of buffer that has the file name, use\n\t\t\t\tbufname() to get the name\n\t\t\tmodule\tmodule name\n\t\t\tlnum\tline number in the buffer (first line is 1)\n\t\t\tcol\tcolumn number (first column is 1)\n\t\t\tvcol\t|TRUE|: \"col\" is visual column\n\t\t\t\t|FALSE|: \"col\" is byte index\n\t\t\tnr\terror number\n\t\t\tpattern\tsearch pattern used to locate the error\n\t\t\ttext\tdescription of the error\n\t\t\ttype\ttype of the error, 'E', '1', etc.\n\t\t\tvalid\t|TRUE|: recognized error message",
   "argsStr": "[{what}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getreg",
   "description": "The result is a String, which is the contents of register\n\t\t{regname}.  Example: >\n\t\t\t:let cliptext = getreg('*')\n<\t\tWhen {regname} was not set the result is an empty string.",
   "argsStr": "[{regname} [, 1 [, {list}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getregtype",
   "description": "The result is a String, which is type of register {regname}.\n\t\tThe value will be one of:\n\t\t    \"v\"\t\t\tfor |charwise| text\n\t\t    \"V\"\t\t\tfor |linewise| text\n\t\t    \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n\t\t    \"\"\t\t\tfor an empty or unknown register\n\t\t<CTRL-V> is one character with value 0x16.\n\t\tIf {regname} is not specified, |v:register| is used.",
   "argsStr": "[{regname}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabinfo",
   "description": "If {arg} is not specified, then information about all the tab\n\t\tpages is returned as a List. Each List item is a Dictionary.\n\t\tOtherwise, {arg} specifies the tab page number and information\n\t\tabout that one is returned.  If the tab page does not exist an\n\t\tempty List is returned.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabvar",
   "description": "Get the value of a tab-local variable {varname} in tab page\n\t\t{tabnr}. |t:var|\n\t\tTabs are numbered starting with one.\n\t\tWhen {varname} is empty a dictionary with all tab-local\n\t\tvariables is returned.\n\t\tNote that the name without \"t:\" must be used.\n\t\tWhen the tab or variable doesn't exist {def} or an empty\n\t\tstring is returned, there is no error message.",
   "argsStr": "{tabnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettabwinvar",
   "description": "Get the value of window-local variable {varname} in window\n\t\t{winnr} in tab page {tabnr}.\n\t\tWhen {varname} is empty a dictionary with all window-local\n\t\tvariables is returned.\n\t\tWhen {varname} is equal to \"&\" get the values of all\n\t\twindow-local options in a Dictionary.\n\t\tOtherwise, when {varname} starts with \"&\" get the value of a\n\t\twindow-local option.\n\t\tNote that {varname} must be the name without \"w:\".\n\t\tTabs are numbered starting with one.  For the current tabpage\n\t\tuse |getwinvar()|.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tWhen {winnr} is zero the current window is used.\n\t\tThis also works for a global option, buffer-local option and\n\t\twindow-local option, but it doesn't work for a global variable\n\t\tor buffer-local variable.\n\t\tWhen the tab, window or variable doesn't exist {def} or an\n\t\tempty string is returned, there is no error message.\n\t\tExamples: >\n\t\t\t:let list_is_on = gettabwinvar(1, 2, '&list')\n\t\t\t:echo \"myvar = \" . gettabwinvar(3, 1, 'myvar')\n<\n\t\tTo obtain all window-local variables use: >\n\t\t\tgettabwinvar({tabnr}, {winnr}, '&')",
   "argsStr": "{tabnr}, {winnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "gettagstack",
   "description": "The result is a Dict, which is the tag stack of window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is not specified, the current window is used.\n\t\tWhen window {nr} doesn't exist, an empty Dict is returned.",
   "argsStr": "[{nr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwininfo",
   "description": "Returns information about windows as a List with Dictionaries.",
   "argsStr": "[{winid}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinpos",
   "description": "The result is a list with two numbers, the result of\n\t\tgetwinposx() and getwinposy() combined:\n\t\t\t[x-pos, y-pos]\n\t\t{timeout} can be used to specify how long to wait in msec for\n\t\ta response from the terminal.  When omitted 100 msec is used.",
   "argsStr": "[{timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinposx",
   "description": "The result is a Number, which is the X coordinate in pixels of\n\t\tthe left hand side of the GUI Vim window.  The result will be\n\t\t-1 if the information is not available.\n\t\tThe value can be used with `:winpos`.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinposy",
   "description": "The result is a Number, which is the Y coordinate in pixels of\n\t\tthe top of the GUI Vim window.  The result will be -1 if the\n\t\tinformation is not available.\n\t\tThe value can be used with `:winpos`.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "getwinvar",
   "description": "Like |gettabwinvar()| for the current tabpage.\n\t\tExamples: >\n\t\t\t:let list_is_on = getwinvar(2, '&list')\n\t\t\t:echo \"myvar = \" . getwinvar(1, 'myvar')\n<",
   "argsStr": "{winnr}, {varname} [, {def}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "glob",
   "description": "Expand the file wildcards in {expr}.  See |wildcards| for the\n\t\tuse of special characters.",
   "argsStr": "{expr} [, {nosuf} [, {list} [, {alllinks}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "glob2regpat",
   "description": "Convert a file pattern, as used by glob(), into a search\n\t\tpattern.  The result can be used to match with a string that\n\t\tis a file name.  E.g. >\n\t\t\tif filename =~ glob2regpat('Make*.mak')\n<\t\tThis is equivalent to: >\n\t\t\tif filename =~ '^Make.*\\.mak$'\n<\t\tWhen {expr} is an empty string the result is \"^$\", match an\n\t\tempty string.\n\t\tNote that the result depends on the system.  On MS-Windows\n\t\ta backslash usually means a path separator.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "globpath",
   "description": "Perform glob() on all directories in {path} and concatenate\n\t\tthe results.  Example: >\n\t\t\t:echo globpath(&rtp, \"syntax/c.vim\")\n<\n\t\t{path} is a comma-separated list of directory names.  Each\n\t\tdirectory name is prepended to {expr} and expanded like with\n\t\t|glob()|.  A path separator is inserted when needed.\n\t\tTo add a comma inside a directory name escape it with a\n\t\tbackslash.  Note that on MS-Windows a directory may have a\n\t\ttrailing backslash, remove it if you put a comma after it.\n\t\tIf the expansion fails for one of the directories, there is no\n\t\terror message.",
   "argsStr": "{path}, {expr} [, {nosuf} [, {list} [, {allinks}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "has",
   "description": "Returns 1 if {feature} is supported, 0 otherwise.  The\n\t\t{feature} argument is a feature name like \"nvim-0.2.1\" or\n\t\t\"win32\", see below.  See also |exists()|.",
   "argsStr": "{feature}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "feature-list",
   "description": "List of supported pseudo-feature names:\n\t\t        acl\t\t|ACL| support\n\t\t\tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n\t\t        iconv\t\tCan use |iconv()| for conversion.\n\t\t        +shellslash\tCan use backslashes in filenames (Windows)\n\t\t\tclipboard\t|clipboard| provider is available.\n\t\t\tfname_case\tCase in file names matters (for Darwin and MS-Windows\n\t\t\t\t\tthis is not present).\n\t\t\tmac\t\tMacOS system.\n\t\t\tnvim\t\tThis is Nvim.\n\t\t\tpython2\t\tLegacy Vim |python2| interface. |has-python|\n\t\t\tpython3\t\tLegacy Vim |python3| interface. |has-python|\n\t\t\tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n\t\t\tttyin\t\tinput is a terminal (tty)\n\t\t\tttyout\t\toutput is a terminal (tty)\n\t\t\tunix\t\tUnix system.\n\t\t\t*vim_starting*\tTrue during |startup|.\n\t\t\twin32\t\tWindows system (32 or 64 bit).\n\t\t\twin64\t\tWindows system (64 bit).\n\t\t\twsl\t\tWSL (Windows Subsystem for Linux) system",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "has-patch",
   "description": "3.  Vim patch. For example the \"patch123\" feature means that\n\t\t    Vim patch 123 at the current |v:version| was included: >\n\t\t\t:if v:version > 602 || v:version == 602 && has(\"patch148\")",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "has_key",
   "description": "The result is a Number, which is 1 if |Dictionary| {dict} has\n\t\tan entry with key {key}.  Zero otherwise.",
   "argsStr": "{dict}, {key}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "haslocaldir",
   "description": "The result is a Number, which is 1 when the tabpage or window\n\t\thas set a local path via |:tcd| or |:lcd|, otherwise 0.",
   "argsStr": "[{winnr}[, {tabnr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hasmapto",
   "description": "The result is a Number, which is 1 if there is a mapping that\n\t\tcontains {what} in somewhere in the rhs (what it is mapped to)\n\t\tand this mapping exists in one of the modes indicated by\n\t\t{mode}.\n\t\tWhen {abbr} is there and it is |TRUE| use abbreviations\n\t\tinstead of mappings.  Don't forget to specify Insert and/or\n\t\tCommand-line mode.\n\t\tBoth the global mappings and the mappings local to the current\n\t\tbuffer are checked for a match.\n\t\tIf no matching mapping is found 0 is returned.\n\t\tThe following characters are recognized in {mode}:\n\t\t\tn\tNormal mode\n\t\t\tv\tVisual mode\n\t\t\to\tOperator-pending mode\n\t\t\ti\tInsert mode\n\t\t\tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n\t\t\tc\tCommand-line mode\n\t\tWhen {mode} is omitted, \"nvo\" is used.",
   "argsStr": "{what} [, {mode} [, {abbr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histadd",
   "description": "Add the String {item} to the history {history} which can be",
   "argsStr": "{history}, {item}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "hist-names",
   "description": "\"cmd\"\t or \":\"\t  command line history\n\t\t\t\"search\" or \"/\"   search pattern history\n\t\t\t\"expr\"\t or \"=\"   typed expression history\n\t\t\t\"input\"  or \"@\"\t  input line history\n\t\t\t\"debug\"  or \">\"   debug command history\n\t\t\tempty\t\t  the current or last used history\n\t\tThe {history} string does not need to be the whole name, one\n\t\tcharacter is sufficient.\n\t\tIf {item} does already exist in the history, it will be\n\t\tshifted to become the newest entry.\n\t\tThe result is a Number: 1 if the operation was successful,\n\t\totherwise 0 is returned.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "histdel",
   "description": "Clear {history}, i.e. delete all its entries.  See |hist-names|\n\t\tfor the possible values of {history}.",
   "argsStr": "{history} [, {item}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histget",
   "description": "The result is a String, the entry with Number {index} from\n\t\t{history}.  See |hist-names| for the possible values of\n\t\t{history}, and |:history-indexing| for {index}.  If there is\n\t\tno such entry, an empty String is returned.  When {index} is\n\t\tomitted, the most recent item from the history is used.",
   "argsStr": "{history} [, {index}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "histnr",
   "description": "The result is the Number of the current entry in {history}.\n\t\tSee |hist-names| for the possible values of {history}.\n\t\tIf an error occurred, -1 is returned.",
   "argsStr": "{history}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hlexists",
   "description": "The result is a Number, which is non-zero if a highlight group\n\t\tcalled {name} exists.  This is when the group has been\n\t\tdefined in some way.  Not necessarily when highlighting has\n\t\tbeen defined for it, it may also have been used for a syntax\n\t\titem.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hlID",
   "description": "The result is a Number, which is the ID of the highlight group\n\t\twith name {name}.  When the highlight group doesn't exist,\n\t\tzero is returned.\n\t\tThis can be used to retrieve information about the highlight\n\t\tgroup.  For example, to get the background color of the\n\t\t\"Comment\" group: >\n\t:echo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "hostname",
   "description": "The result is a String, which is the name of the machine on\n\t\twhich Vim is currently running.  Machine names greater than\n\t\t256 characters long are truncated.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "iconv",
   "description": "The result is a String, which is the text {expr} converted\n\t\tfrom encoding {from} to encoding {to}.\n\t\tWhen the conversion completely fails an empty string is\n\t\treturned.  When some characters could not be converted they\n\t\tare replaced with \"?\".\n\t\tThe encoding names are whatever the iconv() library function\n\t\tcan accept, see \":!man 3 iconv\".\n\t\tMost conversions require Vim to be compiled with the |+iconv|\n\t\tfeature.  Otherwise only UTF-8 to latin1 conversion and back\n\t\tcan be done.\n\t\tNote that Vim uses UTF-8 for all Unicode encodings, conversion\n\t\tfrom/to UCS-2 is automatically changed to use UTF-8.  You\n\t\tcannot use UCS-2 in a string anyway, because of the NUL bytes.",
   "argsStr": "{expr}, {from}, {to}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "indent",
   "description": "The result is a Number, which is indent of line {lnum} in the\n\t\tcurrent buffer.  The indent is counted in spaces, the value\n\t\tof 'tabstop' is relevant.  {lnum} is used just like in\n\t\t|getline()|.\n\t\tWhen {lnum} is invalid -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "index",
   "description": "Return the lowest index in |List| {list} where the item has a\n\t\tvalue equal to {expr}.  There is no automatic conversion, so\n\t\tthe String \"4\" is different from the Number 4.  And the number\n\t\t4 is different from the Float 4.0.  The value of 'ignorecase'\n\t\tis not used here, case always matters.\n\t\tIf {start} is given then start looking at the item with index\n\t\t{start} (may be negative for an item relative to the end).\n\t\tWhen {ic} is given and it is |TRUE|, ignore case.  Otherwise\n\t\tcase must match.\n\t\t-1 is returned when {expr} is not found in {list}.\n\t\tExample: >\n\t\t\t:let idx = index(words, \"the\")\n\t\t\t:if index(numbers, 123) >= 0",
   "argsStr": "{list}, {expr} [, {start} [, {ic}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "input",
   "description": "input({opts})\n\t\tThe result is a String, which is whatever the user typed on\n\t\tthe command-line.  The {prompt} argument is either a prompt\n\t\tstring, or a blank string (for no prompt).  A '\\n' can be used\n\t\tin the prompt to start a new line.",
   "argsStr": "{prompt} [, {text} [, {completion}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "input()-highlight* *E5400* *E5402",
   "description": "The optional `highlight` key allows specifying function which\n\t\twill be used for highlighting user input.  This function\n\t\treceives user input as its only argument and must return\n\t\ta list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n\t\twhere\n\t\t\thl_start_col is the first highlighted column,\n\t\t\thl_end_col is the last highlighted column (+ 1!),\n\t\t\thl_group is |:hi| group used for highlighting.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5403* *E5404* *E5405* *E5406",
   "description": "Both hl_start_col and hl_end_col + 1 must point to the start\n\t\tof the multibyte character (highlighting must not break\n\t\tmultibyte characters), hl_end_col + 1 may be equal to the\n\t\tinput length.  Start column must be in range [0, len(input)),\n\t\tend column must be in range (hl_start_col, len(input)],\n\t\tsections must be ordered so that next hl_start_col is greater\n\t\tthen or equal to previous hl_end_col.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "inputlist",
   "description": "{textlist} must be a |List| of strings.  This |List| is\n\t\tdisplayed, one string per line.  The user will be prompted to\n\t\tenter a number, which is returned.\n\t\tThe user can also select an item by clicking on it with the\n\t\tmouse.  For the first string 0 is returned.  When clicking\n\t\tabove the first item a negative number is returned.  When\n\t\tclicking on the prompt one more than the length of {textlist}\n\t\tis returned.\n\t\tMake sure {textlist} has less than 'lines' entries, otherwise\n\t\tit won't work.  It's a good idea to put the entry number at\n\t\tthe start of the string.  And put a prompt in the first item.\n\t\tExample: >\n\t\t\tlet color = inputlist(['Select color:', '1. red',\n\t\t\t\t\\ '2. green', '3. blue'])",
   "argsStr": "{textlist}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputrestore",
   "description": "Restore typeahead that was saved with a previous |inputsave()|.\n\t\tShould be called the same number of times inputsave() is\n\t\tcalled.  Calling it more often is harmless though.\n\t\tReturns 1 when there is nothing to restore, 0 otherwise.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputsave",
   "description": "Preserve typeahead (also from mappings) and clear it, so that\n\t\ta following prompt gets input from the user.  Should be\n\t\tfollowed by a matching inputrestore() after the prompt.  Can\n\t\tbe used several times, in which case there must be just as\n\t\tmany inputrestore() calls.\n\t\tReturns 1 when out of memory, 0 otherwise.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "inputsecret",
   "description": "This function acts much like the |input()| function with but\n\t\ttwo exceptions:\n\t\ta) the user's response will be displayed as a sequence of\n\t\tasterisks (\"*\") thereby keeping the entry secret, and\n\t\tb) the user's response will not be recorded on the input\n\t\t|history| stack.\n\t\tThe result is a String, which is whatever the user actually\n\t\ttyped on the command-line in response to the issued prompt.\n\t\tNOTE: Command-line completion is not supported.",
   "argsStr": "{prompt} [, {text}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "insert",
   "description": "Insert {item} at the start of |List| {list}.\n\t\tIf {idx} is specified insert {item} before the item with index\n\t\t{idx}.  If {idx} is zero it goes before the first item, just\n\t\tlike omitting {idx}.  A negative {idx} is also possible, see\n\t\t|list-index|.  -1 inserts just before the last item.\n\t\tReturns the resulting |List|.  Examples: >\n\t\t\t:let mylist = insert([2, 3, 5], 1)\n\t\t\t:call insert(mylist, 4, -1)\n\t\t\t:call insert(mylist, 6, len(mylist))\n<\t\tThe last example can be done simpler with |add()|.\n\t\tNote that when {item} is a |List| it is inserted as a single\n\t\titem.  Use |extend()| to concatenate |Lists|.",
   "argsStr": "{list}, {item} [, {idx}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "interrupt",
   "description": "Interrupt script execution.  It works more or less like the\n\t\tuser typing CTRL-C, most commands won't execute and control\n\t\treturns to the user.  This is useful to abort execution\n\t\tfrom lower down, e.g. in an autocommand.  Example: >\n\t\t:function s:check_typoname(file)\n\t\t:   if fnamemodify(a:file, ':t') == '['\n\t\t:       echomsg 'Maybe typo'\n\t\t:       call interrupt()\n\t\t:   endif\n\t\t:endfunction\n\t\t:au BufWritePre * call s:check_typoname(expand('<amatch>'))",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "invert",
   "description": "Bitwise invert.  The argument is converted to a number.  A\n\t\tList, Dict or Float argument causes an error.  Example: >\n\t\t\t:let bits = invert(bits)",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isdirectory",
   "description": "The result is a Number, which is |TRUE| when a directory\n\t\twith the name {directory} exists.  If {directory} doesn't\n\t\texist, or isn't a directory, the result is |FALSE|.  {directory}\n\t\tis any expression, which is used as a String.",
   "argsStr": "{directory}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isinf",
   "description": "Return 1 if {expr} is a positive infinity, or -1 a negative\n\t\tinfinity, otherwise 0. >\n\t\t\t:echo isinf(1.0 / 0.0)\n<\t\t\t1 >\n\t\t\t:echo isinf(-1.0 / 0.0)\n<\t\t\t-1",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "islocked",
   "description": "The result is a Number, which is |TRUE| when {expr} is the\n\t\tname of a locked variable.\n\t\t{expr} must be the name of a variable, |List| item or\n\t\t|Dictionary| entry, not the variable itself!  Example: >\n\t\t\t:let alist = [0, ['a', 'b'], 2, 3]\n\t\t\t:lockvar 1 alist\n\t\t\t:echo islocked('alist')\t\t\" 1\n\t\t\t:echo islocked('alist[1]')\t\" 0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "id",
   "description": "Returns a |String| which is a unique identifier of the\n\t\tcontainer type (|List|, |Dict| and |Partial|). It is\n\t\tguaranteed that for the mentioned types `id(v1) ==# id(v2)`\n\t\treturns true iff `type(v1) == type(v2) && v1 is v2` (note:\n\t\t|v:_null_list| and |v:_null_dict| have the same `id()` with\n\t\tdifferent types because they are internally represented as\n\t\ta NULL pointers). Currently `id()` returns a hexadecimal\n\t\trepresentanion of the pointers to the containers (i.e. like\n\t\t`0x994a40`), same as `printf(\"%p\", {expr})`, but it is advised\n\t\tagainst counting on exact format of return value.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "items",
   "description": "Return a |List| with all the key-value pairs of {dict}.  Each\n\t\t|List| item is a list with two items: the key of a {dict}\n\t\tentry and the value of this entry.  The |List| is in arbitrary\n\t\torder.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "isnan",
   "description": "Return |TRUE| if {expr} is a float with value NaN. >\n\t\t\techo isnan(0.0 / 0.0)\n<\t\t\t1",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobpid",
   "description": "Return the PID (process id) of |job-id| {job}.",
   "argsStr": "{job}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobresize",
   "description": "Resize the pseudo terminal window of |job-id| {job} to {width}\n\t\tcolumns and {height} rows.\n\t\tFails if the job was not started with `\"pty\":v:true`.",
   "argsStr": "{job}, {width}, {height}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobstart",
   "description": "Spawns {cmd} as a job.\n\t\tIf {cmd} is a List it runs directly (no 'shell').\n\t\tIf {cmd} is a String it runs in the 'shell', like this: >\n\t\t  :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n<\t\t(See |shell-unquoting| for details.)",
   "argsStr": "{cmd}[, {opts}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "jobstart-options",
   "description": "{opts} is a dictionary with these keys:\n\t\t  clear_env:  (boolean) `env` defines the job environment\n\t\t\t      exactly, instead of merging current environment.\n\t\t  cwd:\t      (string, default=|current-directory|) Working\n\t\t\t      directory of the job.\n\t\t  detach:     (boolean) Detach the job process: it will not be\n\t\t\t      killed when Nvim exits. If the process exits\n\t\t\t      before Nvim, `on_exit` will be invoked.\n\t\t  env:\t      (dict) Map of environment variable name:value\n\t\t\t      pairs extending (or replacing if |clear_env|)\n\t\t\t      the current environment.\n\t\t  height:     (number) Height of the `pty` terminal.\n\t\t  |on_exit|:    (function) Callback invoked when the job exits.\n\t\t  |on_stdout|:  (function) Callback invoked when the job emits\n\t\t\t      stdout data.\n\t\t  |on_stderr|:  (function) Callback invoked when the job emits\n\t\t\t      stderr data.\n\t\t  overlapped: (boolean) Set FILE_FLAG_OVERLAPPED for the\n\t\t\t      standard input/output passed to the child process.\n\t\t\t      Normally you do not need to set this.\n\t\t\t      (Only available on MS-Windows, On other\n\t\t\t      platforms, this option is silently ignored.)\n\t\t  pty:\t      (boolean) Connect the job to a new pseudo\n\t\t\t      terminal, and its streams to the master file\n\t\t\t      descriptor. Then  `on_stderr` is ignored,\n\t\t\t      `on_stdout` receives all output.\n\t\t  rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n\t\t\t      the job over stdio. Then `on_stdout` is ignored,\n\t\t\t      but `on_stderr` can still be used.\n\t\t  stderr_buffered: (boolean) Collect data until EOF (stream closed)\n\t\t\t      before invoking `on_stderr`. |channel-buffered|\n\t\t  stdout_buffered: (boolean) Collect data until EOF (stream\n\t\t\t      closed) before invoking `on_stdout`. |channel-buffered|\n\t\t  width:      (number) Width of the `pty` terminal.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "jobstop",
   "description": "Stop |job-id| {id} by sending SIGTERM to the job process. If\n\t\tthe process does not terminate after a timeout then SIGKILL\n\t\twill be sent. When the job terminates its |on_exit| handler\n\t\t(if any) will be invoked.\n\t\tSee |job-control|.",
   "argsStr": "{id}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "jobwait",
   "description": "Waits for jobs and their |on_exit| handlers to complete.",
   "argsStr": "{jobs}[, {timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "join",
   "description": "Join the items in {list} together into one String.\n\t\tWhen {sep} is specified it is put in between the items.  If\n\t\t{sep} is omitted a single space is used.\n\t\tNote that {sep} is not added at the end.  You might want to\n\t\tadd it there too: >\n\t\t\tlet lines = join(mylist, \"\\n\") . \"\\n\"\n<\t\tString items are used as-is.  |Lists| and |Dictionaries| are\n\t\tconverted into a string like with |string()|.\n\t\tThe opposite function is |split()|.",
   "argsStr": "{list} [, {sep}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "json_decode",
   "description": "Convert {expr} from JSON object.  Accepts |readfile()|-style\n\t\tlist as the input, as well as regular string.  May output any\n\t\tVim value. In the following cases it will output\n\t\t|msgpack-special-dict|:\n\t\t1. Dictionary contains duplicate key.\n\t\t2. Dictionary contains empty key.\n\t\t3. String contains NUL byte.  Two special dictionaries: for\n\t\t   dictionary and for string will be emitted in case string\n\t\t   with NUL byte was a dictionary key.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "json_encode",
   "description": "Convert {expr} into a JSON string.  Accepts\n\t\t|msgpack-special-dict| as the input.  Will not convert\n\t\t|Funcref|s, mappings with non-string keys (can be created as\n\t\t|msgpack-special-dict|), values with self-referencing\n\t\tcontainers, strings which contain non-UTF-8 characters,\n\t\tpseudo-UTF-8 strings which contain codepoints reserved for\n\t\tsurrogate pairs (such strings are not valid UTF-8 strings).\n\t\tNon-printable characters are converted into \"\\u1234\" escapes\n\t\tor special escapes like \"\\t\", other are dumped as-is.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "keys",
   "description": "Return a |List| with all the keys of {dict}.  The |List| is in\n\t\tarbitrary order.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "len",
   "description": "The result is a Number, which is the length of the argument.\n\t\tWhen {expr} is a String or a Number the length in bytes is\n\t\tused, as with |strlen()|.\n\t\tWhen {expr} is a |List| the number of items in the |List| is\n\t\treturned.\n\t\tWhen {expr} is a |Blob| the number of bytes is returned.\n\t\tWhen {expr} is a |Dictionary| the number of entries in the\n\t\t|Dictionary| is returned.\n\t\tOtherwise an error is given.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "libcall",
   "description": "Call function {funcname} in the run-time library {libname}\n\t\twith single argument {argument}.\n\t\tThis is useful to call functions in a library that you\n\t\tespecially made to be used with Vim.  Since only one argument\n\t\tis possible, calling standard library functions is rather\n\t\tlimited.\n\t\tThe result is the String returned by the function.  If the\n\t\tfunction returns NULL, this will appear as an empty string \"\"\n\t\tto Vim.\n\t\tIf the function returns a number, use libcallnr()!\n\t\tIf {argument} is a number, it is passed to the function as an\n\t\tint; if {argument} is a string, it is passed as a\n\t\tnull-terminated string.",
   "argsStr": "{libname}, {funcname}, {argument}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "libcallnr",
   "description": "Just like |libcall()|, but used for a function that returns an\n\t\tint instead of a string.\n\t\tExamples: >\n\t\t\t:echo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n\t\t\t:call libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n\t\t\t:call libcallnr(\"libc.so\", \"sleep\", 10)\n<",
   "argsStr": "{libname}, {funcname}, {argument}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "line",
   "description": "The result is a Number, which is the line number of the file\n\t\tposition given with {expr}.  The accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the last line in the current buffer\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    w0\t    first line visible in current window (one if the\n\t\t\t    display isn't updated, e.g. in silent Ex mode)\n\t\t    w$\t    last line visible in current window (this is one\n\t\t\t    less than \"w0\" if no lines are visible)\n\t\t    v\t    In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tNote that a mark in another file can be used.  The line number\n\t\tthen applies to another buffer.\n\t\tTo get the column number use |col()|.  To get both use\n\t\t|getpos()|.\n\t\tExamples: >\n\t\t\tline(\".\")\t\tline number of the cursor\n\t\t\tline(\"'t\")\t\tline number of mark t\n\t\t\tline(\"'\" . marker)\tline number of mark marker",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "line2byte",
   "description": "Return the byte count from the start of the buffer for line\n\t\t{lnum}.  This includes the end-of-line character, depending on\n\t\tthe 'fileformat' option for the current buffer.  The first\n\t\tline returns 1. UTF-8 encoding is used, 'fileencoding' is\n\t\tignored.  This can also be used to get the byte count for the\n\t\tline just below the last line: >\n\t\t\tline2byte(line(\"$\") + 1)\n<\t\tThis is the buffer size plus one.  If 'fileencoding' is empty\n\t\tit is the file size plus one.\n\t\tWhen {lnum} is invalid -1 is returned.\n\t\tAlso see |byte2line()|, |go| and |:goto|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "lispindent",
   "description": "Get the amount of indent for line {lnum} according the lisp\n\t\tindenting rules, as with 'lisp'.\n\t\tThe indent is counted in spaces, the value of 'tabstop' is\n\t\trelevant.  {lnum} is used just like in |getline()|.\n\t\tWhen {lnum} is invalid or Vim was not compiled the\n\t\t|+lispindent| feature, -1 is returned.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "list2str",
   "description": "Convert each number in {list} to a character string can\n\t\tconcatenate them all.  Examples: >\n\t\t\tlist2str([32])\t\treturns \" \"\n\t\t\tlist2str([65, 66, 67])\treturns \"ABC\"\n<\t\tThe same can be done (slowly) with: >\n\t\t\tjoin(map(list, {nr, val -> nr2char(val)}), '')\n<\t\t|str2list()| does the opposite.",
   "argsStr": "{list} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "localtime",
   "description": "Return the current time, measured as seconds since 1st Jan\n\t\t1970.  See also |strftime()| and |getftime()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "log",
   "description": "Return the natural logarithm (base e) of {expr} as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t(0, inf].\n\t\tExamples: >\n\t\t\t:echo log(10)\n<\t\t\t2.302585 >\n\t\t\t:echo log(exp(5))\n<\t\t\t5.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "log10",
   "description": "Return the logarithm of Float {expr} to base 10 as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo log10(1000)\n<\t\t\t3.0 >\n\t\t\t:echo log10(0.01)\n<\t\t\t-2.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "map",
   "description": "{expr1} must be a |List| or a |Dictionary|.\n\t\tReplace each item in {expr1} with the result of evaluating\n\t\t{expr2}. {expr2} must be a |string| or |Funcref|.",
   "argsStr": "{expr1}, {expr2}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "maparg",
   "description": "When {dict} is omitted or zero: Return the rhs of mapping\n\t\t{name} in mode {mode}.  The returned String has special\n\t\tcharacters translated like in the output of the \":map\" command\n\t\tlisting.",
   "argsStr": "{name} [, {mode} [, {abbr} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mapcheck",
   "description": "Check if there is a mapping that matches with {name} in mode\n\t\t{mode}.  See |maparg()| for {mode} and special names in\n\t\t{name}.\n\t\tWhen {abbr} is there and it is non-zero use abbreviations\n\t\tinstead of mappings.\n\t\tA match happens with a mapping that starts with {name} and\n\t\twith a mapping which is equal to the start of {name}.",
   "argsStr": "{name} [, {mode} [, {abbr}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "match",
   "description": "When {expr} is a |List| then this returns the index of the\n\t\tfirst item where {pat} matches.  Each item is used as a\n\t\tString, |Lists| and |Dictionaries| are used as echoed.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strpbrk",
   "description": "Vim doesn't have a strpbrk() function.  But you can do: >\n\t\t\t:let sepidx = match(line, '[.,;: \\t]')",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strcasestr",
   "description": "Vim doesn't have a strcasestr() function.  But you can add\n\t\t\"\\c\" to the pattern to ignore case: >\n\t\t\t:let idx = match(haystack, '\\cneedle')\n<\n\t\tIf {start} is given, the search starts from byte index\n\t\t{start} in a String or item {start} in a |List|.\n\t\tThe result, however, is still the index counted from the\n\t\tfirst character/item.  Example: >\n\t\t\t:echo match(\"testing\", \"ing\", 2)\n<\t\tresult is again \"4\". >\n\t\t\t:echo match(\"testing\", \"ing\", 4)\n<\t\tresult is again \"4\". >\n\t\t\t:echo match(\"testing\", \"t\", 2)\n<\t\tresult is \"3\".\n\t\tFor a String, if {start} > 0 then it is like the string starts\n\t\t{start} bytes later, thus \"^\" will match at {start}.  Except\n\t\twhen {count} is given, then it's like matches before the\n\t\t{start} byte are ignored (this is a bit complicated to keep it\n\t\tbackwards compatible).\n\t\tFor a String, if {start} < 0, it will be set to 0.  For a list\n\t\tthe index is counted from the end.\n\t\tIf {start} is out of range ({start} > strlen({expr}) for a\n\t\tString or {start} > len({expr}) for a |List|) -1 is returned.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchadd",
   "description": "Defines a pattern to be highlighted in the current window (a\n\t\t\"match\").  It will be highlighted with {group}.  Returns an\n\t\tidentification number (ID), which can be used to delete the\n\t\tmatch using |matchdelete()|.  The ID is bound to the window.\n\t\tMatching is case sensitive and magic, unless case sensitivity\n\t\tor magicness are explicitly overridden in {pattern}.  The\n\t\t'magic', 'smartcase' and 'ignorecase' options are not used.\n\t\tThe \"Conceal\" value is special, it causes the match to be\n\t\tconcealed.",
   "argsStr": "{group}, {pattern}[, {priority}[, {id} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchaddpos",
   "description": "Same as |matchadd()|, but requires a list of positions {pos}\n\t\tinstead of a pattern. This command is faster than |matchadd()|\n\t\tbecause it does not require to handle regular expressions and\n\t\tsets buffer line boundaries to redraw screen. It is supposed\n\t\tto be used when fast match additions and deletions are\n\t\trequired, for example to highlight matching parentheses.",
   "argsStr": "{group}, {pos} [, {priority} [, {id} [, {dict}]]]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5030* *E5031",
   "description": "The list {pos} can contain one of these items:\n\t\t- A number.  This whole line will be highlighted.  The first\n\t\t  line has number 1.\n\t\t- A list with one number, e.g., [23]. The whole line with this\n\t\t  number will be highlighted.\n\t\t- A list with two numbers, e.g., [23, 11]. The first number is\n\t\t  the line number, the second one is the column number (first\n\t\t  column is 1, the value must correspond to the byte index as\n\t\t  |col()| would return).  The character at this position will\n\t\t  be highlighted.\n\t\t- A list with three numbers, e.g., [23, 11, 3]. As above, but\n\t\t  the third number gives the length of the highlight in bytes.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "matcharg",
   "description": "Selects the {nr} match item, as set with a |:match|,\n\t\t|:2match| or |:3match| command.\n\t\tReturn a |List| with two elements:\n\t\t\tThe name of the highlight group used\n\t\t\tThe pattern used.\n\t\tWhen {nr} is not 1, 2 or 3 returns an empty |List|.\n\t\tWhen there is no match item set returns ['', ''].\n\t\tThis is useful to save and restore a |:match|.\n\t\tHighlighting matches using the |:match| commands are limited\n\t\tto three matches. |matchadd()| does not have this limitation.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchdelete",
   "description": "Deletes a match with ID {id} previously defined by |matchadd()|\n\t\tor one of the |:match| commands.  Returns 0 if successful,\n\t\totherwise -1.  See example for |matchadd()|.  All matches can\n\t\tbe deleted in one operation by |clearmatches()|.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsStr": "{id} [, {win}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchend",
   "description": "Same as |match()|, but return the index of first character\n\t\tafter the match.  Example: >\n\t\t\t:echo matchend(\"testing\", \"ing\")\n<\t\tresults in \"7\".",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strspn()* *strcspn",
   "description": "Vim doesn't have a strspn() or strcspn() function, but you can\n\t\tdo it with matchend(): >\n\t\t\t:let span = matchend(line, '[a-zA-Z]')\n\t\t\t:let span = matchend(line, '[^a-zA-Z]')\n<\t\tExcept that -1 is returned when there are no matches.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchlist",
   "description": "Same as |match()|, but return a |List|.  The first item in the\n\t\tlist is the matched string, same as what matchstr() would\n\t\treturn.  Following items are submatches, like \"\\1\", \"\\2\", etc.\n\t\tin |:substitute|.  When an optional submatch didn't match an\n\t\tempty string is used.  Example: >\n\t\t\techo matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)')\n<\t\tResults in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']\n\t\tWhen there is no match an empty list is returned.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchstr",
   "description": "Same as |match()|, but return the matched string.  Example: >\n\t\t\t:echo matchstr(\"testing\", \"ing\")\n<\t\tresults in \"ing\".\n\t\tWhen there is no match \"\" is returned.\n\t\tThe {start}, if given, has the same meaning as for |match()|. >\n\t\t\t:echo matchstr(\"testing\", \"ing\", 2)\n<\t\tresults in \"ing\". >\n\t\t\t:echo matchstr(\"testing\", \"ing\", 5)\n<\t\tresult is \"\".\n\t\tWhen {expr} is a |List| then the matching item is returned.\n\t\tThe type isn't changed, it's not necessarily a String.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "matchstrpos",
   "description": "Same as |matchstr()|, but return the matched string, the start\n\t\tposition and the end position of the match.  Example: >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\")\n<\t\tresults in [\"ing\", 4, 7].\n\t\tWhen there is no match [\"\", -1, -1] is returned.\n\t\tThe {start}, if given, has the same meaning as for |match()|. >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\", 2)\n<\t\tresults in [\"ing\", 4, 7]. >\n\t\t\t:echo matchstrpos(\"testing\", \"ing\", 5)\n<\t\tresult is [\"\", -1, -1].\n\t\tWhen {expr} is a |List| then the matching item, the index\n\t\tof first item where {pat} matches, the start position and the\n\t\tend position of the match are returned. >\n\t\t\t:echo matchstrpos([1, '__x'], '\\a')\n<\t\tresult is [\"x\", 1, 2, 3].\n\t\tThe type isn't changed, it's not necessarily a String.",
   "argsStr": "{expr}, {pat} [, {start} [, {count}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "max",
   "description": "Return the maximum value of all items in {expr}.\n\t\t{expr} can be a list or a dictionary.  For a dictionary,\n\t\tit returns the maximum of all values in the dictionary.\n\t\tIf {expr} is neither a list nor a dictionary, or one of the\n\t\titems in {expr} cannot be used as a Number this results in\n                an error.  An empty |List| or |Dictionary| results in zero.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "menu_get",
   "description": "Returns a |List| of |Dictionaries| describing |menus| (defined\n\t\tby |:menu|, |:amenu|, …), including |hidden-menus|.",
   "argsStr": "{path}, {modes}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "min",
   "description": "Return the minimum value of all items in {expr}.\n\t\t{expr} can be a list or a dictionary.  For a dictionary,\n\t\tit returns the minimum of all values in the dictionary.\n\t\tIf {expr} is neither a list nor a dictionary, or one of the\n\t\titems in {expr} cannot be used as a Number this results in\n\t\tan error.  An empty |List| or |Dictionary| results in zero.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mkdir",
   "description": "Create directory {name}.\n\t\tIf {path} is \"p\" then intermediate directories are created as\n\t\tnecessary.  Otherwise it must be \"\".\n\t\tIf {prot} is given it is used to set the protection bits of\n\t\tthe new directory.  The default is 0755 (rwxr-xr-x: r/w for\n\t\tthe user readable for others).  Use 0700 to make it unreadable\n\t\tfor others.",
   "argsStr": "{name} [, {path} [, {prot}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "mode",
   "description": "Return a string that indicates the current mode.\n\t\tIf [expr] is supplied and it evaluates to a non-zero Number or\n\t\ta non-empty String (|non-zero-arg|), then the full mode is\n\t\treturned, otherwise only the first letter is returned.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "msgpackdump",
   "description": "Convert a list of VimL objects to msgpack. Returned value is\n\t\t|readfile()|-style list. Example: >\n\t\t\tcall writefile(msgpackdump([{}]), 'fname.mpack', 'b')\n<\t\tThis will write the single 0x80 byte to `fname.mpack` file\n\t\t(dictionary with zero items is represented by 0x80 byte in\n\t\tmessagepack).",
   "argsStr": "{list}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5004* *E5005",
   "description": "1. |Funcref|s cannot be dumped.\n\t\t2. Containers that reference themselves cannot be dumped.\n\t\t3. Dictionary keys are always dumped as STR strings.\n\t\t4. Other strings are always dumped as BIN strings.\n\t\t5. Points 3. and 4. do not apply to |msgpack-special-dict|s.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "msgpackparse",
   "description": "Convert a |readfile()|-style list to a list of VimL objects.\n\t\tExample: >\n\t\t\tlet fname = expand('~/.config/nvim/shada/main.shada')\n\t\t\tlet mpack = readfile(fname, 'b')\n\t\t\tlet shada_objects = msgpackparse(mpack)\n<\t\tThis will read ~/.config/nvim/shada/main.shada file to\n\t\t`shada_objects` list.",
   "argsStr": "{list}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "msgpack-special-dict",
   "description": "Some messagepack strings may be parsed to special\n\t\tdictionaries. Special dictionaries are dictionaries which",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "msgpack-special-map",
   "description": "map|List| of |List|s with two items (key and value) each.\n\t\t\tThis value will appear in |msgpackparse()| output if\n\t\t\tparsed mapping contains one of the following keys:\n\t\t\t1. Any key that is not a string (including keys which\n\t\t\t   are binary strings).\n\t\t\t2. String with NUL byte inside.\n\t\t\t3. Duplicate key.\n\t\t\t4. Empty key.\n\t\text\t|List| with two values: first is a signed integer\n\t\t\trepresenting extension type. Second is\n\t\t\t|readfile()|-style list of strings.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "nextnonblank",
   "description": "Return the line number of the first line at or below {lnum}\n\t\tthat is not blank.  Example: >\n\t\t\tif getline(nextnonblank(1)) =~ \"Java\"\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\n\t\tbelow it, zero is returned.\n\t\tSee also |prevnonblank()|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "nr2char",
   "description": "Return a string with a single character, which has the number\n\t\tvalue {expr}.  Examples: >\n\t\t\tnr2char(64)\t\treturns \"@\"\n\t\t\tnr2char(32)\t\treturns \" \"\n<\t\tExample for \"utf-8\": >\n\t\t\tnr2char(300)\t\treturns I with bow character\n<\t\tUTF-8 encoding is always used, {utf8} option has no effect,\n\t\tand exists only for backwards-compatibility.\n\t\tNote that a NUL character in the file is specified with\n\t\tnr2char(10), because NULs are represented with newline\n\t\tcharacters.  nr2char(0) is a real NUL and terminates the\n\t\tstring, thus results in an empty string.",
   "argsStr": "{expr} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "nvim_...",
   "description": "Call nvim |api| functions. The type checking of arguments will\n\t\tbe stricter than for most other builtins. For instance,\n\t\tif Integer is expected, a |Number| must be passed in, a\n\t\t|String| will not be autoconverted.\n\t\tBuffer numbers, as returned by |bufnr()| could be used as\n\t\tfirst argument to nvim_buf_... functions.  All functions\n\t\texpecting an object (buffer, window or tabpage) can\n\t\talso take the numerical value 0 to indicate the current\n\t\t(focused) object.",
   "argsStr": "{...}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "or",
   "description": "Bitwise OR on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let bits = or(bits, 0x80)",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pathshorten",
   "description": "Shorten directory names in the path {expr} and return the\n\t\tresult.  The tail, the file name, is kept as-is.  The other\n\t\tcomponents in the path are reduced to single letters.  Leading\n\t\t'~' and '.' characters are kept.  Example: >\n\t\t\t:echo pathshorten('~/.config/nvim/autoload/file1.vim')\n<\t\t\t~/.c/n/a/file1.vim ~\n\t\tIt doesn't matter if the path exists or not.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "perleval",
   "description": "Evaluate |perl| expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type,\n\t\tnon-string keys result in error.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pow",
   "description": "Return the power of {x} to the exponent {y} as a |Float|.\n\t\t{x} and {y} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo pow(3, 3)\n<\t\t\t27.0 >\n\t\t\t:echo pow(2, 16)\n<\t\t\t65536.0 >\n\t\t\t:echo pow(32, 0.20)\n<\t\t\t2.0",
   "argsStr": "{x}, {y}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prevnonblank",
   "description": "Return the line number of the first line at or above {lnum}\n\t\tthat is not blank.  Example: >\n\t\t\tlet ind = indent(prevnonblank(v:lnum - 1))\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\n\t\tabove it, zero is returned.\n\t\tAlso see |nextnonblank()|.",
   "argsStr": "{lnum}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "printf",
   "description": "Return a String with {fmt}, where \"%\" items are replaced by\n\t\tthe formatted form of their respective arguments.  Example: >\n\t\t\tprintf(\"%4d: E%d %.30s\", lnum, errno, msg)\n<\t\tMay result in:\n\t\t\t\"  99: E42 asdfasdfasdfasdfasdfasdfasdfas\" ~",
   "argsStr": "{fmt}, {expr1} ...",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X",
   "description": "dbBoxXThe Number argument is converted to signed decimal (d),\n\t\t\tunsigned binary (b and B), unsigned octal (o), or\n\t\t\tunsigned hexadecimal (x and X) notation.  The letters\n\t\t\t\"abcdef\" are used for x conversions; the letters\n\t\t\t\"ABCDEF\" are used for X conversions.  The precision, if\n\t\t\tany, gives the minimum number of digits that must\n\t\t\tappear; if the converted value requires fewer digits, it\n\t\t\tis padded on the left with zeros.  In no case does a\n\t\t\tnon-existent or small field width cause truncation of a\n\t\t\tnumeric field; if the result of a conversion is wider\n\t\t\tthan the field width, the field is expanded to contain\n\t\t\tthe conversion result.\n\t\t\tThe 'h' modifier indicates the argument is 16 bits.\n\t\t\tThe 'l' modifier indicates the argument is 32 bits.\n\t\t\tThe 'L' modifier indicates the argument is 64 bits.\n\t\t\tGenerally, these modifiers are not useful. They are\n\t\t\tignored when type is known from the argument.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-c",
   "description": "cThe Number argument is converted to a byte, and the\n\t\t\tresulting character is written.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-s",
   "description": "sThe text of the String argument is used.  If a\n\t\t\tprecision is specified, no more bytes than the number\n\t\t\tspecified are used.\n\t\t\tIf the argument is not a String type, it is\n\t\t\tautomatically converted to text with the same format\n\t\t\tas \":echo\".",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-S",
   "description": "SThe text of the String argument is used.  If a\n\t\t\tprecision is specified, no more display cells than the\n\t\t\tnumber specified are used.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-f* *E807",
   "description": "f FThe Float argument is converted into a string of the\n\t\t\tform 123.456.  The precision specifies the number of\n\t\t\tdigits after the decimal point.  When the precision is\n\t\t\tzero the decimal point is omitted.  When the precision\n\t\t\tis not specified 6 is used.  A really big number\n\t\t\t(out of range or dividing by zero) results in \"inf\"\n\t\t\t or \"-inf\" with %f (INF or -INF with %F).\n\t\t\t \"0.0 / 0.0\" results in \"nan\" with %f (NAN with %F).\n\t\t\tExample: >\n\t\t\t\techo printf(\"%.2f\", 12.115)\n<\t\t\t\t12.12\n\t\t\tNote that roundoff depends on the system libraries.\n\t\t\tUse |round()| when in doubt.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-e* *printf-E",
   "description": "e EThe Float argument is converted into a string of the\n\t\t\tform 1.234e+03 or 1.234E+03 when using 'E'.  The\n\t\t\tprecision specifies the number of digits after the\n\t\t\tdecimal point, like with 'f'.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-g* *printf-G",
   "description": "g GThe Float argument is converted like with 'f' if the\n\t\t\tvalue is between 0.001 (inclusive) and 10000000.0\n\t\t\t(exclusive).  Otherwise 'e' is used for 'g' and 'E'\n\t\t\tfor 'G'.  When no precision is specified superfluous\n\t\t\tzeroes and '+' signs are removed, except for the zero\n\t\t\timmediately after the decimal point.  Thus 10000000.0\n\t\t\tresults in 1.0e7.",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "printf-%",
   "description": "%A '%' is written.  No argument is converted.  The\n\t\t\tcomplete conversion specification is \"%%\".",
   "valuetype": "any"
  },
  {
   "type": "value",
   "name": "E766* *E767",
   "description": "The number of {exprN} arguments must exactly match the number\n\t\tof \"%\" items.  If there are not sufficient or too many\n\t\targuments an error is given.  Up to 18 arguments can be used.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "prompt_setcallback",
   "description": "Set prompt callback for buffer {buf} to {expr}.  When {expr}\n\t\tis an empty string the callback is removed.  This has only\n\t\teffect if {buf} has 'buftype' set to \"prompt\".",
   "argsStr": "{buf}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prompt_setinterrupt",
   "description": "Set a callback for buffer {buf} to {expr}.  When {expr} is an\n\t\tempty string the callback is removed.  This has only effect if\n\t\t{buf} has 'buftype' set to \"prompt\".",
   "argsStr": "{buf}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "prompt_setprompt",
   "description": "Set prompt for buffer {buf} to {text}.  You most likely want\n\t\t{text} to end in a space.\n\t\tThe result is only visible if {buf} has 'buftype' set to\n\t\t\"prompt\".  Example: >\n\t\t\tcall prompt_setprompt(bufnr(''), 'command: ')",
   "argsStr": "{buf}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pum_getpos",
   "description": "If the popup menu (see |ins-completion-menu|) is not visible,\n \t\treturns an empty |Dictionary|, otherwise, returns a\n \t\t|Dictionary| with the following keys:\n \t\t\theight\t\tnr of items visible\n \t\t\twidth\t\tscreen cells\n \t\t\trow\t\ttop screen row (0 first row)\n \t\t\tcol\t\tleftmost screen column (0 first col)\n \t\t\tsize\t\ttotal nr of items\n \t\t\tscrollbar\t|TRUE| if visible",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pumvisible",
   "description": "Returns non-zero when the popup menu is visible, zero\n\t\totherwise.  See |ins-completion-menu|.\n\t\tThis can be used to avoid some things that would remove the\n\t\tpopup menu.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "py3eval",
   "description": "Evaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though, Unicode strings are additionally converted to\n\t\tUTF-8).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type with\n\t\tkeys converted to strings.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pyeval",
   "description": "*pyeval()*\n\t\tEvaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers and strings are returned as they are (strings are\n\t\tcopied though).\n\t\tLists are represented as Vim |List| type.\n\t\tDictionaries are represented as Vim |Dictionary| type,\n\t\tnon-string keys result in error.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "pyxeval",
   "description": "Evaluate Python expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tUses Python 2 or 3, see |python_x| and 'pyxversion'.\n\t\tSee also: |pyeval()|, |py3eval()|",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "range",
   "description": "*range()*\n\t\tReturns a |List| with Numbers:\n\t\t- If only {expr} is specified: [0, 1, ..., {expr} - 1]\n\t\t- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]\n\t\t- If {stride} is specified: [{expr}, {expr} + {stride}, ...,\n\t\t  {max}] (increasing {expr} with {stride} each time, not\n\t\t  producing a value past {max}).\n\t\tWhen the maximum is one before the start the result is an\n\t\tempty list.  When the maximum is more than one before the\n\t\tstart this is an error.\n\t\tExamples: >\n\t\t\trange(4)\t\t\" [0, 1, 2, 3]\n\t\t\trange(2, 4)\t\t\" [2, 3, 4]\n\t\t\trange(2, 9, 3)\t\t\" [2, 5, 8]\n\t\t\trange(2, -2, -1)\t\" [2, 1, 0, -1, -2]\n\t\t\trange(0)\t\t\" []\n\t\t\trange(2, 0)\t\t\" error!\n<",
   "argsStr": "{expr} [, {max} [, {stride}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "readdir",
   "description": "Return a list with file and directory names in {directory}.",
   "argsStr": "{directory} [, {expr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "readfile",
   "description": "Read file {fname} and return a |List|, each line of the file\n\t\tas an item.  Lines are broken at NL characters.  Macintosh\n\t\tfiles separated with CR will result in a single long line\n\t\t(unless a NL appears somewhere).\n\t\tAll NUL characters are replaced with a NL character.\n\t\tWhen {binary} contains \"b\" binary mode is used:\n\t\t- When the last line ends in a NL an extra empty list item is\n\t\t  added.\n\t\t- No CR characters are removed.\n\t\tOtherwise:\n\t\t- CR characters that appear before a NL are removed.\n\t\t- Whether the last line ends in a NL or not does not matter.\n\t\t- Any UTF-8 byte order mark is removed from the text.\n\t\tWhen {max} is given this specifies the maximum number of lines\n\t\tto be read.  Useful if you only want to check the first ten\n\t\tlines of a file: >\n\t\t\t:for line in readfile(fname, '', 10)\n\t\t\t:  if line =~ 'Date' | echo line | endif\n\t\t\t:endfor\n<\t\tWhen {max} is negative -{max} lines from the end of the file\n\t\tare returned, or as many as there are.\n\t\tWhen {max} is zero the result is an empty list.\n\t\tNote that without {max} the whole file is read into memory.\n\t\tAlso note that there is no recognition of encoding.  Read a\n\t\tfile into a buffer if you need to.\n\t\tWhen the file can't be opened an error message is given and\n\t\tthe result is an empty list.\n\t\tAlso see |writefile()|.",
   "argsStr": "{fname} [, {binary} [, {max}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reg_executing",
   "description": "Returns the single letter name of the register being executed.\n\t\tReturns an empty string when no register is being executed.\n\t\tSee |@|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reg_recording",
   "description": "Returns the single letter name of the register being recorded.\n\t\tReturns an empty string string when not recording.  See |q|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltime",
   "description": "Return an item that represents a time value.  The format of\n\t\tthe item depends on the system.  It can be passed to\n\t\t|reltimestr()| to convert it to a string or |reltimefloat()|\n\t\tto convert to a float.",
   "argsStr": "[{start} [, {end}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltimefloat",
   "description": "Return a Float that represents the time value of {time}.\n\t\tUnit of time is seconds.\n\t\tExample:\n\t\t\tlet start = reltime()\n\t\t\tcall MyFunction()\n\t\t\tlet seconds = reltimefloat(reltime(start))\n\t\tSee the note of reltimestr() about overhead.\n \t\tAlso see |profiling|.",
   "argsStr": "{time}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reltimestr",
   "description": "Return a String that represents the time value of {time}.\n\t\tThis is the number of seconds, a dot and the number of\n\t\tmicroseconds.  Example: >\n\t\t\tlet start = reltime()\n\t\t\tcall MyFunction()\n\t\t\techo reltimestr(reltime(start))\n<\t\tNote that overhead for the commands will be added to the time.\n\t\tLeading spaces are used to make the string align nicely.  You\n\t\tcan use split() to remove it. >\n\t\t\techo split(reltimestr(reltime(start)))[0]\n<\t\tAlso see |profiling|.",
   "argsStr": "{time}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_expr",
   "description": "Send the {string} to {server}.  The string is sent as an\n\t\texpression and the result is returned after evaluation.\n\t\tThe result must be a String or a |List|.  A |List| is turned\n\t\tinto a String by joining the items with a line break in\n\t\tbetween (not at the end), like with join(expr, \"\\n\").\n\t\tIf {idvar} is present and not empty, it is taken as the name\n\t\tof a variable and a {serverid} for later use with\n\t\t|remote_read()| is stored there.\n\t\tIf {timeout} is given the read times out after this many\n\t\tseconds.  Otherwise a timeout of 600 seconds is used.\n\t\tSee also |clientserver| |RemoteReply|.\n\t\tThis function is not available in the |sandbox|.\n\t\tNote: Any errors will cause a local error message to be issued\n\t\tand the result will be the empty string.",
   "argsStr": "{server}, {string} [, {idvar} [, {timeout}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_foreground",
   "description": "Move the Vim server with the name {server} to the foreground.\n\t\tThis works like: >\n\t\t\tremote_expr({server}, \"foreground()\")\n<\t\tExcept that on Win32 systems the client does the work, to work\n\t\taround the problem that the OS doesn't always allow the server\n\t\tto bring itself to the foreground.\n\t\tNote: This does not restore the window if it was minimized,\n\t\tlike foreground() does.\n\t\tThis function is not available in the |sandbox|.\n\t\t{only in the Win32 GUI and the Win32 console version}",
   "argsStr": "{server}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_peek",
   "description": "Returns a positive number if there are available strings\n\t\tfrom {serverid}.  Copies any reply string into the variable\n\t\t{retvar} if specified.  {retvar} must be a string with the\n\t\tname of a variable.\n\t\tReturns zero if none are available.\n\t\tReturns -1 if something is wrong.\n\t\tSee also |clientserver|.\n\t\tThis function is not available in the |sandbox|.\n\t\tExamples: >\n\t\t\t:let repl = \"\"\n\t\t\t:echo \"PEEK: \".remote_peek(id, \"repl\").\": \".repl",
   "argsStr": "{serverid} [, {retvar}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_read",
   "description": "Return the oldest available reply from {serverid} and consume\n\t\tit.  Unless a {timeout} in seconds is given, it blocks until a\n\t\treply is available.\n\t\tSee also |clientserver|.\n\t\tThis function is not available in the |sandbox|.\n\t\tExample: >\n\t\t\t:echo remote_read(id)\n<",
   "argsStr": "{serverid}, [{timeout}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_send",
   "description": "Send the {string} to {server}.  The string is sent as input\n\t\tkeys and the function returns immediately.  At the Vim server\n\t\tthe keys are not mapped |:map|.\n\t\tIf {idvar} is present, it is taken as the name of a variable\n\t\tand a {serverid} for later use with remote_read() is stored\n\t\tthere.\n\t\tSee also |clientserver| |RemoteReply|.\n\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{server}, {string} [, {idvar}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remote_startserver",
   "description": "Become the server {name}.  This fails if already running as a\n\t\tserver, when |v:servername| is not empty.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "remove",
   "description": "Without {end}: Remove the item at {idx} from |List| {list} and\n\t\treturn the item.\n\t\tWith {end}: Remove items from {idx} to {end} (inclusive) and\n\t\treturn a List with these items.  When {idx} points to the same\n\t\titem as {end} a list with one item is returned.  When {end}\n\t\tpoints to an item before {idx} this is an error.\n\t\tSee |list-index| for possible values of {idx} and {end}.\n\t\tExample: >\n\t\t\t:echo \"last item: \" . remove(mylist, -1)\n\t\t\t:call remove(mylist, 0, 9)\nremove({dict}, {key})\n\t\tRemove the entry from {dict} with key {key} and return it.\n\t\tExample: >\n\t\t\t:echo \"removed \" . remove(dict, \"one\")\n<\t\tIf there is no {key} in {dict} this is an error.",
   "argsStr": "{list}, {idx} [, {end}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rename",
   "description": "Rename the file by the name {from} to the name {to}.  This\n\t\tshould also work to move files across file systems.  The\n\t\tresult is a Number, which is 0 if the file was renamed\n\t\tsuccessfully, and non-zero when the renaming failed.\n\t\tNOTE: If {to} exists it is overwritten without warning.\n\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{from}, {to}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "repeat",
   "description": "Repeat {expr} {count} times and return the concatenated\n\t\tresult.  Example: >\n\t\t\t:let separator = repeat('-', 80)\n<\t\tWhen {count} is zero or negative the result is empty.\n\t\tWhen {expr} is a |List| the result is {expr} concatenated\n\t\t{count} times.  Example: >\n\t\t\t:let longlist = repeat(['a', 'b'], 3)\n<\t\tResults in ['a', 'b', 'a', 'b', 'a', 'b'].",
   "argsStr": "{expr}, {count}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "resolve",
   "description": "On MS-Windows, when {filename} is a shortcut (a .lnk file),\n\t\treturns the path the shortcut points to in a simplified form.\n\t\tOn Unix, repeat resolving symbolic links in all path\n\t\tcomponents of {filename} and return the simplified result.\n\t\tTo cope with link cycles, resolving of symbolic links is\n\t\tstopped after 100 iterations.\n\t\tOn other systems, return the simplified {filename}.\n\t\tThe simplification step is done as by |simplify()|.\n\t\tresolve() keeps a leading path component specifying the\n\t\tcurrent directory (provided the result is still a relative\n\t\tpath name) and also keeps a trailing path separator.",
   "argsStr": "{filename}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "reverse",
   "description": "Reverse the order of items in {list} in-place.  Returns\n\t\t{list}.\n\t\tIf you want a list to remain unmodified make a copy first: >\n\t\t\t:let revlist = reverse(copy(mylist))",
   "argsStr": "{list}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "round",
   "description": "Round off {expr} to the nearest integral value and return it\n\t\tas a |Float|.  If {expr} lies halfway between two integral\n\t\tvalues, then use the larger one (away from zero).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo round(0.456)\n<\t\t\t0.0  >\n\t\t\techo round(4.5)\n<\t\t\t5.0 >\n\t\t\techo round(-4.5)\n<\t\t\t-5.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcnotify",
   "description": "Sends {event} to {channel} via |RPC| and returns immediately.\n\t\tIf {channel} is 0, the event is broadcast to all channels.\n\t\tExample: >\n\t\t\t:au VimLeave call rpcnotify(0, \"leaving\")",
   "argsStr": "{channel}, {event}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcrequest",
   "description": "Sends a request to {channel} to invoke {method} via\n\t\t|RPC| and blocks until a response is received.\n\t\tExample: >\n\t\t\t:let result = rpcrequest(rpc_chan, \"func\", 1, 2, 3)",
   "argsStr": "{channel}, {method}[, {args}...]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rpcstart",
   "description": "Deprecated. Replace  >\n\t\t\t:let id = rpcstart('prog', ['arg1', 'arg2'])\n<\t\twith >\n\t\t\t:let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})",
   "argsStr": "{prog}[, {argv}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "rubyeval",
   "description": "Evaluate Ruby expression {expr} and return its result\n\t\tconverted to Vim data structures.\n\t\tNumbers, floats and strings are returned as they are (strings\n\t\tare copied though).\n\t\tArrays are represented as Vim |List| type.\n\t\tHashes are represented as Vim |Dictionary| type.\n\t\tOther objects are represented as strings resulted from their\n\t\t\"Object#to_s\" method.\n\t\t{only available when compiled with the |+ruby| feature}",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenattr",
   "description": "Like |screenchar()|, but return the attribute.  This is a rather\n\t\tarbitrary number that can only be used to compare to the\n\t\tattribute at other positions.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenchar",
   "description": "The result is a Number, which is the character at position\n\t\t[row, col] on the screen.  This works for every possible\n\t\tscreen position, also status lines, window separators and the\n\t\tcommand line.  The top left position is row one, column one\n\t\tThe character excludes composing characters.  For double-byte\n\t\tencodings it may only be the first byte.\n\t\tThis is mainly to be used for testing.\n\t\tReturns -1 when row or col is out of range.",
   "argsStr": "{row}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screencol",
   "description": "The result is a Number, which is the current screen column of\n\t\tthe cursor. The leftmost column has number 1.\n\t\tThis function is mainly used for testing.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenpos",
   "description": "The result is a Dict with the screen position of the text\n\t\tcharacter in window {winid} at buffer line {lnum} and column\n\t\t{col}.  {col} is a one-based byte index.\n\t\tThe Dict has these members:\n\t\t\trow\tscreen row\n\t\t\tcol\tfirst screen column\n\t\t\tendcol\tlast screen column\n\t\t\tcurscol\tcursor screen column\n\t\tIf the specified position is not visible, all values are zero.\n\t\tThe \"endcol\" value differs from \"col\" when the character\n\t\toccupies more than one screen cell.  E.g. for a Tab \"col\" can\n\t\tbe 1 and \"endcol\" can be 8.\n\t\tThe \"curscol\" value is where the cursor would be placed.  For\n\t\ta Tab it would be the same as \"endcol\", while for a double\n\t\twidth character it would be the same as \"col\".",
   "argsStr": "{winid}, {lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "screenrow",
   "description": "The result is a Number, which is the current screen row of the\n\t\tcursor.  The top line has number one.\n\t\tThis function is mainly used for testing.\n\t\tAlternatively you can use |winline()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "search",
   "description": "Search for regexp pattern {pattern}.  The search starts at the\n\t\tcursor position (you can use |cursor()| to set it).",
   "argsStr": "{pattern} [, {flags} [, {stopline} [, {timeout}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "search()-sub-match",
   "description": "With the 'p' flag the returned value is one more than the\n\t\tfirst sub-match in \\(\\).  One if none of them matched but the\n\t\twhole pattern did match.\n\t\tTo get the column number too use |searchpos()|.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchdecl",
   "description": "Search for the declaration of {name}.",
   "argsStr": "{name} [, {global} [, {thisblock}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpair",
   "description": "[, {stopline} [, {timeout}]]]])\n\t\tSearch for the match of a nested start-end pair.  This can be\n\t\tused to find the \"endif\" that matches an \"if\", while other\n\t\tif/endif pairs in between are ignored.\n\t\tThe search starts at the cursor.  The default is to search\n\t\tforward, include 'b' in {flags} to search backward.\n\t\tIf a match is found, the cursor is positioned at it and the\n\t\tline number is returned.  If no match is found 0 or -1 is\n\t\treturned and the cursor doesn't move.  No error message is\n\t\tgiven.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpairpos",
   "description": "[, {stopline} [, {timeout}]]]])\n\t\tSame as |searchpair()|, but returns a |List| with the line and\n\t\tcolumn position of the match. The first element of the |List|\n\t\tis the line number and the second element is the byte index of\n\t\tthe column position of the match.  If no match is found,\n\t\treturns [0, 0]. >",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "searchpos",
   "description": "Same as |search()|, but returns a |List| with the line and\n\t\tcolumn position of the match. The first element of the |List|\n\t\tis the line number and the second element is the byte index of\n\t\tthe column position of the match. If no match is found,\n\t\treturns [0, 0].\n\t\tExample: >\n\t:let [lnum, col] = searchpos('mypattern', 'n')",
   "argsStr": "{pattern} [, {flags} [, {stopline} [, {timeout}]]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "server2client",
   "description": "Send a reply string to {clientid}.  The most recent {clientid}\n\t\tthat sent a string can be retrieved with expand(\"<client>\").\n\t\tNote:\n\t\tThis id has to be stored before the next command can be\n\t\treceived.  I.e. before returning from the received command and\n\t\tbefore calling any commands that waits for input.\n\t\tSee also |clientserver|.\n\t\tExample: >\n\t\t\t:echo server2client(expand(\"<client>\"), \"HELLO\")\n<",
   "argsStr": "{clientid}, {string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverlist",
   "description": "Returns a list of server addresses, or empty if all servers\n\t\twere stopped. |serverstart()| |serverstop()|\n\t\tExample: >\n\t\t\t:echo serverlist()",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverstart",
   "description": "Opens a socket or named pipe at {address} and listens for\n\t\t|RPC| messages. Clients can send |API| commands to the address\n\t\tto control Nvim. Returns the address string.",
   "argsStr": "[{address}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "serverstop",
   "description": "Closes the pipe or socket at {address}.\n\t\tReturns TRUE if {address} is valid, else FALSE.\n\t\tIf |$NVIM_LISTEN_ADDRESS| is stopped it is unset.\n\t\tIf |v:servername| is stopped it is set to the next available\n\t\taddress returned by |serverlist()|.",
   "argsStr": "{address}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setbufline",
   "description": "Set line {lnum} to {text} in buffer {expr}.  To insert\n\t\tlines use |append()|.",
   "argsStr": "{expr}, {lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setbufvar",
   "description": "Set option or local variable {varname} in buffer {expr} to\n\t\t{val}.\n\t\tThis also works for a global or local window option, but it\n\t\tdoesn't work for a global or local window variable.\n\t\tFor a local window option the global value is unchanged.\n\t\tFor the use of {expr}, see |bufname()| above.\n\t\tNote that the variable name without \"b:\" must be used.\n\t\tExamples: >\n\t\t\t:call setbufvar(1, \"&mod\", 1)\n\t\t\t:call setbufvar(\"todo\", \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{expr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setcharsearch",
   "description": "Set the current character search information to {dict},\n\t\twhich contains one or more of the following entries:",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setcmdpos",
   "description": "Set the cursor position in the command line to byte position\n\t\t{pos}.  The first position is 1.\n\t\tUse |getcmdpos()| to obtain the current position.\n\t\tOnly works while editing the command line, thus you must use\n\t\t|c_CTRL-\\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For\n\t\t|c_CTRL-\\_e| and |c_CTRL-R_CTRL-R| with '=' the position is\n\t\tset after the command line is set to the expression.  For\n\t\t|c_CTRL-R_=| it is set after evaluating the expression but\n\t\tbefore inserting the resulting text.\n\t\tWhen the number is too big the cursor is put at the end of the\n\t\tline.  A number smaller than one has undefined results.\n\t\tReturns 0 when successful, 1 when not editing the command\n\t\tline.",
   "argsStr": "{pos}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setenv",
   "description": "Set environment variable {name} to {val}.\n\t\tWhen {val} is |v:null| the environment variable is deleted.\n\t\tSee also |expr-env|.",
   "argsStr": "{name}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setfperm",
   "description": "Set the file permissions for {fname} to {mode}.\n\t\t{mode} must be a string with 9 characters.  It is of the form\n\t\t\"rwxrwxrwx\", where each group of \"rwx\" flags represent, in\n\t\tturn, the permissions of the owner of the file, the group the\n\t\tfile belongs to, and other users.  A '-' character means the\n\t\tpermission is off, any other character means on.  Multi-byte\n\t\tcharacters are not supported.",
   "argsStr": "{fname}, {mode}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setline",
   "description": "Set line {lnum} of the current buffer to {text}.  To insert\n\t\tlines use |append()|. To set lines in another buffer use\n\t\t|setbufline()|.",
   "argsStr": "{lnum}, {text}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setloclist",
   "description": "Create or replace or add to the location list for window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero the current window is used.",
   "argsStr": "{nr}, {list}[, {action}[, {what}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setmatches",
   "description": "Restores a list of matches saved by |getmatches() for the\n\t\tcurrent window|.  Returns 0 if successful, otherwise -1.  All\n\t\tcurrent matches are cleared before the list is restored.  See\n\t\texample for |getmatches()|.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsStr": "{list} [, {win}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setpos",
   "description": "Set the position for {expr}.  Possible values:\n\t\t\t.\tthe cursor\n\t\t\t'x\tmark x",
   "argsStr": "{expr}, {list}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "setqflist",
   "description": "Create or replace or add to the quickfix list.",
   "argsStr": "{list} [, {action}[, {what}]]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E927",
   "description": "'a'\tThe items from {list} are added to the existing\n\t\t\tquickfix list. If there is no existing list, then a\n\t\t\tnew list is created.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "setreg",
   "description": "Set the register {regname} to {value}.\n\t\t{value} may be any value returned by |getreg()|, including\n\t\ta |List|.\n\t\tIf {options} contains \"a\" or {regname} is upper case,\n\t\tthen the value is appended.\n\t\t{options} can also contain a register type specification:\n\t\t    \"c\" or \"v\"\t      |charwise| mode\n\t\t    \"l\" or \"V\"\t      |linewise| mode\n\t\t    \"b\" or \"<CTRL-V>\" |blockwise-visual| mode\n\t\tIf a number immediately follows \"b\" or \"<CTRL-V>\" then this is\n\t\tused as the width of the selection - if it is not specified\n\t\tthen the width of the block is set to the number of characters\n\t\tin the longest line (counting a <Tab> as 1 character).\n\t\tIf {options} contains \"u\" or '\"', then the unnamed register is\n\t\tset to point to register {regname}.",
   "argsStr": "{regname}, {value} [, {options}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E883",
   "description": "Note: you may not use |List| containing more than one item to\n\t\t      set search and expression registers. Lists containing no\n\t\t      items act like empty strings.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "settabvar",
   "description": "Set tab-local variable {varname} to {val} in tab page {tabnr}.\n\t\t|t:var|\n\t\tNote that the variable name without \"t:\" must be used.\n\t\tTabs are numbered starting with one.\n\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{tabnr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "settabwinvar",
   "description": "Set option or local variable {varname} in window {winnr} to\n\t\t{val}.\n\t\tTabs are numbered starting with one.  For the current tabpage\n\t\tuse |setwinvar()|.\n\t\t{winnr} can be the window number or the |window-ID|.\n\t\tWhen {winnr} is zero the current window is used.\n\t\tThis also works for a global or local buffer option, but it\n\t\tdoesn't work for a global or local buffer variable.\n\t\tFor a local buffer option the global value is unchanged.\n\t\tNote that the variable name without \"w:\" must be used.\n\t\tExamples: >\n\t\t\t:call settabwinvar(1, 1, \"&list\", 0)\n\t\t\t:call settabwinvar(3, 2, \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.",
   "argsStr": "{tabnr}, {winnr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "settagstack",
   "description": "Modify the tag stack of the window {nr} using {dict}.\n\t\t{nr} can be the window number or the |window-ID|.",
   "argsStr": "{nr}, {dict} [, {action}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E962",
   "description": "How the tag stack is modified depends on the {action}\n\t\targument:\n\t\t- If {action} is not present or is set to 'r', then the tag\n\t\t  stack is replaced.\n\t\t- If {action} is set to 'a', then new entries from {dict} are\n\t\t  pushed (added) onto the tag stack.\n\t\t- If {action} is set to 't', then all the entries from the\n\t\t  current entry in the tag stack or \"curidx\" in {dict} are\n\t\t  removed and then new entries are pushed to the stack.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "setwinvar",
   "description": "Like |settabwinvar()| for the current tab page.\n\t\tExamples: >\n\t\t\t:call setwinvar(1, \"&list\", 0)\n\t\t\t:call setwinvar(2, \"myvar\", \"foobar\")",
   "argsStr": "{nr}, {varname}, {val}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sha256",
   "description": "Returns a String with 64 hex characters, which is the SHA256\n\t\tchecksum of {string}.",
   "argsStr": "{string}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "shellescape",
   "description": "Escape {string} for use as a shell command argument.",
   "argsStr": "{string} [, {special}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "shiftwidth",
   "description": "Returns the effective value of 'shiftwidth'. This is the\n\t\t'shiftwidth' value unless it is zero, in which case it is the\n\t\t'tabstop' value.  To be backwards compatible in indent\n\t\tplugins, use this: >\n\t\t\tif exists('*shiftwidth')\n\t\t\t  func s:sw()\n\t\t\t    return shiftwidth()\n\t\t\t  endfunc\n\t\t\telse\n\t\t\t  func s:sw()\n\t\t\t    return &sw\n\t\t\t  endfunc\n\t\t\tendif\n<\t\tAnd then use s:sw() instead of &sw.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_define",
   "description": "Define a new sign named {name} or modify the attributes of an\n\t\texisting sign.  This is similar to the |:sign-define| command.",
   "argsStr": "{name} [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_getdefined",
   "description": "Get a list of defined signs and their attributes.\n\t\tThis is similar to the |:sign-list| command.",
   "argsStr": "[{name}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_getplaced",
   "description": "Return a list of signs placed in a buffer or all the buffers.\n\t\tThis is similar to the |:sign-place-list| command.",
   "argsStr": "[{expr} [, {dict}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_jump",
   "description": "Open the buffer {expr} or jump to the window that contains\n\t\t{expr} and position the cursor at sign {id} in group {group}.\n\t\tThis is similar to the |:sign-jump| command.",
   "argsStr": "{id}, {group}, {expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_place",
   "description": "Place the sign defined as {name} at line {lnum} in file {expr}\n\t\tand assign {id} and {group} to sign.  This is similar to the\n\t\t|:sign-place| command.",
   "argsStr": "{id}, {group}, {name}, {expr} [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_undefine",
   "description": "Deletes a previously defined sign {name}. This is similar to\n\t\tthe |:sign-undefine| command. If {name} is not supplied, then\n\t\tdeletes all the defined signs.",
   "argsStr": "[{name}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sign_unplace",
   "description": "Remove a previously placed sign in one or more buffers.  This\n\t\tis similar to the |:sign-unplace| command.",
   "argsStr": "{group} [, {dict}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "simplify",
   "description": "Simplify the file name as much as possible without changing\n\t\tthe meaning.  Shortcuts (on MS-Windows) or symbolic links (on\n\t\tUnix) are not resolved.  If the first path component in\n\t\t{filename} designates the current directory, this will be\n\t\tvalid for the result as well.  A trailing path separator is\n\t\tnot removed either.\n\t\tExample: >\n\t\t\tsimplify(\"./dir/.././/file/\") == \"./file/\"\n<\t\tNote: The combination \"dir/..\" is only removed if \"dir\" is\n\t\ta searchable directory or does not exist.  On Unix, it is also\n\t\tremoved when \"dir\" is a symbolic link within the same\n\t\tdirectory.  In order to resolve all the involved symbolic\n\t\tlinks before simplifying the path name, use |resolve()|.",
   "argsStr": "{filename}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sin",
   "description": "Return the sine of {expr}, measured in radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo sin(100)\n<\t\t\t-0.506366 >\n\t\t\t:echo sin(-4.01)\n<\t\t\t0.763301",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sinh",
   "description": "Return the hyperbolic sine of {expr} as a |Float| in the range\n\t\t[-inf, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo sinh(0.5)\n<\t\t\t0.521095 >\n\t\t\t:echo sinh(-0.9)\n<\t\t\t-1.026517",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sockconnect",
   "description": "Connect a socket to an address. If {mode} is \"pipe\" then\n\t\t{address} should be the path of a named pipe. If {mode} is\n\t\t\"tcp\" then {address} should be of the form \"host:port\" where\n\t\tthe host should be an ip adderess or host name, and port the\n\t\tport number.",
   "argsStr": "{mode}, {address}, {opts}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sort",
   "description": "Sort the items in {list} in-place.  Returns {list}.",
   "argsStr": "{list} [, {func} [, {dict}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "soundfold",
   "description": "Return the sound-folded equivalent of {word}.  Uses the first\n\t\tlanguage in 'spelllang' for the current window that supports\n\t\tsoundfolding.  'spell' must be set.  When no sound folding is\n\t\tpossible the {word} is returned unmodified.\n\t\tThis can be used for making spelling suggestions.  Note that\n\t\tthe method can be quite slow.",
   "argsStr": "{word}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "spellbadword",
   "description": "Without argument: The result is the badly spelled word under\n\t\tor after the cursor.  The cursor is moved to the start of the\n\t\tbad word.  When no bad word is found in the cursor line the\n\t\tresult is an empty string and the cursor doesn't move.",
   "argsStr": "[{sentence}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "spellsuggest",
   "description": "Return a |List| with spelling suggestions to replace {word}.\n\t\tWhen {max} is given up to this number of suggestions are\n\t\treturned.  Otherwise up to 25 suggestions are returned.",
   "argsStr": "{word} [, {max} [, {capital}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "split",
   "description": "Make a |List| out of {expr}.  When {pattern} is omitted or\n\t\tempty each white-separated sequence of characters becomes an\n\t\titem.\n\t\tOtherwise the string is split where {pattern} matches,\n\t\tremoving the matched characters. 'ignorecase' is not used\n\t\there, add \\c to ignore case. |/\\c|\n\t\tWhen the first or last item is empty it is omitted, unless the\n\t\t{keepempty} argument is given and it's non-zero.\n\t\tOther empty items are kept when {pattern} matches at least one\n\t\tcharacter or when {keepempty} is non-zero.\n\t\tExample: >\n\t\t\t:let words = split(getline('.'), '\\W\\+')\n<\t\tTo split a string in individual characters: >\n\t\t\t:for c in split(mystring, '\\zs')\n<\t\tIf you want to keep the separator you can also use '\\zs' at\n\t\tthe end of the pattern: >\n\t\t\t:echo split('abc:def:ghi', ':\\zs')\n<\t\t\t['abc:', 'def:', 'ghi'] ~\n\t\tSplitting a table where the first element can be empty: >\n\t\t\t:let items = split(line, ':', 1)\n<\t\tThe opposite function is |join()|.",
   "argsStr": "{expr} [, {pattern} [, {keepempty}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "sqrt",
   "description": "Return the non-negative square root of Float {expr} as a\n\t\t|Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.  When {expr}\n\t\tis negative the result is NaN (Not a Number).\n\t\tExamples: >\n\t\t\t:echo sqrt(100)\n<\t\t\t10.0 >\n\t\t\t:echo sqrt(-4.01)\n<\t\t\tnan\n\t\t\"nan\" may be different, it depends on system libraries.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stdioopen",
   "description": "With |--headless| this opens stdin and stdout as a |channel|.\n\t\tMay be called only once. See |channel-stdio|. stderr is not\n\t\thandled by this function, see |v:stderr|.",
   "argsStr": "{opts}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stdpath",
   "description": "Returns |standard-path| locations of various default files and\n\t\tdirectories.",
   "argsStr": "{what}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2float",
   "description": "Convert String {expr} to a Float.  This mostly works the same\n\t\tas when using a floating point number in an expression, see\n\t\t|floating-point-format|.  But it's a bit more permissive.\n\t\tE.g., \"1e40\" is accepted, while in an expression you need to\n\t\twrite \"1.0e40\".  The hexadecimal form \"0x123\" is also\n\t\taccepted, but not others, like binary or octal.\n\t\tText after the number is silently ignored.\n\t\tThe decimal point is always '.', no matter what the locale is\n\t\tset to.  A comma ends the number: \"12,345.67\" is converted to\n\t\t12.0.  You can strip out thousands separators with\n\t\t|substitute()|: >\n\t\t\tlet f = str2float(substitute(text, ',', '', 'g'))",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2list",
   "description": "Return a list containing the number values which represent\n\t\teach character in String {expr}.  Examples: >\n\t\t\tstr2list(\" \")\t\treturns [32]\n\t\t\tstr2list(\"ABC\")\t\treturns [65, 66, 67]\n<\t\t|list2str()| does the opposite.",
   "argsStr": "{expr} [, {utf8}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "str2nr",
   "description": "Convert string {expr} to a number.\n\t\t{base} is the conversion base, it can be 2, 8, 10 or 16.\n\t\tWhen {base} is omitted base 10 is used.  This also means that\n\t\ta leading zero doesn't cause octal conversion to be used, as\n\t\twith the default String to Number conversion.\n\t\tWhen {base} is 16 a leading \"0x\" or \"0X\" is ignored.  With a\n\t\tdifferent base the result will be zero. Similarly, when {base}\n\t\tis 8 a leading \"0\" is ignored, and when {base} is 2 a leading\n\t\t\"0b\" or \"0B\" is ignored.\n\t\tText after the number is silently ignored.",
   "argsStr": "{expr} [, {base}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strchars",
   "description": "The result is a Number, which is the number of characters\n\t\tin String {expr}.\n\t\tWhen {skipcc} is omitted or zero, composing characters are\n\t\tcounted separately.\n\t\tWhen {skipcc} set to 1, Composing characters are ignored.\n\t\tAlso see |strlen()|, |strdisplaywidth()| and |strwidth()|.",
   "argsStr": "{expr} [, {skipcc}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strcharpart",
   "description": "Like |strpart()| but using character index and length instead\n\t\tof byte index and length.\n\t\tWhen a character index is used where a character does not\n\t\texist it is assumed to be one character.  For example: >\n\t\t\tstrcharpart('abc', -1, 2)\n<\t\tresults in 'a'.",
   "argsStr": "{src}, {start} [, {len}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strdisplaywidth",
   "description": "The result is a Number, which is the number of display cells\n\t\tString {expr} occupies on the screen when it starts at {col}\n\t\t(first column is zero).  When {col} is omitted zero is used.\n\t\tOtherwise it is the screen column where to start.  This\n\t\tmatters for Tab characters.\n\t\tThe option settings of the current window are used.  This\n\t\tmatters for anything that's displayed differently, such as\n\t\t'tabstop' and 'display'.\n\t\tWhen {expr} contains characters with East Asian Width Class\n\t\tAmbiguous, this function's return value depends on 'ambiwidth'.\n\t\tAlso see |strlen()|, |strwidth()| and |strchars()|.",
   "argsStr": "{expr} [, {col}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strftime",
   "description": "The result is a String, which is a formatted date and time, as\n\t\tspecified by the {format} string.  The given {time} is used,\n\t\tor the current time if no time is given.  The accepted\n\t\t{format} depends on your system, thus this is not portable!\n\t\tSee the manual page of the C function strftime() for the\n\t\tformat.  The maximum length of the result is 80 characters.\n\t\tSee also |localtime()| and |getftime()|.\n\t\tThe language can be changed with the |:language| command.\n\t\tExamples: >\n\t\t  :echo strftime(\"%c\")\t\t   Sun Apr 27 11:49:23 1997\n\t\t  :echo strftime(\"%Y %b %d %X\")\t   1997 Apr 27 11:53:25\n\t\t  :echo strftime(\"%y%m%d %T\")\t   970427 11:53:55\n\t\t  :echo strftime(\"%H:%M\")\t   11:55\n\t\t  :echo strftime(\"%c\", getftime(\"file.c\"))\n\t\t\t\t\t\t   Show mod time of file.c.",
   "argsStr": "{format} [, {time}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strgetchar",
   "description": "Get character {index} from {str}.  This uses a character\n\t\tindex, not a byte index.  Composing characters are considered\n\t\tseparate characters here.\n\t\tAlso see |strcharpart()| and |strchars()|.",
   "argsStr": "{str}, {index}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "stridx",
   "description": "The result is a Number, which gives the byte index in\n\t\t{haystack} of the first occurrence of the String {needle}.\n\t\tIf {start} is specified, the search starts at index {start}.\n\t\tThis can be used to find a second match: >\n\t\t\t:let colon1 = stridx(line, \":\")\n\t\t\t:let colon2 = stridx(line, \":\", colon1 + 1)\n<\t\tThe search is done case-sensitive.\n\t\tFor pattern searches use |match()|.\n\t\t-1 is returned if the {needle} does not occur in {haystack}.\n\t\tSee also |strridx()|.\n\t\tExamples: >\n\t\t  :echo stridx(\"An Example\", \"Example\")\t     3\n\t\t  :echo stridx(\"Starting point\", \"Start\")    0\n\t\t  :echo stridx(\"Starting point\", \"start\")   -1",
   "argsStr": "{haystack}, {needle} [, {start}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strstr()* *strchr",
   "description": "stridx() works similar to the C function strstr().  When used\n\t\twith a single character it works similar to strchr().",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "string",
   "description": "Return {expr} converted to a String.  If {expr} is a Number,\n\t\tFloat, String or a composition of them, then the result can be\n\t\tparsed back with |eval()|.\n\t\t\t{expr} type\tresult ~\n\t\t\tString\t\t'string'\n\t\t\tNumber\t\t123\n\t\t\tFloat\t\t123.123456 or 1.123456e8 or\n\t\t\t\t\t`str2float('inf')`\n\t\t\tFuncref\t\t`function('name')`\n\t\t\tList\t\t[item, item]\n\t\t\tDictionary\t{key: value, key: value}\n\t\tNote that in String values the ' character is doubled.\n\t\tAlso see |strtrans()|.\n\t\tNote 2: Output format is mostly compatible with YAML, except\n\t\tfor infinite and NaN floating-point values representations\n\t\twhich use |str2float()|.  Strings are also dumped literally,\n\t\tonly single quote is escaped, which does not allow using YAML\n\t\tfor parsing back binary strings.  |eval()| should always work for\n\t\tstrings and floats though and this is the only official\n\t\tmethod, use |msgpackdump()| or |json_encode()| if you need to\n\t\tshare data with other application.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strlen",
   "description": "The result is a Number, which is the length of the String\n\t\t{expr} in bytes.\n\t\tIf the argument is a Number it is first converted to a String.\n\t\tFor other types an error is given.\n\t\tIf you want to count the number of multibyte characters use\n\t\t|strchars()|.\n\t\tAlso see |len()|, |strdisplaywidth()| and |strwidth()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strpart",
   "description": "The result is a String, which is part of {src}, starting from\n\t\tbyte {start}, with the byte length {len}.\n\t\tWhen {chars} is present and TRUE then {len} is the number of\n\t\tcharacters positions (composing characters are not counted\n\t\tseparately, thus \"1\" means one base character and any\n\t\tfollowing composing characters).\n\t\tTo count {start} as characters instead of bytes use\n\t\t|strcharpart()|.",
   "argsStr": "{src}, {start} [, {len} [, {chars}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strridx",
   "description": "The result is a Number, which gives the byte index in\n\t\t{haystack} of the last occurrence of the String {needle}.\n\t\tWhen {start} is specified, matches beyond this index are\n\t\tignored.  This can be used to find a match before a previous\n\t\tmatch: >\n\t\t\t:let lastcomma = strridx(line, \",\")\n\t\t\t:let comma2 = strridx(line, \",\", lastcomma - 1)\n<\t\tThe search is done case-sensitive.\n\t\tFor pattern searches use |match()|.\n\t\t-1 is returned if the {needle} does not occur in {haystack}.\n\t\tIf the {needle} is empty the length of {haystack} is returned.\n\t\tSee also |stridx()|.  Examples: >\n\t\t  :echo strridx(\"an angry armadillo\", \"an\")\t     3",
   "argsStr": "{haystack}, {needle} [, {start}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strrchr",
   "description": "When used with a single character it works similar to the C\n\t\tfunction strrchr().",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strtrans",
   "description": "The result is a String, which is {expr} with all unprintable\n\t\tcharacters translated into printable characters |'isprint'|.\n\t\tLike they are shown in a window.  Example: >\n\t\t\techo strtrans(@a)\n<\t\tThis displays a newline in register a as \"^@\" instead of\n\t\tstarting a new line.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "strwidth",
   "description": "The result is a Number, which is the number of display cells\n\t\tString {expr} occupies.  A Tab character is counted as one\n\t\tcell, alternatively use |strdisplaywidth()|.\n\t\tWhen {expr} contains characters with East Asian Width Class\n\t\tAmbiguous, this function's return value depends on 'ambiwidth'.\n\t\tAlso see |strlen()|, |strdisplaywidth()| and |strchars()|.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "submatch",
   "description": "Only for an expression in a |:substitute| command or\n\t\tsubstitute() function.\n\t\tReturns the {nr}'th submatch of the matched text.  When {nr}\n\t\tis 0 the whole matched text is returned.\n\t\tNote that a NL in the string can stand for a line break of a\n\t\tmulti-line match or a NUL character in the text.\n\t\tAlso see |sub-replace-expression|.",
   "argsStr": "{nr} [, {list}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "substitute",
   "description": "The result is a String, which is a copy of {expr}, in which\n\t\tthe first match of {pat} is replaced with {sub}.\n\t\tWhen {flags} is \"g\", all matches of {pat} in {expr} are\n\t\treplaced.  Otherwise {flags} should be \"\".",
   "argsStr": "{expr}, {pat}, {sub}, {flags}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "swapinfo",
   "description": "The result is a dictionary, which holds information about the\n\t\tswapfile {fname}. The available fields are:\n\t\t\tversion VIM version\n\t\t\tuser\tuser name\n\t\t\thost\thost name\n\t\t\tfname\toriginal file name\n\t\t\tpid\tPID of the VIM process that created the swap\n\t\t\t\tfile\n\t\t\tmtime\tlast modification time in seconds\n\t\t\tinode\tOptional: INODE number of the file\n\t\t\tdirty\t1 if file was modified, 0 if not\n\t\tIn case of failure an \"error\" item is added with the reason:\n\t\t\tCannot open file: file not found or in accessible\n\t\t\tCannot read file: cannot read first block\n\t\t\tNot a swap file: does not contain correct block ID\n\t\t\tMagic number mismatch: Info in first block is invalid",
   "argsStr": "{fname}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "swapname",
   "description": "The result is the swap file path of the buffer {expr}.\n\t\tFor the use of {expr}, see |bufname()| above.\n\t\tIf buffer {expr} is the current buffer, the result is equal to\n\t\t|:swapname| (unless no swap file).\n\t\tIf buffer {expr} has no swap file, returns an empty string.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synID",
   "description": "The result is a Number, which is the syntax ID at the position\n\t\t{lnum} and {col} in the current window.\n\t\tThe syntax ID can be used with |synIDattr()| and\n\t\t|synIDtrans()| to obtain syntax information about text.",
   "argsStr": "{lnum}, {col}, {trans}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synIDattr",
   "description": "The result is a String, which is the {what} attribute of\n\t\tsyntax ID {synID}.  This can be used to obtain information\n\t\tabout a syntax item.\n\t\t{mode} can be \"gui\", \"cterm\" or \"term\", to get the attributes\n\t\tfor that mode.  When {mode} is omitted, or an invalid value is\n\t\tused, the attributes for the currently active highlighting are\n\t\tused (GUI, cterm or term).\n\t\tUse synIDtrans() to follow linked highlight groups.\n\t\t{what}\t\tresult\n\t\t\"name\"\t\tthe name of the syntax item\n\t\t\"fg\"\t\tforeground color (GUI: color name used to set\n\t\t\t\tthe color, cterm: color number as a string,\n\t\t\t\tterm: empty string)\n\t\t\"bg\"\t\tbackground color (as with \"fg\")\n\t\t\"font\"\t\tfont name (only available in the GUI)\n\t\t\t\t|highlight-font|\n\t\t\"sp\"\t\tspecial color (as with \"fg\") |highlight-guisp|\n\t\t\"fg#\"\t\tlike \"fg\", but for the GUI and the GUI is\n\t\t\t\trunning the name in \"#RRGGBB\" form\n\t\t\"bg#\"\t\tlike \"fg#\" for \"bg\"\n\t\t\"sp#\"\t\tlike \"fg#\" for \"sp\"\n\t\t\"bold\"\t\t\"1\" if bold\n\t\t\"italic\"\t\"1\" if italic\n\t\t\"reverse\"\t\"1\" if reverse\n\t\t\"inverse\"\t\"1\" if inverse (= reverse)\n\t\t\"standout\"\t\"1\" if standout\n\t\t\"underline\"\t\"1\" if underlined\n\t\t\"undercurl\"\t\"1\" if undercurled\n\t\t\"strikethrough\"\t\"1\" if struckthrough",
   "argsStr": "{synID}, {what} [, {mode}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synIDtrans",
   "description": "The result is a Number, which is the translated syntax ID of\n\t\t{synID}.  This is the syntax group ID of what is being used to\n\t\thighlight the character.  Highlight links given with\n\t\t\":highlight link\" are followed.",
   "argsStr": "{synID}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synconcealed",
   "description": "The result is a List with currently three items:\n\t\t1. The first item in the list is 0 if the character at the\n\t\t   position {lnum} and {col} is not part of a concealable\n\t\t   region, 1 if it is.\n\t\t2. The second item in the list is a string. If the first item\n\t\t   is 1, the second item contains the text which will be\n\t\t   displayed in place of the concealed text, depending on the\n\t\t   current setting of 'conceallevel' and 'listchars'.\n\t\t3. The third and final item in the list is a number\n\t\t   representing the specific syntax region matched in the\n\t\t   line. When the character is not concealed the value is\n\t\t   zero. This allows detection of the beginning of a new\n\t\t   concealable region if there are two consecutive regions\n\t\t   with the same replacement character.  For an example, if\n\t\t   the text is \"123456\" and both \"23\" and \"45\" are concealed\n\t\t   and replaced by the character \"X\", then:\n\t\t\tcall\t\t\treturns ~\n\t\t   \tsynconcealed(lnum, 1)   [0, '', 0]\n\t\t   \tsynconcealed(lnum, 2)   [1, 'X', 1]\n\t\t   \tsynconcealed(lnum, 3)   [1, 'X', 1]\n\t\t   \tsynconcealed(lnum, 4)   [1, 'X', 2]\n\t\t   \tsynconcealed(lnum, 5)   [1, 'X', 2]\n\t\t   \tsynconcealed(lnum, 6)   [0, '', 0]",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "synstack",
   "description": "Return a |List|, which is the stack of syntax items at the\n\t\tposition {lnum} and {col} in the current window.  Each item in\n\t\tthe List is an ID like what |synID()| returns.\n\t\tThe first item in the List is the outer region, following are\n\t\titems contained in that one.  The last one is what |synID()|\n\t\treturns, unless not the whole item is highlighted or it is a\n\t\ttransparent item.\n\t\tThis function is useful for debugging a syntax file.\n\t\tExample that shows the syntax stack under the cursor: >\n\t\t\tfor id in synstack(line(\".\"), col(\".\"))\n\t\t\t   echo synIDattr(id, \"name\")\n\t\t\tendfor\n<\t\tWhen the position specified with {lnum} and {col} is invalid\n\t\tnothing is returned.  The position just after the last\n\t\tcharacter in a line and the first column in an empty line are\n\t\tvalid positions.",
   "argsStr": "{lnum}, {col}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "system",
   "description": "Get the output of {cmd} as a |string| (use |systemlist()| to\n\t\tget a |List|). {cmd} is treated exactly as in |jobstart()|.\n\t\tNot to be used for interactive commands.",
   "argsStr": "{cmd} [, {input}]",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "E5677",
   "description": "Note: system() cannot write to or read from backgrounded (\"&\")\n\t\tshell commands, e.g.: >\n\t\t    :echo system(\"cat - &\", \"foo\"))\n<\t\twhich is equivalent to: >\n\t\t    $ echo foo | bash -c 'cat - &'\n<\t\tThe pipes are disconnected (unless overridden by shell\n\t\tredirection syntax) before input can reach it. Use\n\t\t|jobstart()| instead.",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "systemlist",
   "description": "Same as |system()|, but returns a |List| with lines (parts of\n\t\toutput separated by NL) with NULs transformed into NLs. Output\n\t\tis the same as |readfile()| will output with {binary} argument\n\t\tset to \"b\", except that a final newline is not preserved,\n\t\tunless {keepempty} is non-zero.\n\t\tNote that on MS-Windows you may get trailing CR characters.",
   "argsStr": "{cmd} [, {input} [, {keepempty}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagebuflist",
   "description": "The result is a |List|, where each item is the number of the\n\t\tbuffer associated with each window in the current tab page.\n\t\t{arg} specifies the number of the tab page to be used. When\n\t\tomitted the current tab page is used.\n\t\tWhen {arg} is invalid the number zero is returned.\n\t\tTo get a list of all buffers in all tabs use this: >\n\t\t\tlet buflist = []\n\t\t\tfor i in range(tabpagenr('$'))\n\t\t\t   call extend(buflist, tabpagebuflist(i + 1))\n\t\t\tendfor\n<\t\tNote that a buffer may appear in more than one window.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagenr",
   "description": "The result is a Number, which is the number of the current\n\t\ttab page.  The first tab page has number 1.\n\t\tThe optional argument {arg} supports the following values:\n\t\t\t$\tthe number of the last tab page (the tab page\n\t\t\t\tcount).\n\t\t\t#\tthe number of the last accessed tab page (where\n\t\t\t\t|g<Tab>| goes to).  If there is no previous\n\t\t\t\ttab page, 0 is returned.\n\t\tThe number can be used with the |:tab| command.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tabpagewinnr",
   "description": "Like |winnr()| but for tab page {tabarg}.\n\t\t{tabarg} specifies the number of tab page to be used.\n\t\t{arg} is used like with |winnr()|:\n\t\t- When omitted the current window number is returned.  This is\n\t\t  the window which will be used when going to this tab page.\n\t\t- When \"$\" the number of windows is returned.\n\t\t- When \"#\" the previous window nr is returned.\n\t\tUseful examples: >\n\t\t    tabpagewinnr(1)\t    \" current window of tab page 1\n\t\t    tabpagewinnr(4, '$')    \" number of windows in tab page 4\n<\t\tWhen {tabarg} is invalid zero is returned.",
   "argsStr": "{tabarg} [, {arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tagfiles",
   "description": "Returns a |List| with the file names used to search for tags\n\t\tfor the current buffer.  This is the 'tags' option expanded.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "taglist",
   "description": "Returns a list of tags matching the regular expression {expr}.",
   "argsStr": "{expr} [, {filename}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tempname",
   "description": "The result is a String, which is the name of a file that\n\t\tdoesn't exist.  It can be used for a temporary file.  Example: >\n\t\t\t:let tmpfile = tempname()\n\t\t\t:exe \"redir > \" . tmpfile\n<\t\tFor Unix, the file will be in a private directory |tempfile|.\n\t\tFor MS-Windows forward slashes are used when the 'shellslash'\n\t\toption is set or when 'shellcmdflag' starts with '-'.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "termopen",
   "description": "Spawns {cmd} in a new pseudo-terminal session connected\n\t\tto the current buffer.  {cmd} is the same as the one passed to\n\t\t|jobstart()|.  This function fails if the current buffer is\n\t\tmodified (all buffer contents are destroyed).",
   "argsStr": "{cmd}[, {opts}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "test_garbagecollect_now",
   "description": "Like |garbagecollect()|, but executed right away.  This must\n\t\tonly be called directly to avoid any structure to exist\n\t\tinternally, and |v:testing| must have been set before calling\n\t\tany function.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tan",
   "description": "Return the tangent of {expr}, measured in radians, as a |Float|\n\t\tin the range [-inf, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo tan(10)\n<\t\t\t0.648361 >\n\t\t\t:echo tan(-4.01)\n<\t\t\t-1.181502",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tanh",
   "description": "Return the hyperbolic tangent of {expr} as a |Float| in the\n\t\trange [-1, 1].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo tanh(0.5)\n<\t\t\t0.462117 >\n\t\t\t:echo tanh(-1)\n<\t\t\t-0.761594",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_info",
   "description": "Return a list with information about timers.\n\t\tWhen {id} is given only information about this timer is\n\t\treturned.  When timer {id} does not exist an empty list is\n\t\treturned.\n\t\tWhen {id} is omitted information about all timers is returned.",
   "argsStr": "[{id}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_pause",
   "description": "Pause or unpause a timer.  A paused timer does not invoke its\n\t\tcallback when its time expires.  Unpausing a timer may cause\n\t\tthe callback to be invoked almost immediately if enough time\n\t\thas passed.",
   "argsStr": "{timer}, {paused}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_start",
   "description": "Create a timer and return the timer ID.",
   "argsStr": "{time}, {callback} [, {options}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_stop",
   "description": "Stop a timer.  The timer callback will no longer be invoked.\n\t\t{timer} is an ID returned by timer_start(), thus it must be a\n\t\tNumber.  If {timer} does not exist there is no error.",
   "argsStr": "{timer}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "timer_stopall",
   "description": "Stop all timers.  The timer callbacks will no longer be\n\t\tinvoked.  Useful if some timers is misbehaving.  If there are\n\t\tno timers there is no error.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tolower",
   "description": "The result is a copy of the String given, with all uppercase\n\t\tcharacters turned into lowercase (just like applying |gu| to\n\t\tthe string).",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "toupper",
   "description": "The result is a copy of the String given, with all lowercase\n\t\tcharacters turned into uppercase (just like applying |gU| to\n\t\tthe string).",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "tr",
   "description": "The result is a copy of the {src} string with all characters\n\t\twhich appear in {fromstr} replaced by the character in that\n\t\tposition in the {tostr} string.  Thus the first character in\n\t\t{fromstr} is translated into the first character in {tostr}\n\t\tand so on.  Exactly like the unix \"tr\" command.\n\t\tThis code also deals with multibyte characters properly.",
   "argsStr": "{src}, {fromstr}, {tostr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "trim",
   "description": "Return {text} as a String where any character in {mask} is\n\t\tremoved from the beginning and/or end of {text}.\n\t\tIf {mask} is not given, {mask} is all characters up to 0x20,\n\t\twhich includes Tab, space, NL and CR, plus the non-breaking\n\t\tspace character 0xa0.\n\t\tThe optional {dir} argument specifies where to remove the\n\t\tcharacters:\n\t\t\t0\tremove from the beginning and end of {text}\n\t\t\t1\tremove only at the beginning of {text}\n\t\t\t2\tremove only at the end of {text}\n\t\tWhen omitted both ends are trimmed.\n\t\tThis function deals with multibyte characters properly.\n\t\tExamples: >\n\t\t\techo trim(\"   some text \")\n<\t\treturns \"some text\" >\n\t\t\techo trim(\"  \\r\\t\\t\\r RESERVE \\t\\n\\x0B\\xA0\") . \"_TAIL\"\n<\t\treturns \"RESERVE_TAIL\" >\n\t\t\techo trim(\"rm<Xrm<>X>rrm\", \"rm<>\")\n<\t\treturns \"Xrm<>X\" (characters in the middle are not removed) >\n\t\t\techo trim(\"  vim  \", \" \", 2)\n<\t\treturns \"  vim\"",
   "argsStr": "{text} [, {mask} [, {dir}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "trunc",
   "description": "Return the largest integral value with magnitude less than or\n\t\tequal to {expr} as a |Float| (truncate towards zero).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo trunc(1.456)\n<\t\t\t1.0  >\n\t\t\techo trunc(-5.456)\n<\t\t\t-5.0  >\n\t\t\techo trunc(4.0)\n<\t\t\t4.0",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "type",
   "description": "The result is a Number representing the type of {expr}.\n\t\tInstead of using the number directly, it is better to use the\n\t\tv:t_ variable that has the value:\n\t\t        Number:     0 (|v:t_number|)\n\t\t\tString:     1 (|v:t_string|)\n\t\t\tFuncref:    2 (|v:t_func|)\n\t\t\tList:       3 (|v:t_list|)\n\t\t\tDictionary: 4 (|v:t_dict|)\n\t\t\tFloat:      5 (|v:t_float|)\n\t\t\tBoolean:    6 (|v:true| and |v:false|)\n\t\t\tNull:       7 (|v:null|)\n\t\tFor backward compatibility, this method can be used: >\n\t\t\t:if type(myvar) == type(0)\n\t\t\t:if type(myvar) == type(\"\")\n\t\t\t:if type(myvar) == type(function(\"tr\"))\n\t\t\t:if type(myvar) == type([])\n\t\t\t:if type(myvar) == type({})\n\t\t\t:if type(myvar) == type(0.0)\n\t\t\t:if type(myvar) == type(v:true)\n<\t\tIn place of checking for |v:null| type it is better to check\n\t\tfor |v:null| directly as it is the only value of this type: >\n\t\t\t:if myvar is v:null\n<               To check if the v:t_ variables exist use this: >\n                        :if exists('v:t_number')",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "undofile",
   "description": "Return the name of the undo file that would be used for a file\n\t\twith name {name} when writing.  This uses the 'undodir'\n\t\toption, finding directories that exist.  It does not check if\n\t\tthe undo file exists.\n\t\t{name} is always expanded to the full path, since that is what\n\t\tis used internally.\n\t\tIf {name} is empty undofile() returns an empty string, since a\n\t\tbuffer without a file name will not write an undo file.\n\t\tUseful in combination with |:wundo| and |:rundo|.\n\t\tWhen compiled without the |+persistent_undo| option this always\n\t\treturns an empty string.",
   "argsStr": "{name}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "undotree",
   "description": "Return the current state of the undo tree in a dictionary with\n\t\tthe following items:\n\t\t  \"seq_last\"\tThe highest undo sequence number used.\n\t\t  \"seq_cur\"\tThe sequence number of the current position in\n\t\t\t\tthe undo tree.  This differs from \"seq_last\"\n\t\t\t\twhen some changes were undone.\n\t\t  \"time_cur\"\tTime last used for |:earlier| and related\n\t\t\t\tcommands.  Use |strftime()| to convert to\n\t\t\t\tsomething readable.\n\t\t  \"save_last\"\tNumber of the last file write.  Zero when no\n\t\t\t\twrite yet.\n\t\t  \"save_cur\"\tNumber of the current position in the undo\n\t\t\t\ttree.\n\t\t  \"synced\"\tNon-zero when the last undo block was synced.\n\t\t\t\tThis happens when waiting from input from the\n\t\t\t\tuser.  See |undo-blocks|.\n\t\t  \"entries\"\tA list of dictionaries with information about\n\t\t\t\tundo blocks.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "uniq",
   "description": "Remove second and succeeding copies of repeated adjacent\n\t\t{list} items in-place.  Returns {list}.  If you want a list\n\t\tto remain unmodified make a copy first: >\n\t\t\t:let newlist = uniq(copy(mylist))\n<\t\tThe default compare function uses the string representation of\n\t\teach item.  For the use of {func} and {dict} see |sort()|.",
   "argsStr": "{list} [, {func} [, {dict}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "values",
   "description": "Return a |List| with all the values of {dict}.  The |List| is\n\t\tin arbitrary order.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "virtcol",
   "description": "The result is a Number, which is the screen column of the file\n\t\tposition given with {expr}.  That is, the last screen position\n\t\toccupied by the character at that position, when the screen\n\t\twould be of unlimited width.  When there is a <Tab> at the\n\t\tposition, the returned Number will be the column at the end of\n\t\tthe <Tab>.  For example, for a <Tab> in column 1, with 'ts'\n\t\tset to 8, it returns 8. |conceal| is ignored.\n\t\tFor the byte position use |col()|.\n\t\tFor the use of {expr} see |col()|.\n\t\tWhen 'virtualedit' is used {expr} can be [lnum, col, off], where\n\t\t\"off\" is the offset in screen columns from the start of the\n\t\tcharacter.  E.g., a position within a <Tab> or after the last\n\t\tcharacter.  When \"off\" is omitted zero is used.\n\t\tWhen Virtual editing is active in the current mode, a position\n\t\tbeyond the end of the line can be returned. |'virtualedit'|\n\t\tThe accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the end of the cursor line (the result is the\n\t\t\t    number of displayed characters in the cursor line\n\t\t\t    plus one)\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    v       In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tNote that only marks in the current file can be used.\n\t\tExamples: >\n  virtcol(\".\")\t   with text \"foo^Lbar\", with cursor on the \"^L\", returns 5\n  virtcol(\"$\")\t   with text \"foo^Lbar\", returns 9\n  virtcol(\"'t\")    with text \"\t  there\", with 't at 'h', returns 6\n<\t\tThe first column is 1.  0 is returned for an error.\n\t\tA more advanced example that echoes the maximum length of\n\t\tall lines: >\n\t\t    echo max(map(range(1, line('$')), \"virtcol([v:val, '$'])\"))",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "visualmode",
   "description": "The result is a String, which describes the last Visual mode\n\t\tused in the current buffer.  Initially it returns an empty\n\t\tstring, but once Visual mode has been used, it returns \"v\",\n\t\t\"V\", or \"<CTRL-V>\" (a single CTRL-V character) for\n\t\tcharacter-wise, line-wise, or block-wise Visual mode\n\t\trespectively.\n\t\tExample: >\n\t\t\t:exe \"normal \" . visualmode()\n<\t\tThis enters the same Visual mode as before.  It is also useful\n\t\tin scripts if you wish to act differently depending on the\n\t\tVisual mode that was used.\n\t\tIf Visual mode is active, use |mode()| to get the Visual mode\n\t\t(e.g., in a |:vmap|).\n\t\tIf [expr] is supplied and it evaluates to a non-zero Number or\n\t\ta non-empty String, then the Visual mode will be cleared and\n\t\tthe old value is returned.  See |non-zero-arg|.",
   "argsStr": "[expr]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wait",
   "description": "Waits until {condition} evaluates to |TRUE|, where {condition}\n\t\tis a |Funcref| or |string| containing an expression.",
   "argsStr": "{timeout}, {condition}[, {interval}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wildmenumode",
   "description": "Returns |TRUE| when the wildmenu is active and |FALSE|\n\t\totherwise.  See 'wildmenu' and 'wildmode'.\n\t\tThis can be used in mappings to handle the 'wildcharm' option\n\t\tgracefully. (Makes only sense with |mapmode-c| mappings).",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_findbuf",
   "description": "Returns a list with |window-ID|s for windows that contain\n\t\tbuffer {bufnr}.  When there is none the list is empty.",
   "argsStr": "{bufnr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_getid",
   "description": "Get the |window-ID| for the specified window.\n\t\tWhen {win} is missing use the current window.\n\t\tWith {win} this is the window number.  The top window has\n\t\tnumber 1.\n\t\tWithout {tab} use the current tab, otherwise the tab with\n\t\tnumber {tab}.  The first tab has number one.\n\t\tReturn zero if the window cannot be found.",
   "argsStr": "[{win} [, {tab}]]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_gettype",
   "description": "Return the type of the window:\n\t\t\t\"autocmd\"\tautocommand window. Temporary window\n\t\t\t\t\tused to execute autocommands.\n\t\t\t\"popup\"\t\tpopup window |popup|\n\t\t\t\"preview\"\tpreview window |preview-window|\n\t\t\t\"command\"\tcommand-line window |cmdwin|\n\t\t\t(empty)\t\tnormal window\n\t\t\t\"unknown\"\twindow {nr} not found",
   "argsStr": "[{nr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_gotoid",
   "description": "Go to window with ID {expr}.  This may also change the current\n\t\ttabpage.\n\t\tReturn 1 if successful, 0 if the window cannot be found.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_id2tabwin",
   "description": "Return a list with the tab number and window number of window\n\t\twith ID {expr}: [tabnr, winnr].\n\t\tReturn [0, 0] if the window cannot be found.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_id2win",
   "description": "Return the window number of window with ID {expr}.\n\t\tReturn 0 if the window cannot be found in the current tabpage.",
   "argsStr": "{expr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "win_screenpos",
   "description": "Return the screen position of window {nr} as a list with two\n\t\tnumbers: [row, col].  The first window always has position\n\t\t[1, 1], unless there is a tabline, then it is [2, 1].\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tReturn [0, 0] if the window cannot be found in the current\n\t\ttabpage.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winbufnr",
   "description": "The result is a Number, which is the number of the buffer\n\t\tassociated with window {nr}.  {nr} can be the window number or\n\t\tthe |window-ID|.\n\t\tWhen {nr} is zero, the number of the buffer in the current\n\t\twindow is returned.\n\t\tWhen window {nr} doesn't exist, -1 is returned.\n\t\tExample: >\n  :echo \"The file in the current window is \" . bufname(winbufnr(0))\n<",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wincol",
   "description": "The result is a Number, which is the virtual column of the\n\t\tcursor in the window.  This is counting screen cells from the\n\t\tleft side of the window.  The leftmost column is one.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "windowsversion",
   "description": "The result is a String.  For MS-Windows it indicates the OS\n\t\tversion.  E.g, Windows 10 is \"10.0\", Windows 8 is \"6.2\",\n\t\tWindows XP is \"5.1\".  For non-MS-Windows systems the result is\n\t\tan empty string.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winheight",
   "description": "The result is a Number, which is the height of window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero, the height of the current window is\n\t\treturned.  When window {nr} doesn't exist, -1 is returned.\n\t\tAn existing window always has a height of zero or more.\n\t\tThis excludes any window toolbar line.\n\t\tExamples: >\n  :echo \"The current window has \" . winheight(0) . \" lines.\"\n<",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winlayout",
   "description": "The result is a nested List containing the layout of windows\n\t\tin a tabpage.",
   "argsStr": "[{tabnr}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winline",
   "description": "The result is a Number, which is the screen line of the cursor\n\t\tin the window.  This is counting screen lines from the top of\n\t\tthe window.  The first line is one.\n\t\tIf the cursor was moved the view on the file will be updated\n\t\tfirst, this may cause a scroll.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winnr",
   "description": "The result is a Number, which is the number of the current\n\t\twindow.  The top window has number 1.",
   "argsStr": "[{arg}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winrestcmd",
   "description": "Returns a sequence of |:resize| commands that should restore\n\t\tthe current window sizes.  Only works properly when no windows\n\t\tare opened or closed and the current window and tab page is\n\t\tunchanged.\n\t\tExample: >\n\t\t\t:let cmd = winrestcmd()\n\t\t\t:call MessWithWindowSizes()\n\t\t\t:exe cmd\n<",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winrestview",
   "description": "Uses the |Dictionary| returned by |winsaveview()| to restore\n\t\tthe view of the current window.\n\t\tNote: The {dict} does not have to contain all values, that are\n\t\treturned by |winsaveview()|. If values are missing, those\n\t\tsettings won't be restored. So you can use: >\n\t\t    :call winrestview({'curswant': 4})\n<\n\t\tThis will only set the curswant value (the column the cursor\n\t\twants to move on vertical movements) of the cursor to column 5\n\t\t(yes, that is 5), while all other settings will remain the\n\t\tsame. This is useful, if you set the cursor position manually.",
   "argsStr": "{dict}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winsaveview",
   "description": "Returns a |Dictionary| that contains information to restore\n\t\tthe view of the current window.  Use |winrestview()| to\n\t\trestore the view.\n\t\tThis is useful if you have a mapping that jumps around in the\n\t\tbuffer and you want to go back to the original view.\n\t\tThis does not save fold information.  Use the 'foldenable'\n\t\toption to temporarily switch off folding, so that folds are\n\t\tnot opened when moving around. This may have side effects.\n\t\tThe return value includes:\n\t\t\tlnum\t\tcursor line number\n\t\t\tcol\t\tcursor column (Note: the first column\n\t\t\t\t\tzero, as opposed to what getpos()\n\t\t\t\t\treturns)\n\t\t\tcoladd\t\tcursor column offset for 'virtualedit'\n\t\t\tcurswant\tcolumn for vertical movement\n\t\t\ttopline\t\tfirst line in the window\n\t\t\ttopfill\t\tfiller lines, only in diff mode\n\t\t\tleftcol\t\tfirst column displayed\n\t\t\tskipcol\t\tcolumns skipped\n\t\tNote that no option values are saved.",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "winwidth",
   "description": "The result is a Number, which is the width of window {nr}.\n\t\t{nr} can be the window number or the |window-ID|.\n\t\tWhen {nr} is zero, the width of the current window is\n\t\treturned.  When window {nr} doesn't exist, -1 is returned.\n\t\tAn existing window always has a width of zero or more.\n\t\tExamples: >\n  :echo \"The current window has \" . winwidth(0) . \" columns.\"\n  :if winwidth(0) <= 50\n  :  50 wincmd |\n  :endif\n<\t\tFor getting the terminal or screen size, see the 'columns'\n\t\toption.",
   "argsStr": "{nr}",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "wordcount",
   "description": "The result is a dictionary of byte/chars/word statistics for\n\t\tthe current buffer.  This is the same info as provided by\n\t\t|g_CTRL-G|\n\t\tThe return value includes:\n\t\t\tbytes\t\tNumber of bytes in the buffer\n\t\t\tchars\t\tNumber of chars in the buffer\n\t\t\twords\t\tNumber of words in the buffer\n\t\t\tcursor_bytes    Number of bytes before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tcursor_chars    Number of chars before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tcursor_words    Number of words before cursor position\n\t\t\t\t\t(not in Visual mode)\n\t\t\tvisual_bytes    Number of bytes visually selected\n\t\t\t\t\t(only in Visual mode)\n\t\t\tvisual_chars    Number of chars visually selected\n\t\t\t\t\t(only in Visual mode)\n\t\t\tvisual_words    Number of words visually selected\n\t\t\t\t\t(only in Visual mode)",
   "argsStr": "",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "writefile",
   "description": "Write |List| {list} to file {fname}.  Each list item is\n\t\tseparated with a NL.  Each list item must be a String or\n\t\tNumber.\n\t\tWhen {flags} contains \"b\" then binary mode is used: There will\n\t\tnot be a NL after the last list item.  An empty item at the\n\t\tend does cause the last line in the file to end in a NL.",
   "argsStr": "{list}, {fname} [, {flags}]",
   "returnType": "any"
  },
  {
   "type": "func",
   "name": "xor",
   "description": "Bitwise XOR on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let bits = xor(bits, 0x80)\n<",
   "argsStr": "{expr}, {expr}",
   "returnType": "any"
  },
  {
   "type": "value",
   "name": "string-match",
   "description": "",
   "valuetype": "any"
  }
 ]
}